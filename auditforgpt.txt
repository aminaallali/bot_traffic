===== FILE: /workspace/gitlab-org-gitlab/app/graphql/batch_loaders/award_emoji_votes_batch_loader.rb =====
# frozen_string_literal: true

module BatchLoaders
  class AwardEmojiVotesBatchLoader
    def self.load_upvotes(object, awardable_class: nil)
      load_votes_for(object, AwardEmoji::UPVOTE_NAME, awardable_class: awardable_class)
    end

    def self.load_downvotes(object, awardable_class: nil)
      load_votes_for(object, AwardEmoji::DOWNVOTE_NAME, awardable_class: awardable_class)
    end

    def self.load_votes_for(object, vote_type, awardable_class: nil)
      awardable_class ||= object.class.name
      batch_key = "#{object.class.base_class.name}-#{vote_type}"

      BatchLoader::GraphQL.for(object.id).batch(key: batch_key) do |ids, loader, _args|
        counts = AwardEmoji.votes_for_collection(ids, awardable_class).named(vote_type).index_by(&:awardable_id)

        ids.each do |id|
          loader.call(id, counts[id]&.count || 0)
        end
      end
    end
  end
end

BatchLoaders::AwardEmojiVotesBatchLoader.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/batch_loaders/merge_request_diff_summary_batch_loader.rb =====
# frozen_string_literal: true

module BatchLoaders
  class MergeRequestDiffSummaryBatchLoader
    NIL_STATS = { additions: 0, deletions: 0, file_count: 0 }.freeze

    def self.load_for(merge_request)
      BatchLoader::GraphQL.for(merge_request).batch(key: :diff_stats_summary) do |merge_requests, loader, args|
        Preloaders::MergeRequestDiffPreloader.new(merge_requests).preload_all

        merge_requests.each do |merge_request|
          metrics = merge_request.metrics

          summary = if metrics && metrics.added_lines && metrics.removed_lines
                      {
                        additions: metrics.added_lines,
                        deletions: metrics.removed_lines,
                        file_count: merge_request.merge_request_diff&.files_count || 0
                      }
                    elsif merge_request.diff_stats.blank?
                      NIL_STATS
                    else
                      merge_request.diff_stats.each_with_object(NIL_STATS.dup) do |status, summary|
                        summary.merge!(
                          additions: status.additions,
                          deletions: status.deletions,
                          file_count: 1
                        ) do |_, x, y|
                          x + y
                        end
                      end
                    end

          loader.call(merge_request, summary)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/cached_introspection_query.rb =====
# frozen_string_literal: true

module CachedIntrospectionQuery
  def self.query_string
    <<~QUERY.squish
      query IntrospectionQuery {
        __schema {
          queryType {
            name
            kind
          }
          mutationType {
            name
            kind
          }
          subscriptionType {
            name
            kind
          }
          types {
            ...FullType
          }
          directives {
            name
            description
            locations
            args(includeDeprecated: true) {
              ...InputValue
            }
          }
        }
      }
      fragment FullType on __Type {
        kind
        name
        description
        fields(includeDeprecated: true) {
          name
          description
          args(includeDeprecated: true) {
            ...InputValue
          }
          type {
            ...TypeRef
          }
          isDeprecated
          deprecationReason
        }
        inputFields(includeDeprecated: true) {
          ...InputValue
        }
        interfaces {
          ...TypeRef
        }
        enumValues(includeDeprecated: true) {
          name
          description
          isDeprecated
          deprecationReason
        }
        possibleTypes {
          ...TypeRef
        }
      }
      fragment InputValue on __InputValue {
        name
        description
        type {
          ...TypeRef
        }
        defaultValue
        isDeprecated
        deprecationReason
      }
      fragment TypeRef on __Type {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                        ofType {
                          kind
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

    QUERY
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/gitlab_schema.rb =====
# frozen_string_literal: true

class GitlabSchema < GraphQL::Schema
  DEFAULT_MAX_COMPLEXITY = 200
  AUTHENTICATED_MAX_COMPLEXITY = 250
  ADMIN_MAX_COMPLEXITY = 300
  # Current GraphiQL introspection query has complexity of 226.
  # As we cache this specific query we allow it to have a higher complexity.
  INTROSPECTION_MAX_COMPLEXITY = 226

  DEFAULT_MAX_DEPTH = 15
  AUTHENTICATED_MAX_DEPTH = 20

  trace_with Gitlab::Graphql::Tracers::InstrumentationTracer
  trace_with Gitlab::Graphql::VersionFilter::IntroducedTracer

  use Gitlab::Graphql::Subscriptions::ActionCableWithLoadBalancing
  use BatchLoader::GraphQL
  use Gitlab::Graphql::Pagination::Connections
  use Gitlab::Graphql::Timeout, max_seconds: Gitlab.config.gitlab.graphql_timeout

  directive Gitlab::Graphql::VersionFilter::IntroducedDirective

  query_analyzer Gitlab::Graphql::QueryAnalyzers::AST::LoggerAnalyzer
  query_analyzer Gitlab::Graphql::QueryAnalyzers::AST::RecursionAnalyzer

  query Types::QueryType
  mutation Types::MutationType
  subscription Types::SubscriptionType

  default_max_page_size 100

  validate_max_errors 5
  validate_timeout 0.2.seconds

  lazy_resolve ::Gitlab::Graphql::Lazy, :force

  class << self
    def multiplex(queries, **kwargs)
      kwargs[:max_complexity] ||= max_query_complexity(kwargs[:context]) unless kwargs.key?(:max_complexity)

      queries.each do |query|
        query[:max_complexity] ||= max_query_complexity(query[:context]) unless query.key?(:max_complexity)
        query[:max_depth] = max_query_depth(query[:context]) unless query.key?(:max_depth)
      end

      super(queries, **kwargs)
    end

    def get_type(type_name, *other_args)
      type_name = Gitlab::GlobalId::Deprecations.apply_to_graphql_name(type_name)
      type_name = Gitlab::Graphql::TypeNameDeprecations.apply_to_graphql_name(type_name)

      super(type_name, *other_args)
    end

    def id_from_object(object, _type = nil, _ctx = nil)
      unless object.respond_to?(:to_global_id)
        # This is an error in our schema and needs to be solved. So raise a
        # more meaningful error message
        raise "#{object} does not implement `to_global_id`. " \
          "Include `GlobalID::Identification` into `#{object.class}"
      end

      object.to_global_id
    end

    # Find an object by looking it up from its global ID, passed as a string.
    #
    # This is the composition of 'parse_gid' and 'find_by_gid', see these
    # methods for further documentation.
    def object_from_id(global_id, ctx = {})
      gid = parse_gid(global_id, ctx)

      find_by_gid(gid)
    end

    def resolve_type(type, object, ctx = :__undefined__)
      return if type.respond_to?(:assignable?) && !type.assignable?(object)

      if type.kind.object?
        type
      else
        super
      end
    end

    # Find an object by looking it up from its 'GlobalID'.
    #
    # * For `ApplicationRecord`s, this is equivalent to
    #   `global_id.model_class.find(gid.model_id)`, but more efficient.
    # * For classes that implement `.lazy_find(global_id)`, this class method
    #   will be called.
    # * All other classes will use `GlobalID#find`
    def find_by_gid(gid)
      return unless gid

      if gid.model_class < ApplicationRecord
        Gitlab::Graphql::Loaders::BatchModelLoader.new(gid.model_class, gid.model_id).find
      elsif gid.model_class.respond_to?(:lazy_find)
        gid.model_class.lazy_find(gid.model_id)
      else
        begin
          gid.find
        # other if conditions return nil when the record is not found
        rescue ActiveRecord::RecordNotFound
          nil
        end
      end
    end

    # Parse a string to a GlobalID, raising ArgumentError if there are problems
    # with it.
    #
    # Problems that may occur:
    #  * it may not be syntactically valid
    #  * it may not match the expected type (see below)
    #
    # Options:
    #  * :expected_type [Class] - the type of object this GlobalID should refer to.
    #  * :expected_type [[Class]] - array of the types of object this GlobalID should refer to.
    #
    # e.g.
    #
    # ```
    #   gid = GitlabSchema.parse_gid(my_string, expected_type: ::Project)
    #   project_id = gid.model_id
    #   gid.model_class == ::Project
    # ```
    def parse_gid(global_id, ctx = {})
      expected_types = Array(ctx[:expected_type])
      gid = GlobalID.parse(global_id)

      raise Gitlab::Graphql::Errors::ArgumentError, "#{global_id} is not a valid GitLab ID." unless gid

      if expected_types.any? && expected_types.none? { |type| gid.model_class.ancestors.include?(type) }
        vars = { global_id: global_id, expected_types: expected_types.join(', ') }
        msg = _('%{global_id} is not a valid ID for %{expected_types}.') % vars
        raise Gitlab::Graphql::Errors::ArgumentError, msg
      end

      gid
    end

    # Parse an array of strings to an array of GlobalIDs, raising ArgumentError if there are problems
    # with it.
    # See #parse_gid
    #
    # ```
    #   gids = GitlabSchema.parse_gids(my_array_of_strings, expected_type: ::Project)
    #   project_ids = gids.map(&:model_id)
    #   gids.all? { |gid| gid.model_class == ::Project }
    # ```
    def parse_gids(global_ids, ctx = {})
      global_ids.map { |gid| parse_gid(gid, ctx) }
    end

    def unauthorized_field(error)
      return error.field.if_unauthorized if error.field.respond_to?(:if_unauthorized) && error.field.if_unauthorized

      super
    end

    private

    def max_query_complexity(ctx)
      current_user = ctx&.fetch(:current_user, nil)
      introspection = ctx&.fetch(:introspection, false)

      if current_user&.admin
        ADMIN_MAX_COMPLEXITY
      elsif current_user
        AUTHENTICATED_MAX_COMPLEXITY
      elsif introspection
        INTROSPECTION_MAX_COMPLEXITY
      else
        DEFAULT_MAX_COMPLEXITY
      end
    end

    def max_query_depth(ctx)
      current_user = ctx&.fetch(:current_user, nil)

      if current_user
        AUTHENTICATED_MAX_DEPTH
      else
        DEFAULT_MAX_DEPTH
      end
    end
  end

  def get_type(type_name)
    type_name = Gitlab::GlobalId::Deprecations.apply_to_graphql_name(type_name)
    type_name = Gitlab::Graphql::TypeNameDeprecations.apply_to_graphql_name(type_name)

    super(type_name)
  end
end

GitlabSchema.prepend_mod_with('GitlabSchema')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/graphql_triggers.rb =====
# frozen_string_literal: true

module GraphqlTriggers
  def self.ci_job_status_updated(job)
    GitlabSchema.subscriptions.trigger(:ci_job_status_updated, { job_id: job.to_gid }, job)
  end

  def self.ci_pipeline_status_updated(pipeline)
    GitlabSchema.subscriptions.trigger(:ci_pipeline_status_updated, { pipeline_id: pipeline.to_gid }, pipeline)
  end

  def self.issuable_assignees_updated(issuable)
    GitlabSchema.subscriptions.trigger(:issuable_assignees_updated, { issuable_id: issuable.to_gid }, issuable)
  end

  def self.issue_crm_contacts_updated(issue)
    GitlabSchema.subscriptions.trigger(:issue_crm_contacts_updated, { issuable_id: issue.to_gid }, issue)
  end

  def self.issuable_title_updated(issuable)
    GitlabSchema.subscriptions.trigger(:issuable_title_updated, { issuable_id: issuable.to_gid }, issuable)
  end

  def self.issuable_description_updated(issuable)
    GitlabSchema.subscriptions.trigger(:issuable_description_updated, { issuable_id: issuable.to_gid }, issuable)
  end

  def self.issuable_labels_updated(issuable)
    GitlabSchema.subscriptions.trigger(:issuable_labels_updated, { issuable_id: issuable.to_gid }, issuable)
  end

  def self.issuable_dates_updated(issuable)
    GitlabSchema.subscriptions.trigger(:issuable_dates_updated, { issuable_id: issuable.to_gid }, issuable)
  end

  def self.issuable_milestone_updated(issuable)
    GitlabSchema.subscriptions.trigger(:issuable_milestone_updated, { issuable_id: issuable.to_gid }, issuable)
  end

  def self.work_item_note_created(work_item_gid, note_data)
    GitlabSchema.subscriptions.trigger(:work_item_note_created, { noteable_id: work_item_gid }, note_data)
  end

  def self.work_item_note_deleted(work_item_gid, note_data)
    GitlabSchema.subscriptions.trigger(:work_item_note_deleted, { noteable_id: work_item_gid }, note_data)
  end

  def self.work_item_note_updated(work_item_gid, note_data)
    GitlabSchema.subscriptions.trigger(:work_item_note_updated, { noteable_id: work_item_gid }, note_data)
  end

  def self.merge_request_reviewers_updated(merge_request)
    GitlabSchema.subscriptions.trigger(
      :merge_request_reviewers_updated, { issuable_id: merge_request.to_gid }, merge_request
    )
  end

  def self.merge_request_merge_status_updated(merge_request)
    GitlabSchema.subscriptions.trigger(
      :merge_request_merge_status_updated, { issuable_id: merge_request.to_gid }, merge_request
    )
  end

  def self.merge_request_approval_state_updated(merge_request)
    GitlabSchema.subscriptions.trigger(
      :merge_request_approval_state_updated, { issuable_id: merge_request.to_gid }, merge_request
    )
  end

  def self.merge_request_diff_generated(merge_request)
    GitlabSchema.subscriptions.trigger(
      :merge_request_diff_generated, { issuable_id: merge_request.to_gid }, merge_request
    )
  end

  def self.work_item_updated(work_item)
    # becomes is necessary here since this can be triggered with both a WorkItem and also an Issue
    # depending on the update service the call comes from
    work_item = work_item.becomes(::WorkItem) if work_item.is_a?(::Issue) # rubocop:disable Cop/AvoidBecomes

    ::GitlabSchema.subscriptions.trigger('workItemUpdated', { work_item_id: work_item.to_gid }, work_item)
  end

  def self.issuable_todo_updated(issuable)
    return unless issuable.respond_to?(:to_gid)

    ::GitlabSchema.subscriptions.trigger(
      :issuable_todo_updated, { issuable_id: issuable.to_gid }, issuable
    )
  end

  def self.user_merge_request_updated(user, merge_request)
    return unless Feature.enabled?(:merge_request_dashboard, user, type: :beta)

    GitlabSchema.subscriptions.trigger(:user_merge_request_updated, { user_id: user.to_gid }, merge_request)
  end
end

GraphqlTriggers.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/award.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class Award < BaseMutation
      graphql_name 'AchievementsAward'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :user_achievement,
        ::Types::Achievements::UserAchievementType,
        null: true,
        description: 'Achievement award.'

      argument :achievement_id, ::Types::GlobalIDType[::Achievements::Achievement],
        required: true,
        description: 'Global ID of the achievement being awarded.'

      argument :user_id, ::Types::GlobalIDType[::User],
        required: true,
        description: 'Global ID of the user being awarded the achievement.'

      authorize :award_achievement

      def resolve(args)
        achievement = authorized_find!(id: args[:achievement_id])

        recipient_id = args[:user_id].model_id
        result = ::Achievements::AwardService.new(current_user, achievement.id, recipient_id).execute
        { user_achievement: result.payload, errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/create.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class Create < BaseMutation
      graphql_name 'AchievementsCreate'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :achievement,
        ::Types::Achievements::AchievementType,
        null: true,
        description: 'Achievement created.'

      argument :namespace_id, ::Types::GlobalIDType[::Namespace],
        required: true,
        description: 'Namespace for the achievement.'

      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Name for the achievement.'

      argument :avatar, ApolloUploadServer::Upload,
        required: false,
        description: 'Avatar for the achievement.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description of or notes for the achievement.'

      authorize :admin_achievement

      def resolve(args)
        namespace = authorized_find!(id: args[:namespace_id])

        if Feature.disabled?(:achievements, namespace)
          raise_resource_not_available_error! '`achievements` feature flag is disabled.'
        end

        result = ::Achievements::CreateService.new(namespace: namespace,
          current_user: current_user,
          params: args).execute
        { achievement: result.payload, errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class Delete < BaseMutation
      graphql_name 'AchievementsDelete'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :achievement,
        ::Types::Achievements::AchievementType,
        null: true,
        description: 'Achievement.'

      argument :achievement_id, ::Types::GlobalIDType[::Achievements::Achievement],
        required: true,
        description: 'Global ID of the achievement being deleted.'

      authorize :admin_achievement

      def resolve(args)
        achievement = authorized_find!(id: args[:achievement_id])

        result = ::Achievements::DestroyService.new(current_user, achievement).execute
        { achievement: result.payload, errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/delete_user_achievement.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class DeleteUserAchievement < BaseMutation
      graphql_name 'UserAchievementsDelete'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :user_achievement,
        ::Types::Achievements::UserAchievementType,
        null: true,
        description: 'Deleted user achievement.'

      argument :user_achievement_id, ::Types::GlobalIDType[::Achievements::UserAchievement],
        required: true,
        description: 'Global ID of the user achievement being deleted.'

      authorize :destroy_user_achievement

      def resolve(args)
        user_achievement = authorized_find!(id: args[:user_achievement_id])

        result = ::Achievements::DestroyUserAchievementService.new(current_user, user_achievement).execute
        { user_achievement: result.payload, errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/revoke.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class Revoke < BaseMutation
      graphql_name 'AchievementsRevoke'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :user_achievement,
        ::Types::Achievements::UserAchievementType,
        null: true,
        description: 'Achievement award.'

      argument :user_achievement_id, ::Types::GlobalIDType[::Achievements::UserAchievement],
        required: true,
        description: 'Global ID of the user achievement being revoked.'

      authorize :award_achievement

      def resolve(args)
        user_achievement = authorized_find!(id: args[:user_achievement_id])

        result = ::Achievements::RevokeService.new(current_user, user_achievement).execute
        { user_achievement: result.payload, errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/update.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class Update < BaseMutation
      graphql_name 'AchievementsUpdate'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :achievement,
        ::Types::Achievements::AchievementType,
        null: true,
        description: 'Achievement.'

      argument :achievement_id, ::Types::GlobalIDType[::Achievements::Achievement],
        required: true,
        description: 'Global ID of the achievement being updated.'

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Name for the achievement.'

      argument :avatar, ApolloUploadServer::Upload,
        required: false,
        description: 'Avatar for the achievement.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description of or notes for the achievement.'

      authorize :admin_achievement

      def resolve(args)
        achievement = authorized_find!(id: args[:achievement_id])

        args.delete(:achievement_id)
        result = ::Achievements::UpdateService.new(current_user, achievement, args).execute
        { achievement: result.payload, errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/update_user_achievement_priorities.rb =====
# frozen_string_literal: true

module Mutations
  module Achievements
    class UpdateUserAchievementPriorities < BaseMutation
      graphql_name 'UserAchievementPrioritiesUpdate'

      field :user_achievements,
        [::Types::Achievements::UserAchievementType],
        null: false,
        description: 'Updated user achievements.'

      argument :user_achievement_ids,
        [::Types::GlobalIDType[::Achievements::UserAchievement]],
        required: true,
        description: 'Global IDs of the user achievements being prioritized, ' \
          'ordered from highest to lowest priority.'

      def resolve(args)
        user_achievements = args.delete(:user_achievement_ids).map { |id| find_object(id) }

        user_achievements.each do |user_achievement|
          unless Ability.allowed?(current_user, :update_owned_user_achievement, user_achievement)
            raise_resource_not_available_error!
          end
        end

        result = ::Achievements::UpdateUserAchievementPrioritiesService.new(current_user, user_achievements).execute
        { user_achievements: result.payload, errors: result.errors }
      end

      def find_object(id)
        ::Gitlab::Graphql::Lazy.force(GitlabSchema.object_from_id(id, expected_type: ::Achievements::UserAchievement))
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/achievements/update_user_achievement.rb =====
# frozen_string_literal: true

module Mutations
  # rubocop:disable Gitlab/BoundedContexts -- the Achievements module already exists and holds the other mutations as well
  module Achievements
    class UpdateUserAchievement < BaseMutation
      graphql_name 'UserAchievementsUpdate'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      field :user_achievement,
        ::Types::Achievements::UserAchievementType,
        null: true,
        description: 'Achievement award.'

      argument :user_achievement_id,
        ::Types::GlobalIDType[::Achievements::UserAchievement],
        required: true,
        description: 'Global ID of the user achievement being updated.'

      argument :show_on_profile,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Indicates whether or not the user achievement is visible on the profile.'

      authorize :update_user_achievement

      def resolve(args)
        user_achievement = authorized_find!(id: args.delete(:user_achievement_id))

        result = ::Achievements::UpdateUserAchievementService.new(current_user, user_achievement, args).execute
        { user_achievement: result.payload, errors: result.errors }
      end

      def find_object(id:)
        GitlabSchema.object_from_id(id)
      end
    end
  end
  # rubocop:enable Gitlab/BoundedContexts
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/admin/abuse_report_labels/create.rb =====
# frozen_string_literal: true

module Mutations
  module Admin
    module AbuseReportLabels
      class Create < BaseMutation
        graphql_name 'AbuseReportLabelCreate'

        field :label, Types::AntiAbuse::AbuseReportLabelType, null: true, description: 'Label after mutation.'

        argument :title, GraphQL::Types::String, required: true, description: 'Title of the label.'

        argument :color, GraphQL::Types::String, required: false, default_value: Label::DEFAULT_COLOR,
          see: {
            'List of color keywords at mozilla.org' =>
              'https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords'
          },
          description: <<~DESC
            The color of the label given in 6-digit hex notation with leading '#' sign
            (for example, `#FFAABB`) or one of the CSS color names.
          DESC

        def resolve(args)
          raise_resource_not_available_error! unless current_user.can?(:admin_all_resources)

          label = ::Admin::AbuseReportLabels::CreateService.new(args).execute

          {
            label: label.persisted? ? label : nil,
            errors: errors_on_object(label)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/admin/sidekiq_queues/delete_jobs.rb =====
# frozen_string_literal: true

module Mutations
  module Admin
    module SidekiqQueues
      class DeleteJobs < BaseMutation
        graphql_name 'AdminSidekiqQueuesDeleteJobs'

        ADMIN_MESSAGE = 'You must be an admin to use this mutation'

        ::Gitlab::ApplicationContext.allowed_job_keys.each do |key|
          argument key,
            GraphQL::Types::String,
            required: false,
            description: "Delete jobs matching #{key} in the context metadata."
        end

        argument ::Gitlab::SidekiqQueue::WORKER_KEY,
          GraphQL::Types::String,
          required: false,
          description: 'Delete jobs with the given worker class.'

        argument :queue_name,
          GraphQL::Types::String,
          required: true,
          description: 'Name of the queue to delete jobs from.'

        field :result,
          Types::Admin::SidekiqQueues::DeleteJobsResponseType,
          null: true,
          description: 'Information about the status of the deletion request.'

        def ready?(**args)
          raise_resource_not_available_error! ADMIN_MESSAGE unless current_user&.admin?

          super
        end

        def resolve(queue_name:, **args)
          {
            result: Gitlab::SidekiqQueue.new(queue_name).drop_jobs!(args, timeout: 30),
            errors: []
          }
        rescue Gitlab::SidekiqQueue::NoMetadataError
          {
            result: nil,
            errors: ['No metadata provided']
          }
        rescue Gitlab::SidekiqQueue::InvalidQueueError
          raise_resource_not_available_error! "Queue #{queue_name} not found"
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/alerts/set_assignees.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module Alerts
      class SetAssignees < Base
        graphql_name 'AlertSetAssignees'

        argument :assignee_usernames,
          [GraphQL::Types::String],
          required: true,
          description: 'Usernames to assign to the alert. Replaces existing assignees by default.'

        argument :operation_mode,
          Types::MutationOperationModeEnum,
          required: false,
          description: 'Operation to perform. Defaults to REPLACE.'

        def resolve(args)
          alert = authorized_find!(project_path: args[:project_path], iid: args[:iid])
          result = set_assignees(alert, args[:assignee_usernames], args[:operation_mode])

          track_alert_events('incident_management_alert_assigned', alert)

          prepare_response(result)
        end

        private

        def set_assignees(alert, assignee_usernames, operation_mode)
          operation_mode ||= Types::MutationOperationModeEnum.enum[:replace]

          original_assignees = alert.assignees
          target_users = find_target_users(assignee_usernames)

          assignees = case Types::MutationOperationModeEnum.enum.key(operation_mode).to_sym
                      when :replace then target_users.uniq
                      when :append then (original_assignees + target_users).uniq
                      when :remove then (original_assignees - target_users)
                      end

          ::AlertManagement::Alerts::UpdateService.new(alert, current_user, assignees: assignees).execute
        end

        def find_target_users(assignee_usernames)
          UsersFinder.new(current_user, username: assignee_usernames).execute
        end

        def prepare_response(result)
          {
            alert: result.payload[:alert],
            errors: result.error? ? [result.message] : []
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/alerts/todo/create.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module Alerts
      module Todo
        class Create < Base
          graphql_name 'AlertTodoCreate'

          def resolve(args)
            alert = authorized_find!(project_path: args[:project_path], iid: args[:iid])
            result = ::AlertManagement::Alerts::Todo::CreateService.new(alert, current_user).execute

            track_alert_events('incident_management_alert_todo', alert)

            prepare_response(result)
          end

          private

          def prepare_response(result)
            {
              alert: result.payload[:alert],
              todo: result.payload[:todo],
              errors: result.error? ? [result.message] : []
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/base.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    class Base < BaseMutation
      include Gitlab::Utils::UsageData

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Project the alert to mutate is in."

      argument :iid, GraphQL::Types::String,
        required: true,
        description: "IID of the alert to mutate."

      field :alert,
        Types::AlertManagement::AlertType,
        null: true,
        description: "Alert after mutation."

      field :todo,
        Types::TodoType,
        null: true,
        description: "To-do item after mutation."

      field :issue,
        Types::IssueType,
        null: true,
        description: "Issue created after mutation."

      authorize :update_alert_management_alert

      private

      def find_object(project_path:, **args)
        project = Project.find_by_full_path(project_path)

        return unless project

        ::AlertManagement::AlertsFinder.new(current_user, project, args).execute.first
      end

      def track_alert_events(event, alert)
        project = alert.project
        namespace = project.namespace
        track_usage_event(event, current_user.id)

        Gitlab::Tracking.event(
          self.class.to_s,
          event,
          project: project,
          namespace: namespace,
          user: current_user,
          label: 'redis_hll_counters.incident_management.incident_management_total_unique_counts_monthly',
          context: [Gitlab::Tracking::ServicePingContext.new(data_source: :redis_hll, event: event).to_context]
        )
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/create_alert_issue.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    class CreateAlertIssue < Base
      graphql_name 'CreateAlertIssue'

      def resolve(args)
        alert = authorized_find!(project_path: args[:project_path], iid: args[:iid])
        if Feature.enabled?(:hide_incident_management_features, alert.project)
          raise_resource_not_available_error! 'This feature is not available.'
        end

        result = create_alert_issue(alert, current_user)

        track_alert_events('incident_management_incident_created', alert)
        track_usage_event(:incident_management_alert_create_incident, current_user.id)

        prepare_response(alert, result)
      end

      private

      def create_alert_issue(alert, user)
        ::AlertManagement::CreateAlertIssueService.new(alert, user).execute
      end

      def prepare_response(alert, result)
        {
          alert: alert,
          issue: result[:issue],
          errors: result.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/http_integration/create.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module HttpIntegration
      class Create < HttpIntegrationBase
        graphql_name 'HttpIntegrationCreate'

        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project to create the integration in.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the integration.'

        argument :type, Types::AlertManagement::IntegrationTypeEnum,
          as: :type_identifier,
          required: false,
          default_value: :http,
          replace_null_with_default: true,
          description: 'Type of integration to create. Cannot be changed after creation.'

        argument :active, GraphQL::Types::Boolean,
          required: true,
          description: 'Whether the integration is receiving alerts.'

        def resolve(args)
          project = authorized_find!(args[:project_path])

          response ::AlertManagement::HttpIntegrations::CreateService.new(
            project,
            current_user,
            http_integration_params(project, args)
          ).execute
        end
      end
    end
  end
end

Mutations::AlertManagement::HttpIntegration::Create.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/http_integration/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module HttpIntegration
      class Destroy < HttpIntegrationBase
        graphql_name 'HttpIntegrationDestroy'

        argument :id, Types::GlobalIDType[::AlertManagement::HttpIntegration],
          required: true,
          description: "ID of the integration to remove."

        def resolve(id:)
          integration = authorized_find!(id: id)

          response ::AlertManagement::HttpIntegrations::DestroyService.new(
            integration,
            current_user
          ).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/http_integration/http_integration_base.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module HttpIntegration
      class HttpIntegrationBase < BaseMutation
        field :integration,
          Types::AlertManagement::HttpIntegrationType,
          null: true,
          description: "Alerting integration."

        authorize :admin_operations

        private

        def response(result)
          {
            integration: result.payload[:integration],
            errors: result.errors
          }
        end

        # overriden in EE
        def http_integration_params(_project, args)
          args.slice(:name, :active, :type_identifier)
        end
      end
    end
  end
end

Mutations::AlertManagement::HttpIntegration::HttpIntegrationBase.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/http_integration/reset_token.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module HttpIntegration
      class ResetToken < HttpIntegrationBase
        graphql_name 'HttpIntegrationResetToken'

        argument :id, Types::GlobalIDType[::AlertManagement::HttpIntegration],
          required: true,
          description: "ID of the integration to mutate."

        def resolve(id:)
          integration = authorized_find!(id: id)

          response ::AlertManagement::HttpIntegrations::UpdateService.new(
            integration,
            current_user,
            regenerate_token: true
          ).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/http_integration/update.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    module HttpIntegration
      class Update < HttpIntegrationBase
        graphql_name 'HttpIntegrationUpdate'

        argument :id, Types::GlobalIDType[::AlertManagement::HttpIntegration],
          required: true,
          description: "ID of the integration to mutate."

        argument :name, GraphQL::Types::String,
          required: false,
          description: "Name of the integration."

        argument :active, GraphQL::Types::Boolean,
          required: false,
          description: "Whether the integration is receiving alerts."

        def resolve(args)
          integration = authorized_find!(id: args[:id])

          response ::AlertManagement::HttpIntegrations::UpdateService.new(
            integration,
            current_user,
            http_integration_params(integration.project, args)
          ).execute
        end
      end
    end
  end
end

Mutations::AlertManagement::HttpIntegration::Update.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/prometheus_integration/create.rb =====
# frozen_string_literal: true

# Deprecated:
#   Remove from MutationType during any major release.
module Mutations
  module AlertManagement
    module PrometheusIntegration
      class Create < HttpIntegration::Create
        graphql_name 'PrometheusIntegrationCreate'

        field :integration,
          Types::AlertManagement::PrometheusIntegrationType,
          null: true,
          description: "Newly created integration."

        argument :name, GraphQL::Types::String,
          required: false,
          description: 'Name of the integration.',
          default_value: 'Prometheus'

        argument :api_url, GraphQL::Types::String,
          required: false,
          description: 'Endpoint at which Prometheus can be queried.',
          deprecated: { reason: 'Feature removed in 16.0', milestone: '18.2' }

        def resolve(args)
          super(args.merge(name: 'Prometheus', type_identifier: :prometheus))
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/prometheus_integration/reset_token.rb =====
# frozen_string_literal: true

# Deprecated:
#   Remove from MutationType during any major release.
module Mutations
  module AlertManagement
    module PrometheusIntegration
      class ResetToken < HttpIntegration::ResetToken
        graphql_name 'PrometheusIntegrationResetToken'

        field :integration,
          Types::AlertManagement::PrometheusIntegrationType,
          null: true,
          description: "Updated integration."

        argument :id, Types::GlobalIDType[::Integrations::Prometheus],
          required: true,
          description: "ID of the integration to mutate."

        def authorized_find!(**)
          integration = super&.project
            &.alert_management_http_integrations
            &.for_endpoint_identifier('legacy-prometheus')
            &.take

          integration || raise_resource_not_available_error!
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/prometheus_integration/update.rb =====
# frozen_string_literal: true

# Deprecated:
#   Remove from MutationType during any major release.
module Mutations
  module AlertManagement
    module PrometheusIntegration
      class Update < HttpIntegration::Update
        graphql_name 'PrometheusIntegrationUpdate'

        field :integration,
          Types::AlertManagement::PrometheusIntegrationType,
          null: true,
          description: "Updated integration."

        argument :id, Types::GlobalIDType[::Integrations::Prometheus],
          required: true,
          description: "ID of the integration to mutate."

        argument :api_url, GraphQL::Types::String,
          required: false,
          description: "Endpoint at which Prometheus can be queried.",
          deprecated: { reason: 'Feature removed in 16.0', milestone: '18.2' }

        def resolve(args)
          super(args.except(:name))
        end

        def authorized_find!(**)
          integration = super&.project
            &.alert_management_http_integrations
            &.for_endpoint_identifier('legacy-prometheus')
            &.take

          integration || raise_resource_not_available_error!
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/alert_management/update_alert_status.rb =====
# frozen_string_literal: true

module Mutations
  module AlertManagement
    class UpdateAlertStatus < Base
      graphql_name 'UpdateAlertStatus'

      argument :status, Types::AlertManagement::StatusEnum,
        required: true,
        description: 'Status to set the alert.'

      def resolve(project_path:, iid:, status:)
        alert = authorized_find!(project_path: project_path, iid: iid)
        result = update_status(alert, status)

        track_alert_events('incident_management_alert_status_changed', alert)

        prepare_response(result)
      end

      private

      def update_status(alert, status)
        ::AlertManagement::Alerts::UpdateService
          .new(alert, current_user, status: status)
          .execute
      end

      def prepare_response(result)
        {
          alert: result.payload[:alert],
          errors: result.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/award_emojis/add.rb =====
# frozen_string_literal: true

module Mutations
  module AwardEmojis
    class Add < Base
      graphql_name 'AwardEmojiAdd'

      def resolve(args)
        awardable = authorized_find!(id: args[:awardable_id])

        service = ::AwardEmojis::AddService.new(awardable, args[:name], current_user).execute

        {
          award_emoji: (service[:award] if service[:status] == :success),
          errors: service[:errors] || []
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/award_emojis/base.rb =====
# frozen_string_literal: true

module Mutations
  module AwardEmojis
    class Base < BaseMutation
      NOT_EMOJI_AWARDABLE = 'You cannot add emoji reactions to this resource.'

      authorize :award_emoji

      argument :awardable_id,
        ::Types::GlobalIDType[::Awardable],
        required: true,
        description: 'Global ID of the awardable resource.'

      argument :name,
        GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::AwardEmojis::AwardEmojiType, :name)

      field :award_emoji,
        Types::AwardEmojis::AwardEmojiType,
        null: true,
        description: 'Emoji reactions after mutation.'

      private

      def authorize!(object)
        super
        raise_resource_not_available_error!(NOT_EMOJI_AWARDABLE) unless object.emoji_awardable?
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/award_emojis/remove.rb =====
# frozen_string_literal: true

module Mutations
  module AwardEmojis
    class Remove < Base
      graphql_name 'AwardEmojiRemove'

      def resolve(args)
        awardable = authorized_find!(id: args[:awardable_id])

        service = ::AwardEmojis::DestroyService.new(awardable, args[:name], current_user).execute

        {
          # Mutation response is always a `nil` award_emoji
          errors: service[:errors] || []
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/award_emojis/toggle.rb =====
# frozen_string_literal: true

module Mutations
  module AwardEmojis
    class Toggle < Base
      graphql_name 'AwardEmojiToggle'

      field :toggled_on, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates the status of the emoji. ' \
          'True if the toggle awarded the emoji, and false if the toggle removed the emoji.'

      def resolve(args)
        awardable = authorized_find!(id: args[:awardable_id])

        service = ::AwardEmojis::ToggleService.new(awardable, args[:name], current_user).execute

        toggled_on = awardable.awarded_emoji?(args[:name], current_user)

        {
          # For consistency with the AwardEmojis::Remove mutation, only return
          # the AwardEmoji if it was created and not destroyed
          award_emoji: (service[:award] if toggled_on),
          errors: service[:errors] || [],
          toggled_on: toggled_on
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/base_mutation.rb =====
# frozen_string_literal: true

module Mutations
  class BaseMutation < GraphQL::Schema::RelayClassicMutation
    include Gitlab::Graphql::VersionFilter::FutureFieldFallback
    include Gitlab::Graphql::Authorize::AuthorizeResource
    prepend Gitlab::Graphql::CopyFieldDescription

    ERROR_MESSAGE = 'You cannot perform write operations on a read-only instance'

    field_class ::Types::BaseField
    argument_class ::Types::BaseArgument

    field :errors, [GraphQL::Types::String],
      null: false,
      description: 'Errors encountered during the mutation.',
      scopes: [:api, :read_api, :ai_workflows]

    def current_user
      context[:current_user]
    end

    def api_user?
      context[:is_sessionless_user]
    end

    # Returns Array of errors on an ActiveRecord object
    def errors_on_object(record)
      record.errors.full_messages
    end

    def ready?(**args)
      raise_resource_not_available_error!(ERROR_MESSAGE) if read_only?

      true
    end

    def read_only?
      Gitlab::Database.read_only?
    end

    def load_application_object(argument, id, context)
      ::Gitlab::Graphql::Lazy.new { super }
    end

    def unauthorized_object(error)
      # The default behavior is to abort processing and return nil for the
      # entire mutation field, but not set any top-level errors. We prefer to
      # at least say that something went wrong.
      Gitlab::ErrorTracking.track_exception(error)
      raise_resource_not_available_error!
    end

    def self.authorizes_object?
      true
    end

    def self.authorized?(object, context)
      auth = ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(:execute_graphql_mutation, authorization_scopes)
      return true if auth.ok?(:global, context[:current_user],
        scope_validator: context[:scope_validator])

      # in our mutations we raise, rather than returning a null value.
      raise_resource_not_available_error!
    end

    def self.authorization_scopes
      [:api]
    end

    # See: AuthorizeResource#authorized_resource?
    def self.authorization
      @authorization ||= ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(authorize, authorization_scopes)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/common_mutation_arguments.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module CommonMutationArguments
      extend ActiveSupport::Concern

      included do
        argument :name,
          GraphQL::Types::String,
          required: false,
          description: 'Board name.'
        argument :hide_backlog_list,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::BoardType, :hide_backlog_list)
        argument :hide_closed_list,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::BoardType, :hide_closed_list)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/create.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    class Create < ::Mutations::BaseMutation
      graphql_name 'CreateBoard'

      include Mutations::ResolvesResourceParent
      include Mutations::Boards::CommonMutationArguments

      field :board,
        Types::BoardType,
        null: true,
        description: 'Board after mutation.'

      authorize :admin_issue_board

      def resolve(args)
        board_parent = authorized_resource_parent_find!(args)

        response = ::Boards::CreateService.new(board_parent, current_user, args).execute

        {
          board: response.success? ? response.payload : nil,
          errors: response.errors
        }
      end
    end
  end
end

Mutations::Boards::Create.prepend_mod_with('Mutations::Boards::Create')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    class Destroy < ::Mutations::BaseMutation
      graphql_name 'DestroyBoard'

      field :board,
        Types::BoardType,
        null: true,
        description: 'Board after mutation.'
      argument :id,
        ::Types::GlobalIDType[::Board],
        required: true,
        description: 'Global ID of the board to destroy.'

      authorize :admin_issue_board

      def resolve(id:)
        board = authorized_find!(id: id)

        response = ::Boards::DestroyService.new(board.resource_parent, current_user).execute(board)

        {
          board: response.success? ? nil : board,
          errors: response.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/issues/issue_move_list.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module Issues
      class IssueMoveList < Mutations::Issues::Base
        graphql_name 'IssueMoveList'
        BoardGID = ::Types::GlobalIDType[::Board]
        ListID = ::GraphQL::Types::ID
        IssueID = ::GraphQL::Types::ID

        argument :board_id, BoardGID,
          required: true,
          loads: Types::BoardType,
          description: 'Global ID of the board that the issue is in.'

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project the issue to mutate is in.'

        argument :iid, GraphQL::Types::String,
          required: true,
          description: 'IID of the issue to mutate.'

        argument :from_list_id, ListID,
          required: false,
          description: 'ID of the board list that the issue will be moved from.'

        argument :to_list_id, ListID,
          required: false,
          description: 'ID of the board list that the issue will be moved to.'

        argument :move_before_id, IssueID,
          required: false,
          description: 'ID of issue that should be placed before the current issue.'

        argument :move_after_id, IssueID,
          required: false,
          description: 'ID of issue that should be placed after the current issue.'

        argument :position_in_list, GraphQL::Types::Int,
          required: false,
          description: "Position of issue within the board list. Positions start at 0. " \
            "Use #{::Boards::Issues::MoveService::LIST_END_POSITION} to move to the end of the list."

        def ready?(**args)
          if move_arguments(args).blank?
            raise Gitlab::Graphql::Errors::ArgumentError,
              'At least one of the arguments ' \
                'fromListId, toListId, positionInList, moveAfterId, or moveBeforeId is required'
          end

          if move_list_arguments(args).one?
            raise Gitlab::Graphql::Errors::ArgumentError,
              'Both fromListId and toListId must be present'
          end

          if args[:position_in_list].present?
            if move_list_arguments(args).empty?
              raise Gitlab::Graphql::Errors::ArgumentError,
                'Both fromListId and toListId are required when positionInList is given'
            end

            if args[:move_before_id].present? || args[:move_after_id].present?
              raise Gitlab::Graphql::Errors::ArgumentError,
                'positionInList is mutually exclusive with any of moveBeforeId or moveAfterId'
            end

            if args[:position_in_list] != ::Boards::Issues::MoveService::LIST_END_POSITION &&
                args[:position_in_list] < 0
              raise Gitlab::Graphql::Errors::ArgumentError,
                "positionInList must be >= 0 or #{::Boards::Issues::MoveService::LIST_END_POSITION}"
            end
          end

          super
        end

        def resolve(board:, project_path:, iid:, **args)
          issue = authorized_find!(project_path: project_path, iid: iid)
          move_params = { id: issue.id, board_id: board.id }.merge(move_arguments(args))

          result = move_issue(board, issue, move_params)

          {
            issue: issue.reset,
            errors: error_for(result)
          }
        end

        private

        def move_issue(board, issue, move_params)
          service = ::Boards::Issues::MoveService.new(board.resource_parent, current_user, move_params)

          service.execute(issue)
        end

        def move_list_arguments(args)
          args.slice(:from_list_id, :to_list_id)
        end

        def move_arguments(args)
          args.slice(:from_list_id, :to_list_id, :position_in_list, :move_after_id, :move_before_id)
        end

        def error_for(result)
          return [] unless result.error?

          [result.message]
        end
      end
    end
  end
end

Mutations::Boards::Issues::IssueMoveList.prepend_mod_with('Mutations::Boards::Issues::IssueMoveList')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/lists/base_create.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module Lists
      class BaseCreate < BaseMutation
        argument :backlog, GraphQL::Types::Boolean,
          required: false,
          description: 'Create the backlog list.'

        argument :label_id, ::Types::GlobalIDType[::Label],
          required: false,
          description: 'Global ID of an existing label.'

        def ready?(**args)
          if args.slice(*mutually_exclusive_args).size != 1
            arg_str = mutually_exclusive_args.map { |x| x.to_s.camelize(:lower) }.join(' or ')
            raise Gitlab::Graphql::Errors::ArgumentError, "one and only one of #{arg_str} is required"
          end

          super
        end

        def resolve(**args)
          board  = authorized_find!(id: args[:board_id])
          params = create_list_params(args)

          response = create_list(board, params)

          {
            list: response.success? ? response.payload[:list] : nil,
            errors: response.errors
          }
        end

        private

        def create_list(board, params)
          raise NotImplementedError
        end

        def create_list_params(args)
          params = args.slice(*mutually_exclusive_args).with_indifferent_access
          params[:label_id] &&= ::GitlabSchema.parse_gid(params[:label_id], expected_type: ::Label).model_id
          params[:position] = args[:position]

          params
        end

        def mutually_exclusive_args
          [:backlog, :label_id]
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/lists/base_update.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module Lists
      class BaseUpdate < BaseMutation
        argument :position, GraphQL::Types::Int,
          required: false,
          description: 'Position of list within the board.'

        argument :collapsed, GraphQL::Types::Boolean,
          required: false,
          description: 'Indicates if the list is collapsed for the user.'

        def resolve(list: nil, **args)
          raise_resource_not_available_error! if list.nil? || !can_read_list?(list)

          update_result = update_list(list, args)

          {
            list: update_result.payload[:list],
            errors: update_result.errors
          }
        end

        private

        def update_list(list, args)
          raise NotImplementedError
        end

        def can_read_list?(list)
          raise NotImplementedError
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/lists/create.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module Lists
      class Create < BaseCreate
        graphql_name 'BoardListCreate'

        argument :board_id, ::Types::GlobalIDType[::Board],
          required: true,
          description: 'Global ID of the issue board to mutate.'

        argument :position, GraphQL::Types::Int,
          required: false,
          description: 'Position of the list.'

        field :list,
          Types::BoardListType,
          null: true,
          description: 'Issue list in the issue board.'

        authorize :admin_issue_board_list

        private

        def create_list(board, params)
          create_list_service =
            ::Boards::Lists::CreateService.new(board.resource_parent, current_user, params)

          create_list_service.execute(board)
        end
      end
    end
  end
end

Mutations::Boards::Lists::Create.prepend_mod_with('Mutations::Boards::Lists::Create')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/lists/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module Lists
      class Destroy < ::Mutations::BaseMutation
        graphql_name 'DestroyBoardList'

        field :list,
          Types::BoardListType,
          null: true,
          description: 'List after mutation.'

        argument :list_id, ::Types::GlobalIDType[::List],
          required: true,
          loads: Types::BoardListType,
          description: 'Global ID of the list to destroy. Only label lists are accepted.'

        def resolve(list:)
          raise_resource_not_available_error! unless can_admin_list?(list)

          response = ::Boards::Lists::DestroyService.new(list.board.resource_parent, current_user)
            .execute(list)

          {
            list: response.success? ? nil : list,
            errors: response.errors
          }
        end

        private

        def can_admin_list?(list)
          return false unless list.present?

          Ability.allowed?(current_user, :admin_issue_board_list, list.board)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/lists/update.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    module Lists
      class Update < BaseUpdate
        graphql_name 'UpdateBoardList'

        argument :list_id, Types::GlobalIDType[List],
          required: true,
          loads: Types::BoardListType,
          description: 'Global ID of the list.'

        field :list,
          Types::BoardListType,
          null: true,
          description: 'Mutated list.'

        private

        def update_list(list, args)
          service = ::Boards::Lists::UpdateService.new(list.board, current_user, args)
          service.execute(list)
        end

        def can_read_list?(list)
          Ability.allowed?(current_user, :read_issue_board_list, list.board)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/boards/update.rb =====
# frozen_string_literal: true

module Mutations
  module Boards
    class Update < ::Mutations::BaseMutation
      graphql_name 'UpdateBoard'

      include Mutations::Boards::CommonMutationArguments

      argument :id,
        ::Types::GlobalIDType[::Board],
        required: true,
        description: 'Board global ID.'

      field :board,
        Types::BoardType,
        null: true,
        description: 'Board after mutation.'

      authorize :admin_issue_board

      def resolve(id:, **args)
        board = authorized_find!(id: id)

        ::Boards::UpdateService.new(board.resource_parent, current_user, args).execute(board)

        {
          board: board,
          errors: errors_on_object(board)
        }
      end
    end
  end
end

Mutations::Boards::Update.prepend_mod_with('Mutations::Boards::Update')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/branch_rules/create.rb =====
# frozen_string_literal: true

module Mutations
  module BranchRules
    class Create < BaseMutation
      graphql_name 'BranchRuleCreate'

      authorize :create_branch_rule

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path to the project that the branch is associated with.'

      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Branch name, with wildcards, for the branch rules.'

      field :branch_rule,
        Types::Projects::BranchRuleType,
        null: true,
        description: 'Branch rule after mutation.'

      def resolve(project_path:, name:)
        project = authorized_find!(project_path)

        service_params = protected_branch_params(name)
        protected_branch = ::ProtectedBranches::CreateService.new(project, current_user, service_params).execute

        if protected_branch.persisted?
          {
            branch_rule: ::Projects::BranchRule.new(project, protected_branch),
            errors: []
          }
        else
          { errors: errors_on_object(protected_branch) }
        end
      rescue Gitlab::Access::AccessDeniedError
        raise_resource_not_available_error!
      end

      def protected_branch_params(name)
        {
          name: name,
          push_access_levels_attributes: access_level_attributes(:push),
          merge_access_levels_attributes: access_level_attributes(:merge)
        }
      end

      def access_level_attributes(type)
        ::ProtectedRefs::AccessLevelParams.new(
          type,
          {},
          with_defaults: true
        ).access_levels
      end

      private

      def find_object(full_path)
        Project.find_by_full_path(full_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/branch_rules/delete.rb =====
# frozen_string_literal: true

module Mutations
  module BranchRules
    class Delete < BaseMutation
      graphql_name 'BranchRuleDelete'

      authorize :destroy_branch_rule

      argument :id, ::Types::GlobalIDType[::Projects::BranchRule],
        required: true,
        description: 'Global ID of the branch rule to destroy.'

      field :branch_rule,
        ::Types::Projects::BranchRuleType,
        null: true,
        description: 'Branch rule after mutation.'

      def resolve(id:)
        branch_rule = authorized_find!(id: id)

        response = ::BranchRules::DestroyService.new(branch_rule, current_user).execute

        { branch_rule: (branch_rule if response.error?), errors: response.errors }
      rescue Gitlab::Access::AccessDeniedError
        raise_resource_not_available_error!
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/branch_rules/update.rb =====
# frozen_string_literal: true

module Mutations
  module BranchRules
    class Update < BaseMutation
      graphql_name 'BranchRuleUpdate'

      authorize :update_branch_rule

      argument :id, ::Types::GlobalIDType[::Projects::BranchRule],
        required: true,
        description: 'Global ID of the branch rule to update.'

      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Branch name, with wildcards, for the branch rules.'

      argument :branch_protection, Types::BranchRules::BranchProtectionInputType,
        required: false,
        description: 'Branch protections configured for the branch rule.'

      field :branch_rule,
        Types::Projects::BranchRuleType,
        null: true,
        description: 'Branch rule after mutation.'

      def resolve(id:, **params)
        branch_rule = authorized_find!(id: id)

        response = ::BranchRules::UpdateService.new(branch_rule, current_user, params).execute

        { branch_rule: (branch_rule if response.success?), errors: response.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/catalog/resources/base.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Catalog
      module Resources
        class Base < BaseMutation
          argument :project_path, GraphQL::Types::ID,
            required: true,
            description: 'Project path belonging to the catalog resource.'

          def find_object(project_path:)
            Project.find_by_full_path(project_path)
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/catalog/resources/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Catalog
      module Resources
        class Create < Base
          graphql_name 'CatalogResourcesCreate'

          authorize :add_catalog_resource

          def resolve(project_path:)
            project = authorized_find!(project_path: project_path)
            response = ::Ci::Catalog::Resources::CreateService.new(project, current_user).execute

            errors = response.success? ? [] : [response.message]

            {
              errors: errors
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/catalog/resources/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Catalog
      module Resources
        class Destroy < Base
          graphql_name 'CatalogResourcesDestroy'

          authorize :add_catalog_resource

          def resolve(project_path:)
            project = authorized_find!(project_path: project_path)
            catalog_resource = project.catalog_resource

            response = ::Ci::Catalog::Resources::DestroyService.new(project, current_user).execute(catalog_resource)

            errors = response.success? ? [] : [response.message]

            {
              errors: errors
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_artifact/bulk_destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobArtifact
      class BulkDestroy < BaseMutation
        graphql_name 'BulkDestroyJobArtifacts'

        authorize :destroy_artifacts

        ArtifactId = ::Types::GlobalIDType[::Ci::JobArtifact]
        ProjectId = ::Types::GlobalIDType[::Project]

        argument :ids, [ArtifactId],
          required: true,
          description: 'Global IDs of the job artifacts to destroy.',
          prepare: ->(global_ids, _ctx) { GitlabSchema.parse_gids(global_ids, expected_type: ::Ci::JobArtifact) }

        argument :project_id, ProjectId,
          required: true,
          description: 'Global Project ID of the job artifacts to destroy. Incompatible with projectPath.'

        field :destroyed_count, ::GraphQL::Types::Int,
          null: true,
          description: 'Number of job artifacts deleted.'

        field :destroyed_ids, [ArtifactId],
          null: true,
          description: 'IDs of job artifacts that were deleted.'

        def find_object(id:)
          GlobalID::Locator.locate(id)
        end

        def resolve(**args)
          ids = args[:ids]
          project_id = args[:project_id]

          project = authorized_find!(id: project_id)

          raise Gitlab::Graphql::Errors::ArgumentError, 'IDs array of job artifacts can not be empty' if ids.empty?

          result = ::Ci::JobArtifacts::BulkDeleteByProjectService.new(
            job_artifact_ids: model_ids_of(ids),
            current_user: current_user,
            project: project
          ).execute

          if result.success?
            result.payload.slice(:destroyed_count, :destroyed_ids).merge(errors: [])
          else
            { errors: result.errors }
          end
        end

        private

        def model_ids_of(global_ids)
          global_ids.filter_map { |gid| gid.model_id.to_i }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_artifact/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobArtifact
      class Destroy < BaseMutation
        graphql_name 'ArtifactDestroy'

        authorize :destroy_artifacts

        ArtifactID = ::Types::GlobalIDType[::Ci::JobArtifact]

        argument :id,
          ArtifactID,
          required: true,
          description: 'ID of the artifact to delete.'

        field :artifact,
          Types::Ci::JobArtifactType,
          null: true,
          description: 'Deleted artifact.'

        def find_object(id:)
          GlobalID::Locator.locate(id)
        end

        def resolve(id:)
          artifact = authorized_find!(id: id)

          if artifact.destroy
            { errors: [] }
          else
            { errors: artifact.errors.full_messages }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job/artifacts_destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Job
      class ArtifactsDestroy < Base
        graphql_name 'JobArtifactsDestroy'

        authorize :destroy_artifacts

        field :job,
          Types::Ci::JobType,
          null: true,
          description: 'Job with artifacts to be deleted.'

        field :destroyed_artifacts_count,
          GraphQL::Types::Int,
          null: false,
          description: 'Number of artifacts deleted.'

        def resolve(id:)
          job = authorized_find!(id: id)

          result = ::Ci::JobArtifacts::DeleteService.new(job).execute

          if result.success?
            {
              job: job,
              destroyed_artifacts_count: result.payload[:destroyed_artifacts_count],
              errors: Array(result.payload[:errors])
            }
          else
            {
              job: job,
              destroyed_artifacts_count: 0,
              errors: Array(result.message)
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job/base.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Job
      class Base < BaseMutation
        JobID = ::Types::GlobalIDType[::Ci::Build]

        argument :id, JobID,
          required: true,
          description: 'ID of the job to mutate.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job/cancel.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Job
      class Cancel < Base
        graphql_name 'JobCancel'

        field :job,
          Types::Ci::JobType,
          null: true,
          description: 'Job after the mutation.'

        authorize :cancel_build

        def resolve(id:)
          job = authorized_find!(id: id)

          ::Ci::BuildCancelService.new(job, current_user).execute
          {
            job: job,
            errors: errors_on_object(job)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job/play.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Job
      class Play < Base
        graphql_name 'JobPlay'

        argument :id, ::Types::GlobalIDType[::Ci::Processable],
          required: true,
          description: 'ID of the job to mutate.'

        field :job,
          Types::Ci::JobType,
          null: true,
          description: 'Job after the mutation.'

        argument :variables, [::Types::Ci::VariableInputType],
          required: false,
          default_value: [],
          replace_null_with_default: true,
          description: 'Variables to use when playing a manual job.'

        authorize :update_build

        def resolve(id:, variables:)
          job = authorized_find!(id: id)
          variables = variables.map(&:to_h)

          job.play(current_user, variables)

          {
            job: job,
            errors: errors_on_object(job)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job/retry.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Job
      class Retry < Base
        graphql_name 'JobRetry'

        JobID = ::Types::GlobalIDType[::Ci::Processable]

        argument :id, JobID,
          required: true,
          description: 'ID of the job to mutate.'

        field :job,
          Types::Ci::JobType,
          null: true,
          description: 'Job after the mutation.'

        argument :variables, [::Types::Ci::VariableInputType],
          required: false,
          default_value: [],
          replace_null_with_default: true,
          description: 'Variables to use when retrying a manual job.'

        authorize :update_build

        def resolve(id:, variables:)
          job = authorized_find!(id: id)
          project = job.project
          variables = variables.map(&:to_h)

          response = ::Ci::RetryJobService.new(project, current_user).execute(job, variables: variables)

          if response.success?
            {
              job: response[:job],
              errors: []
            }
          else
            {
              job: nil,
              errors: [response.message]
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/add_group_or_project.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class AddGroupOrProject < BaseMutation
        graphql_name 'CiJobTokenScopeAddGroupOrProject'

        include FindsProject

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project that the CI job token scope belongs to.'

        argument :target_path, GraphQL::Types::ID,
          required: true,
          description: 'Group or project to be added to the CI job token scope.'

        argument :default_permissions, GraphQL::Types::Boolean,
          required: false,
          default_value: true,
          experiment: { milestone: '17.8' },
          description: 'Indicates whether default permissions are enabled (true) or fine-grained permissions are ' \
            'enabled (false).'

        argument :job_token_policies, [Types::Ci::JobTokenScope::PoliciesEnum],
          required: false,
          default_value: [],
          experiment: { milestone: '17.5' },
          description: 'List of policies added to the CI job token scope. Is ignored if ' \
            'job token policies are disabled.'

        field :ci_job_token_scope_allowlist_entry,
          Types::Ci::JobTokenScope::AllowlistEntryType,
          null: true,
          experiment: { milestone: '17.6' },
          description: "Allowlist entry for the CI job token's access scope."

        field :ci_job_token_scope, # rubocop: disable GraphQL/ExtractType -- no value for now
          Types::Ci::JobTokenScopeType,
          null: true,
          description: "CI job token's access scope."

        def resolve(project_path:, target_path:, default_permissions:, job_token_policies:)
          project = authorized_find!(project_path)
          target = find_target_path(target_path)

          result = ::Ci::JobTokenScope::AddGroupOrProjectService
            .new(project, current_user)
            .execute(target, default_permissions: default_permissions, policies: job_token_policies)

          if result.success?
            {
              ci_job_token_scope: ::Ci::JobToken::Scope.new(project),
              ci_job_token_scope_allowlist_entry: result.payload.values[0],
              errors: []
            }
          else
            {
              ci_job_token_scope: nil,
              ci_job_token_scope_allowlist_entry: nil,
              errors: [result.message]
            }
          end
        end

        private

        def find_target_path(target_path)
          ::Group.find_by_full_path(target_path) ||
            ::Project.find_by_full_path(target_path)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/add_project.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class AddProject < BaseMutation
        graphql_name 'CiJobTokenScopeAddProject'

        include FindsProject

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project that the CI job token scope belongs to.'

        argument :target_project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project to be added to the CI job token scope.'

        argument :direction,
          ::Types::Ci::JobTokenScope::DirectionEnum,
          required: false,
          deprecated: {
            reason: 'Outbound job token scope is being removed. This field can now only be set to INBOUND',
            milestone: '16.0'
          },
          description: 'Direction of access, which defaults to INBOUND.'

        field :ci_job_token_scope_allowlist_entry,
          Types::Ci::JobTokenScope::AllowlistEntryType,
          null: true,
          experiment: { milestone: '17.6' },
          description: "Allowlist entry for the CI job token's access scope."

        field :ci_job_token_scope, # rubocop: disable GraphQL/ExtractType -- no value for now
          Types::Ci::JobTokenScopeType,
          null: true,
          description: "CI job token's access scope."

        def resolve(project_path:, target_project_path:, direction: nil)
          project = authorized_find!(project_path)
          target_project = Project.find_by_full_path(target_project_path)

          if direction == :outbound
            raise Gitlab::Graphql::Errors::ArgumentError, 'direction: OUTBOUND scope entries can only be removed. ' \
              'Only INBOUND scope can be expanded.'
          end

          direction ||= :inbound

          result = ::Ci::JobTokenScope::AddProjectService
            .new(project, current_user)
            .execute(target_project, direction: direction)

          if result.success?
            {
              ci_job_token_scope: ::Ci::JobToken::Scope.new(project),
              ci_job_token_scope_allowlist_entry: result.payload[:project_link],
              errors: []
            }
          else
            {
              ci_job_token_scope: nil,
              ci_job_token_scope_allowlist_entry: nil,
              errors: [result.message]
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/autopopulate_allowlist.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class AutopopulateAllowlist < BaseMutation
        graphql_name 'CiJobTokenScopeAutopopulateAllowlist'

        include FindsProject
        include Gitlab::InternalEventsTracking

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project in which to autopopulate the allowlist.'

        field :status,
          GraphQL::Types::String,
          null: false,
          description: "Status of the autopopulation process."

        def resolve(project_path:)
          project = authorized_find!(project_path)

          track_internal_event(
            'ci_job_token_autopopulate_allowlist',
            user: current_user,
            project: project,
            additional_properties: {
              label: 'ui'
            }
          )

          result = ::Ci::JobToken::ClearAutopopulatedAllowlistService.new(project, current_user).execute
          result = ::Ci::JobToken::AutopopulateAllowlistService.new(project, current_user).execute if result.success?

          if result.success?
            { status: "complete", errors: [] }
          else
            { status: "error", errors: [result.message] }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/clear_allowlist_autopopulations.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class ClearAllowlistAutopopulations < BaseMutation
        graphql_name 'CiJobTokenScopeClearAllowlistAutopopulations'

        include FindsProject

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project in which to autopopulate the allowlist.'

        field :status,
          GraphQL::Types::String,
          null: false,
          description: "Status of the autopopulation process."

        def resolve(project_path:)
          project = authorized_find!(project_path)

          result = ::Ci::JobToken::ClearAutopopulatedAllowlistService.new(project, current_user).execute

          if result.success?
            { status: "complete", errors: [] }
          else
            { status: "error", errors: [result.message] }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/remove_group.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class RemoveGroup < BaseMutation
        graphql_name 'CiJobTokenScopeRemoveGroup'

        include FindsProject

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project that the CI job token scope belongs to.'

        argument :target_group_path, GraphQL::Types::ID,
          required: true,
          description: 'Group to be removed from the CI job token scope.'

        field :ci_job_token_scope_allowlist_entry,
          Types::Ci::JobTokenScope::AllowlistEntryType,
          null: true,
          experiment: { milestone: '17.6' },
          description: "Allowlist entry for the CI job token's access scope."

        field :ci_job_token_scope, # rubocop: disable GraphQL/ExtractType -- no value for now
          Types::Ci::JobTokenScopeType,
          null: true,
          description: "CI job token's access scope."

        def resolve(project_path:, target_group_path:)
          project = authorized_find!(project_path)
          target_group = Group.find_by_full_path(target_group_path)

          result = ::Ci::JobTokenScope::RemoveGroupService
            .new(project, current_user)
            .execute(target_group)

          if result.success?
            {
              ci_job_token_scope: ::Ci::JobToken::Scope.new(project),
              ci_job_token_scope_allowlist_entry: result.payload,
              errors: []
            }
          else
            {
              ci_job_token_scope: nil,
              ci_job_token_scope_allowlist_entry: nil,
              errors: [result.message]
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/remove_project.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class RemoveProject < BaseMutation
        graphql_name 'CiJobTokenScopeRemoveProject'

        include FindsProject

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project that the CI job token scope belongs to.'

        argument :target_project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project to be removed from the CI job token scope.'

        argument :direction,
          ::Types::Ci::JobTokenScope::DirectionEnum,
          required: false,
          deprecated: {
            reason: 'Outbound job token scope is being removed. This field can now only be set to INBOUND',
            milestone: '16.9'
          },
          description: 'Direction of access, which defaults to inbound.'

        field :ci_job_token_scope_allowlist_entry,
          Types::Ci::JobTokenScope::AllowlistEntryType,
          null: true,
          experiment: { milestone: '17.6' },
          description: "Allowlist entry for the CI job token's access scope."

        field :ci_job_token_scope, # rubocop: disable GraphQL/ExtractType -- no value for now
          Types::Ci::JobTokenScopeType,
          null: true,
          description: "CI job token's access scope."

        def resolve(
          project_path:, target_project_path:,
          direction: ::Types::Ci::JobTokenScope::DirectionEnum.values["INBOUND"].value)
          project = authorized_find!(project_path)
          target_project = Project.find_by_full_path(target_project_path)

          result = ::Ci::JobTokenScope::RemoveProjectService
            .new(project, current_user)
            .execute(target_project, direction)

          if result.success?
            {
              ci_job_token_scope: ::Ci::JobToken::Scope.new(project),
              ci_job_token_scope_allowlist_entry: result.payload,
              errors: []
            }
          else
            {
              ci_job_token_scope: nil,
              ci_job_token_scope_allowlist_entry: nil,
              errors: [result.message]
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job_token_scope/update_job_token_policies.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module JobTokenScope
      class UpdateJobTokenPolicies < BaseMutation
        graphql_name 'CiJobTokenScopeUpdatePolicies'

        include FindsProject

        authorize :admin_project

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project that the CI job token scope belongs to.'

        argument :target_path, GraphQL::Types::ID,
          required: true,
          description: 'Group or project that the CI job token targets.'

        argument :default_permissions, GraphQL::Types::Boolean,
          required: true,
          description: 'Indicates whether default permissions are enabled (true) or fine-grained permissions are ' \
            'enabled (false).'

        argument :job_token_policies, [Types::Ci::JobTokenScope::PoliciesEnum],
          required: true,
          description: 'List of policies added to the CI job token scope.'

        field :ci_job_token_scope_allowlist_entry,
          Types::Ci::JobTokenScope::AllowlistEntryType,
          null: true,
          experiment: { milestone: '17.6' },
          description: "Allowlist entry for the CI job token's access scope."

        def resolve(project_path:, target_path:, default_permissions:, job_token_policies:)
          project = authorized_find!(project_path)
          target = find_target_using_path(target_path)

          result = ::Ci::JobTokenScope::UpdatePoliciesService
            .new(project, current_user)
            .execute(target, default_permissions, job_token_policies)

          if result.success?
            {
              ci_job_token_scope_allowlist_entry: result.payload,
              errors: []
            }
          else
            {
              ci_job_token_scope_allowlist_entry: nil,
              errors: [result.message]
            }
          end
        end

        private

        def find_target_using_path(target_path)
          ::Group.find_by_full_path(target_path) ||
            ::Project.find_by_full_path(target_path)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/job/unschedule.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Job
      class Unschedule < Base
        graphql_name 'JobUnschedule'

        field :job,
          Types::Ci::JobType,
          null: true,
          description: 'Job after the mutation.'

        authorize :update_build

        def resolve(id:)
          job = authorized_find!(id: id)

          ::Ci::BuildUnscheduleService.new(job, current_user).execute
          {
            job: job,
            errors: errors_on_object(job)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/lint.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    class Lint < BaseMutation
      graphql_name 'CiLint'

      description <<~MD
        Linted and processed contents of a CI config.
        Should not be requested more than once per request.
      MD

      include Gitlab::Graphql::Authorize::AuthorizeResource
      include ResolvesProject

      authorize :create_pipeline

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project of the CI config.'

      argument :content, GraphQL::Types::String,
        required: true,
        description: "Contents of `.gitlab-ci.yml`."

      argument :ref, GraphQL::Types::String,
        required: false,
        description: 'Ref to use when linting. Default is the project default branch.'

      argument :dry_run, GraphQL::Types::Boolean,
        required: false,
        description: 'Run pipeline creation simulation, or only do static check.'

      field :config, Types::Ci::ConfigType, null: true, description: 'Linted CI config and metadata.'

      def resolve(project_path:, content:, ref: nil, dry_run: false)
        project = authorized_find!(project_path: project_path)
        ref ||= project.default_branch

        result = ::Gitlab::Ci::Lint
          .new(project: project, current_user: context[:current_user])
          .validate(content, dry_run: dry_run, ref: ref)

        {
          config: response(result),
          errors: []
        }
      rescue GRPC::InvalidArgument => e
        Gitlab::ErrorTracking.track_and_raise_exception(e, ref: ref)
      end

      private

      def response(result)
        {
          status: result.status,
          errors: result.errors,
          warnings: result.warnings,
          stages: make_stages(result),
          merged_yaml: result.merged_yaml,
          includes: result.includes
        }
      end

      def make_jobs(config_jobs)
        config_jobs.map do |job|
          {
            name: job[:name],
            stage: job[:stage],
            group_name: Gitlab::Utils::Job.group_name(job[:name]),
            needs: job[:needs] || [],
            allow_failure: job[:allow_failure],
            before_script: job[:before_script],
            script: job[:script],
            after_script: job[:after_script],
            only: job[:only],
            except: job[:except],
            when: job[:when],
            tags: job[:tag_list],
            environment: job[:environment]
          }
        end
      end

      def make_groups(job_data)
        jobs = make_jobs(job_data)

        jobs_by_group = jobs.group_by { |job| job[:group_name] }
        jobs_by_group.map do |name, jobs|
          { jobs: jobs, name: name, stage: jobs.first[:stage], size: jobs.size }
        end
      end

      def make_stages(result)
        return [] unless result.valid?

        make_groups(result.jobs)
          .group_by { |group| group[:stage] }
          .map { |name, groups| { name: name, groups: groups } }
      end

      def find_object(project_path:)
        resolve_project(full_path: project_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/namespace_settings_update.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    class NamespaceSettingsUpdate < BaseMutation
      graphql_name 'NamespaceSettingsUpdate'

      include ResolvesNamespace

      authorize :maintainer_access

      argument :full_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the namespace the settings belong to.'
      argument :pipeline_variables_default_role, ::Types::Ci::PipelineVariablesDefaultRoleTypeEnum,
        required: false,
        description: copy_field_description(Types::Ci::NamespaceSettingsType, :pipeline_variables_default_role)

      field :ci_cd_settings,
        Types::Ci::NamespaceSettingsType,
        null: false,
        description: 'Namespace CI/CD settings after mutation.'

      def resolve(full_path:, **args)
        namespace = authorized_find!(full_path)
        settings = namespace.namespace_settings

        service_response = ::Ci::NamespaceSettings::UpdateService
          .new(settings, args)
          .execute

        {
          ci_cd_settings: settings,
          errors: service_response.errors
        }
      end

      private

      def find_object(full_path)
        resolve_namespace(full_path: full_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline/base.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Pipeline
      class Base < BaseMutation
        PipelineID = ::Types::GlobalIDType[::Ci::Pipeline]

        argument :id, PipelineID,
          required: true,
          description: 'ID of the pipeline to mutate.'

        private

        def find_object(id:)
          GlobalID::Locator.locate(id)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline/cancel.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Pipeline
      class Cancel < Base
        graphql_name 'PipelineCancel'

        authorize :cancel_pipeline

        def resolve(id:)
          pipeline = authorized_find!(id: id)

          result = ::Ci::CancelPipelineService.new(pipeline: pipeline, current_user: current_user).execute

          if result.success?
            { success: true, errors: [] }
          else
            { success: false, errors: [result.message] }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Pipeline
      class Create < BaseMutation
        graphql_name 'PipelineCreate'

        include FindsProject

        EXECUTE_OPTIONS = { ignore_skip_ci: true, save_on_errors: false }.freeze
        INTERNAL_CREATE_OPERATION_NAME = 'internalPipelineCreate'

        field :pipeline,
          Types::Ci::PipelineType,
          null: true,
          description: 'Pipeline created after mutation. Null if `async: true`.'

        field :request_id,
          GraphQL::Types::String,
          null: true,
          description: 'ID for checking the pipeline creation status. Null if `async: false`.',
          experiment: { milestone: '17.8' }

        argument :async, GraphQL::Types::Boolean,
          required: false,
          description: 'When `true`, the request does not wait for the pipeline to be created, ' \
            'and returns a unique identifier that can be used to check the creation status.',
          experiment: { milestone: '17.8' }

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the project that is triggering the pipeline.'

        argument :ref, GraphQL::Types::String,
          required: true,
          description: 'Ref on which to run the pipeline.'

        argument :variables, [Types::Ci::VariableInputType],
          required: false,
          description: 'Variables for the pipeline.'

        argument :inputs, [Types::Ci::Inputs::InputType],
          required: false,
          description: 'Inputs for the pipeline.',
          experiment: { milestone: '17.10' }

        authorize :create_pipeline

        def resolve(project_path:, ref:, async: false, variables: {}, inputs: [])
          project = authorized_find!(project_path)
          creation_params = { ref: ref, variables_attributes: variables.map(&:to_h) }

          execute_options = EXECUTE_OPTIONS.merge(inputs: parse_inputs(inputs))

          service = ::Ci::CreatePipelineService.new(project, current_user, creation_params)
          response = execute_service(service, source, async, execute_options)

          if response.success?
            if async
              { request_id: response.payload, errors: [] }
            else
              { pipeline: response.payload, errors: [] }
            end
          else
            { pipeline: nil, errors: [response.message] }
          end
        end

        private

        def execute_service(service, source, async, options)
          if async
            service.execute_async(source, options)
          else
            service.execute(source, **options)
          end
        end

        def source
          return 'web' if context.query.operation_name == INTERNAL_CREATE_OPERATION_NAME

          'api'
        end

        def parse_inputs(inputs)
          inputs.to_h { |input| [input.name, input.value] }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Pipeline
      class Destroy < Base
        graphql_name 'PipelineDestroy'

        authorize :destroy_pipeline

        def resolve(id:)
          pipeline = authorized_find!(id: id)
          project = pipeline.project

          return undergoing_refresh_error(project) if project.refreshing_build_artifacts_size?

          result = ::Ci::DestroyPipelineService.new(project, current_user).execute(pipeline)
          {
            success: result.success?,
            errors: result.errors
          }
        end

        private

        def undergoing_refresh_error(project)
          Gitlab::ProjectStatsRefreshConflictsLogger.warn_request_rejected_during_stats_refresh(project.id)

          {
            success: false,
            errors: ['Action temporarily disabled. The project this pipeline belongs to is undergoing stats refresh.']
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline/retry.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Pipeline
      class Retry < Base
        graphql_name 'PipelineRetry'

        field :pipeline,
          Types::Ci::PipelineType,
          null: true,
          description: 'Pipeline after mutation.'

        authorize :update_pipeline

        def resolve(id:)
          pipeline = authorized_find!(id: id)
          project = pipeline.project

          service_response = ::Ci::RetryPipelineService.new(project, current_user).execute(pipeline)

          {
            pipeline: pipeline,
            errors: errors_on_object(pipeline) + service_response.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/base.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class Base < BaseMutation
        PipelineScheduleID = ::Types::GlobalIDType[::Ci::PipelineSchedule]

        argument :id, PipelineScheduleID,
          required: true,
          description: 'ID of the pipeline schedule to mutate.'

        private

        def find_object(id:)
          GlobalID::Locator.locate(id)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class Create < BaseMutation
        graphql_name 'PipelineScheduleCreate'

        include FindsProject

        authorize :create_pipeline_schedule

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the project the pipeline schedule is associated with.'

        argument :description, GraphQL::Types::String,
          required: true,
          description: 'Description of the pipeline schedule.'

        argument :cron, GraphQL::Types::String,
          required: true,
          description: 'Cron expression of the pipeline schedule.'

        argument :cron_timezone, GraphQL::Types::String,
          required: false,
          description:
          <<-STR
                    Cron time zone supported by ActiveSupport::TimeZone.
                    For example: "Pacific Time (US & Canada)" (default: "UTC").
          STR

        argument :ref, GraphQL::Types::String,
          required: true,
          description: 'Ref of the pipeline schedule.'

        argument :active, GraphQL::Types::Boolean,
          required: false,
          description: 'Indicates if the pipeline schedule should be active or not.'

        argument :variables, [Mutations::Ci::PipelineSchedule::VariableInputType],
          required: false,
          description: 'Variables for the pipeline schedule.'

        argument :inputs, [Types::Ci::Inputs::InputType],
          required: false,
          description: 'Inputs for the pipeline schedule.',
          experiment: { milestone: '17.10' }

        field :pipeline_schedule,
          Types::Ci::PipelineScheduleType,
          description: 'Created pipeline schedule.'

        def resolve(project_path:, variables: [], inputs: [], **pipeline_schedule_attrs)
          project = authorized_find!(project_path)
          params = pipeline_schedule_attrs.merge(
            variables_attributes: variables.map(&:to_h),
            inputs_attributes: inputs.map(&:to_h)
          )

          response = ::Ci::PipelineSchedules::CreateService
                        .new(project, current_user, params)
                        .execute

          schedule = response.payload

          unless response.success?
            return {
              pipeline_schedule: nil, errors: response.errors
            }
          end

          {
            pipeline_schedule: schedule,
            errors: []
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class Delete < Base
        graphql_name 'PipelineScheduleDelete'

        authorize :admin_pipeline_schedule

        def resolve(id:)
          schedule = authorized_find!(id: id)

          if schedule.destroy
            {
              errors: []
            }
          else
            {
              errors: ['Failed to remove the pipeline schedule']
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/play.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class Play < Base
        graphql_name 'PipelineSchedulePlay'

        authorize :play_pipeline_schedule

        field :pipeline_schedule,
          Types::Ci::PipelineScheduleType,
          null: true,
          description: 'Pipeline schedule after mutation.'

        def resolve(id:)
          schedule = authorized_find!(id: id)

          job_id = ::Ci::PipelineSchedules::PlayService
            .new(schedule.project, current_user)
            .execute(schedule)

          if job_id
            { pipeline_schedule: schedule, errors: [] }
          else
            { pipeline_schedule: nil, errors: ['Unable to schedule a pipeline to run immediately.'] }
          end

        rescue Gitlab::Access::AccessDeniedError
          raise_resource_not_available_error!
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/take_ownership.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class TakeOwnership < Base
        graphql_name 'PipelineScheduleTakeOwnership'

        authorize :admin_pipeline_schedule

        field :pipeline_schedule,
          Types::Ci::PipelineScheduleType,
          description: 'Updated pipeline schedule ownership.'

        def resolve(id:)
          schedule = authorized_find!(id: id)

          service_response = ::Ci::PipelineSchedules::TakeOwnershipService.new(schedule, current_user).execute
          {
            pipeline_schedule: schedule,
            errors: service_response.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/update.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class Update < Base
        graphql_name 'PipelineScheduleUpdate'

        authorize :update_pipeline_schedule

        argument :description, GraphQL::Types::String,
          required: false,
          description: 'Description of the pipeline schedule.'

        argument :cron, GraphQL::Types::String,
          required: false,
          description: 'Cron expression of the pipeline schedule.'

        argument :cron_timezone, GraphQL::Types::String,
          required: false,
          description:
          <<-STR
                    Cron time zone supported by ActiveSupport::TimeZone.
                    For example: "Pacific Time (US & Canada)" (default: "UTC").
          STR

        argument :ref, GraphQL::Types::String,
          required: false,
          description: 'Ref of the pipeline schedule.'

        argument :active, GraphQL::Types::Boolean,
          required: false,
          description: 'Indicates if the pipeline schedule should be active or not.'

        argument :variables, [Mutations::Ci::PipelineSchedule::VariableInputType],
          required: false,
          description: 'Variables for the pipeline schedule.'

        argument :inputs, [Types::Ci::Inputs::InputType],
          required: false,
          description: 'Inputs for the pipeline schedule.',
          experiment: { milestone: '17.11' }

        field :pipeline_schedule,
          Types::Ci::PipelineScheduleType,
          description: 'Updated pipeline schedule.'

        def resolve(id:, variables: [], inputs: [], **pipeline_schedule_attrs)
          schedule = authorized_find!(id: id)

          params = pipeline_schedule_attrs.merge(
            inputs_attributes: inputs.map(&:to_h),
            variables_attributes: variables_attributes_for(variables)
          )

          service_response = ::Ci::PipelineSchedules::UpdateService
            .new(schedule, current_user, params)
            .execute

          {
            pipeline_schedule: schedule,
            errors: service_response.errors
          }
        end

        private

        # This method transforms the GraphQL argument values for pipeline schedule variables into values that can be
        # understood by ActiveRecord when performing a nested attributes collection update.
        def variables_attributes_for(variables)
          variables.map do |variable|
            variable.to_h.tap do |hash|
              hash[:id] = GlobalID::Locator.locate(hash[:id]).id if hash[:id]

              hash[:_destroy] = hash.delete(:destroy)
            end
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_schedule/variable_input_type.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineSchedule
      class VariableInputType < Types::BaseInputObject
        graphql_name 'PipelineScheduleVariableInput'

        description 'Attributes for the pipeline schedule variable.'

        PipelineScheduleVariableID = ::Types::GlobalIDType[::Ci::PipelineScheduleVariable]

        argument :id, PipelineScheduleVariableID, required: false, description: 'ID of the variable to mutate.'

        argument :key, GraphQL::Types::String, required: true, description: 'Name of the variable.'

        argument :value, GraphQL::Types::String, required: true, description: 'Value of the variable.'

        argument :variable_type, Types::Ci::VariableTypeEnum, required: true, description: 'Type of the variable.'

        argument :destroy, GraphQL::Types::Boolean, required: false,
          description: 'Boolean option to destroy the variable.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_trigger/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineTrigger
      class Create < BaseMutation
        graphql_name 'PipelineTriggerCreate'

        include FindsProject

        authorize :manage_trigger

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the project that the pipeline trigger token to mutate is in.'

        argument :description, GraphQL::Types::String,
          required: true,
          description: 'Description of the pipeline trigger token.'

        argument :expires_at, Types::TimeType,
          required: false,
          description: 'Timestamp of when the pipeline trigger token expires.'

        field :pipeline_trigger, Types::Ci::PipelineTriggerType,
          null: true,
          description: 'Mutated pipeline trigger token.'

        def resolve(project_path:, description:, expires_at: nil)
          project = authorized_find!(project_path)

          response = ::Ci::PipelineTriggers::CreateService.new(project: project, user: current_user,
            description: description, expires_at: expires_at).execute

          trigger = response.payload[:trigger]

          {
            pipeline_trigger: trigger,
            errors: trigger.errors.full_messages
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_trigger/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineTrigger
      class Delete < BaseMutation
        graphql_name 'PipelineTriggerDelete'

        authorize :manage_trigger

        argument :id, ::Types::GlobalIDType[::Ci::Trigger],
          required: true,
          description: 'ID of the pipeline trigger token to delete.'

        def resolve(id:)
          trigger = authorized_find!(id: id)
          response = ::Ci::PipelineTriggers::DestroyService.new(user: current_user, trigger: trigger).execute

          { errors: response.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/pipeline_trigger/update.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module PipelineTrigger
      class Update < BaseMutation
        graphql_name 'PipelineTriggerUpdate'

        authorize :admin_trigger

        argument :id, ::Types::GlobalIDType[::Ci::Trigger],
          required: true,
          description: 'ID of the pipeline trigger token to update.'

        argument :description, GraphQL::Types::String,
          required: true,
          description: 'Description of the pipeline trigger token.'

        field :pipeline_trigger, Types::Ci::PipelineTriggerType,
          null: true,
          description: 'Mutated pipeline trigger token.'

        def resolve(id:, description:)
          trigger = authorized_find!(id: id)

          response = ::Ci::PipelineTriggers::UpdateService.new(user: current_user, trigger: trigger,
            description: description).execute

          {
            pipeline_trigger: response.payload[:trigger],
            errors: response.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/project_ci_cd_settings_update.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    class ProjectCiCdSettingsUpdate < BaseMutation
      graphql_name 'ProjectCiCdSettingsUpdate'

      include FindsProject
      include Gitlab::Utils::StrongMemoize

      authorize :admin_project

      argument :full_path, GraphQL::Types::ID,
        required: true,
        description: 'Full Path of the project the settings belong to.'

      argument :group_runners_enabled, GraphQL::Types::Boolean,
        required: false,
        description: 'Indicates whether group runners are enabled for the project.'

      argument :keep_latest_artifact, GraphQL::Types::Boolean,
        required: false,
        description: 'Indicates whether the latest artifact should be kept for the project.'

      argument :job_token_scope_enabled, GraphQL::Types::Boolean,
        required: false,
        deprecated: {
          reason: 'Outbound job token scope is being removed. This field can now only be set to false',
          milestone: '16.0'
        },
        description: 'Indicates whether CI/CD job tokens generated in this project ' \
          'have restricted access to other projects.'

      argument :inbound_job_token_scope_enabled, GraphQL::Types::Boolean,
        required: false,
        description: 'Indicates whether CI/CD job tokens generated in other projects ' \
          'have restricted access to this project.'

      argument :push_repository_for_job_token_allowed, GraphQL::Types::Boolean,
        required: false,
        description: 'Indicates the ability to push to the original project ' \
          'repository using a job token'

      argument :display_pipeline_variables, GraphQL::Types::Boolean,
        required: false,
        description: 'Indicates whether pipeline variables can be displayed in the UI.'

      argument :pipeline_variables_minimum_override_role,
        GraphQL::Types::String,
        required: false,
        description: 'Minimum role required to set variables when creating a pipeline or running a job.'

      field :ci_cd_settings,
        Types::Ci::CiCdSettingType,
        null: false,
        description: 'CI/CD settings after mutation.'

      def resolve(full_path:, **args)
        if args[:job_token_scope_enabled]
          raise Gitlab::Graphql::Errors::ArgumentError, 'job_token_scope_enabled can only be set to false'
        end

        project = authorized_find!(full_path)

        response = ::Projects::UpdateService.new(
          project,
          current_user,
          project_update_params(project, **args)
        ).execute

        settings = project.ci_cd_settings

        if response[:status] == :success
          {
            ci_cd_settings: settings,
            errors: errors_on_object(settings)
          }
        else
          {
            ci_cd_settings: settings,
            errors: [response[:message]]
          }
        end
      end

      private

      def project_update_params(_project, **args)
        {
          group_runners_enabled: args[:group_runners_enabled],
          keep_latest_artifact: args[:keep_latest_artifact],
          ci_outbound_job_token_scope_enabled: args[:job_token_scope_enabled],
          ci_inbound_job_token_scope_enabled: args[:inbound_job_token_scope_enabled],
          ci_push_repository_for_job_token_allowed: args[:push_repository_for_job_token_allowed],
          restrict_user_defined_variables: args[:restrict_user_defined_variables],
          ci_pipeline_variables_minimum_override_role: args[:pipeline_variables_minimum_override_role],
          ci_display_pipeline_variables: args[:display_pipeline_variables]
        }.compact
      end
    end
  end
end

Mutations::Ci::ProjectCiCdSettingsUpdate.prepend_mod_with('Mutations::Ci::ProjectCiCdSettingsUpdate')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/assign_to_project.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class AssignToProject < BaseMutation
        graphql_name 'RunnerAssignToProject'

        authorize :assign_runner

        argument :runner_id, ::Types::GlobalIDType[::Ci::Runner],
          required: true,
          description: 'ID of the runner to assign to the project .'

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the project to which the runner will be assigned.'

        def resolve(**args)
          project, runner = find_project_and_runner!(args)
          result = ::Ci::Runners::AssignRunnerService.new(runner, project, current_user).execute

          { errors: result.errors }
        end

        def find_project_and_runner!(args)
          project = ::Project.find_by_full_path(args[:project_path])
          raise_resource_not_available_error! unless project

          runner = authorized_find!(id: args[:runner_id])
          raise_resource_not_available_error!("Runner is not a project runner") unless runner.project_type?

          [project, runner]
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/bulk_delete.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class BulkDelete < BaseMutation
        graphql_name 'BulkRunnerDelete'

        RunnerID = ::Types::GlobalIDType[::Ci::Runner]

        argument :ids, [RunnerID],
          required: false,
          description: 'IDs of the runners to delete.'

        field :deleted_count,
          ::GraphQL::Types::Int,
          null: true,
          description: 'Number of records effectively deleted. ' \
            'Only present if operation was performed synchronously.'

        field :deleted_ids,
          [RunnerID],
          null: true,
          description: 'IDs of records effectively deleted. ' \
            'Only present if operation was performed synchronously.'

        def resolve(**runner_attrs)
          if ids = runner_attrs[:ids]
            runner_ids = model_ids_of(ids)
            runners = find_all_runners_by_ids(runner_ids)

            result = ::Ci::Runners::BulkDeleteRunnersService.new(runners: runners, current_user: current_user).execute
            result.payload.slice(:deleted_count, :deleted_ids, :errors)
          else
            { errors: [] }
          end
        end

        private

        def model_ids_of(global_ids)
          global_ids.filter_map { |gid| gid.model_id.to_i }
        end

        def find_all_runners_by_ids(ids)
          return ::Ci::Runner.none if ids.blank?

          limit = ::Ci::Runners::BulkDeleteRunnersService::RUNNER_LIMIT
          ::Ci::Runner.id_in(ids).limit(limit + 1)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/bulk_pause.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class BulkPause < BaseMutation
        graphql_name 'RunnerBulkPause'

        RunnerID = ::Types::GlobalIDType[::Ci::Runner]

        argument :ids, [RunnerID],
          required: true,
          description: 'IDs of the runners to pause or unpause.'

        argument :paused, GraphQL::Types::Boolean,
          required: true,
          description: 'Indicates the runner is not allowed to receive jobs.'

        field :updated_count,
          ::GraphQL::Types::Int,
          null: true,
          description: 'Number of records effectively updated. ' \
            'Only present if operation was performed synchronously.'

        field :updated_runners, # rubocop:disable GraphQL/ExtractType -- Same as bulk_delete
          [Types::Ci::RunnerType],
          null: true,
          description: 'Runners after mutation.'

        def resolve(**runner_attrs)
          response = { updated_count: 0, updated_runners: [], errors: [] }
          ids = runner_attrs[:ids]
          runner_ids = model_ids_of(ids)
          runners = find_all_runners_by_ids(runner_ids)
          if runners.any?
            result = ::Ci::Runners::BulkPauseRunnersService
              .new(runners: runners, current_user: current_user, paused: runner_attrs[:paused])
              .execute
            result.payload.slice(:updated_count, :updated_runners, :errors)
          else
            response
          end
        end

        private

        def model_ids_of(global_ids)
          global_ids.filter_map { |gid| gid.model_id.to_i }
        end

        def find_all_runners_by_ids(ids)
          return ::Ci::Runner.none if ids.blank?

          limit = ::Ci::Runners::BulkPauseRunnersService::RUNNER_LIMIT
          ::Ci::Runner.id_in(ids).limit(limit + 1)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/cache/clear.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      module Cache
        class Clear < BaseMutation
          graphql_name 'RunnerCacheClear'

          authorize :admin_runners

          argument :project_id, ::Types::GlobalIDType[Project],
            required: true,
            description: 'Global ID of the project that will have its runner cache cleared.'

          def resolve(project_id:)
            project = authorized_find!(id: project_id)

            ResetProjectCacheService.new(project, current_user).execute
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/common_mutation_arguments.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      module CommonMutationArguments
        extend ActiveSupport::Concern

        included do
          argument :description, GraphQL::Types::String,
            required: false,
            description: 'Description of the runner.'

          argument :maintenance_note, GraphQL::Types::String,
            required: false,
            description: 'Runner\'s maintenance notes.'

          argument :maximum_timeout, GraphQL::Types::Int,
            required: false,
            description: 'Maximum timeout (in seconds) for jobs processed by the runner.'

          argument :access_level, ::Types::Ci::RunnerAccessLevelEnum,
            required: false,
            description: 'Access level of the runner.'

          argument :paused, GraphQL::Types::Boolean,
            required: false,
            description: 'Indicates the runner is not allowed to receive jobs.'

          argument :locked, GraphQL::Types::Boolean,
            required: false,
            description: 'Indicates the runner is locked.'

          argument :run_untagged, GraphQL::Types::Boolean,
            required: false,
            description: 'Indicates the runner is able to run untagged jobs.'

          argument :tag_list, [GraphQL::Types::String],
            required: false,
            description: 'Tags associated with the runner.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class Create < BaseMutation
        graphql_name 'RunnerCreate'

        authorize :create_runners

        include Mutations::Ci::Runner::CommonMutationArguments

        argument :runner_type, ::Types::Ci::RunnerTypeEnum,
          required: true,
          description: 'Type of the runner to create.'

        argument :group_id, ::Types::GlobalIDType[Group],
          required: false,
          description: 'Global ID of the group that the runner is created in (valid only for group runner).'

        argument :project_id, ::Types::GlobalIDType[Project],
          required: false,
          description: 'Global ID of the project that the runner is created in (valid only for project runner).'

        field :runner,
          Types::Ci::RunnerType,
          null: true,
          description: 'Runner after mutation.'

        def ready?(**args)
          case args[:runner_type]
          when 'group_type'
            raise Gitlab::Graphql::Errors::ArgumentError, '`group_id` is missing' unless args[:group_id].present?
          when 'project_type'
            raise Gitlab::Graphql::Errors::ArgumentError, '`project_id` is missing' unless args[:project_id].present?
          end

          parse_gid(**args)

          super
        end

        def resolve(**args)
          case args[:runner_type]
          when 'group_type', 'project_type'
            args[:scope] = authorized_find!(**args)
            args.except!(:group_id, :project_id)
          else
            raise_resource_not_available_error! unless current_user.can?(:create_instance_runners)
          end

          response = { runner: nil, errors: [] }
          result = ::Ci::Runners::CreateRunnerService.new(user: current_user, params: args).execute

          if result.success?
            response[:runner] = result.payload[:runner]
          else
            response[:errors] = result.errors
          end

          response
        end

        private

        def find_object(**args)
          obj = parse_gid(**args)

          GitlabSchema.find_by_gid(obj) if obj
        end

        def parse_gid(runner_type:, **args)
          case runner_type
          when 'group_type'
            GitlabSchema.parse_gid(args[:group_id], expected_type: ::Group)
          when 'project_type'
            GitlabSchema.parse_gid(args[:project_id], expected_type: ::Project)
          end
        end
      end
    end
  end
end

Mutations::Ci::Runner::Create.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class Delete < BaseMutation
        graphql_name 'RunnerDelete'

        authorize :delete_runner

        RunnerID = ::Types::GlobalIDType[::Ci::Runner]

        argument :id, RunnerID,
          required: true,
          description: 'ID of the runner to delete.'

        def resolve(id:, **runner_attrs)
          runner = authorized_find!(id: id)

          ::Ci::Runners::UnregisterRunnerService.new(runner, current_user).execute

          { errors: runner.errors.full_messages }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runners_registration_token/reset.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module RunnersRegistrationToken
      class Reset < BaseMutation
        graphql_name 'RunnersRegistrationTokenReset'

        authorize :update_runners_registration_token

        ScopeID = ::GraphQL::Types::ID

        argument :type, ::Types::Ci::RunnerTypeEnum,
          required: true,
          description: 'Scope of the object to reset the token for.'

        argument :id, ScopeID,
          required: false,
          description: 'ID of the project or group to reset the token for. Omit if resetting instance runner token.'

        field :token,
          GraphQL::Types::String,
          null: true,
          description: 'Runner token after mutation.'

        def resolve(type:, id: nil)
          scope = authorized_find!(type: type, id: id)
          new_token = reset_token(scope)

          {
            token: new_token,
            errors: errors_on_object(scope)
          }
        end

        private

        def find_object(type:, id: nil)
          case type
          when 'instance_type'
            raise Gitlab::Graphql::Errors::ArgumentError, "id must not be specified for '#{type}' scope" if id.present?

            ApplicationSetting.current
          when 'group_type'
            GitlabSchema.object_from_id(id, expected_type: ::Group)
          when 'project_type'
            GitlabSchema.object_from_id(id, expected_type: ::Project)
          end
        end

        def reset_token(scope)
          return unless scope

          result = ::Ci::Runners::ResetRegistrationTokenService.new(scope, current_user).execute
          result.payload[:new_registration_token] if result.success?
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/unassign_from_project.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class UnassignFromProject < BaseMutation
        graphql_name 'RunnerUnassignFromProject'

        authorize :unassign_runner

        argument :runner_id, ::Types::GlobalIDType[::Ci::Runner],
          required: true,
          description: 'ID of the runner to unassign from the project.'

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the project from which the runner will be unassigned.'

        def resolve(**args)
          runner_project = find_object(**args.slice(:runner_id, :project_path))
          raise_resource_not_available_error! unless runner_project

          result = ::Ci::Runners::UnassignRunnerService.new(runner_project, current_user).execute

          { errors: result.errors }
        end

        private

        def find_object(runner_id:, project_path:)
          project = Project.find_by_full_path(project_path)
          runner_id = GitlabSchema.parse_gid(runner_id, expected_type: ::Ci::Runner).model_id
          return unless project

          project.runner_projects.find_by_runner_id(runner_id)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/runner/update.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    module Runner
      class Update < BaseMutation
        graphql_name 'RunnerUpdate'

        authorize :update_runner

        include Mutations::Ci::Runner::CommonMutationArguments

        RunnerID = ::Types::GlobalIDType[::Ci::Runner]

        argument :id, RunnerID,
          required: true,
          description: 'ID of the runner to update.'

        argument :active, GraphQL::Types::Boolean,
          required: false,
          description: 'Indicates the runner is allowed to receive jobs.',
          deprecated: { reason: :renamed, replacement: 'paused', milestone: '14.8' }

        argument :associated_projects, [::Types::GlobalIDType[::Project]],
          required: false,
          description: 'Projects associated with the runner. Available only for project runners.',
          prepare: ->(global_ids, _ctx) { global_ids&.filter_map { |gid| gid.model_id.to_i } }

        field :runner,
          Types::Ci::RunnerType,
          null: true,
          description: 'Runner after mutation.'

        def resolve(id:, **runner_attrs)
          runner = authorized_find!(id: id)

          associated_projects_ids = runner_attrs.delete(:associated_projects)

          response = { runner: runner, errors: [] }
          ::Ci::Runner.transaction do
            associate_runner_projects(response, runner, associated_projects_ids) unless associated_projects_ids.nil?
            update_runner(response, runner, runner_attrs)
          end

          response
        end

        private

        def associate_runner_projects(response, runner, associated_project_ids)
          unless runner.project_type?
            raise Gitlab::Graphql::Errors::ArgumentError,
              "associatedProjects must not be specified for '#{runner.runner_type}' scope"
          end

          result = ::Ci::Runners::SetRunnerAssociatedProjectsService.new(
            runner: runner,
            current_user: current_user,
            project_ids: associated_project_ids
          ).execute
          return if result.success?

          response[:runner] = nil
          response[:errors] = result.errors
          raise ActiveRecord::Rollback
        end

        def update_runner(response, runner, attrs)
          result = ::Ci::Runners::UpdateRunnerService.new(current_user, runner).execute(attrs)
          return if result.success?

          response[:runner] = nil
          response[:errors] = result.errors
          raise ActiveRecord::Rollback
        end
      end
    end
  end
end

Mutations::Ci::Runner::Update.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ci/safe_disable_pipeline_variables.rb =====
# frozen_string_literal: true

module Mutations
  module Ci
    class SafeDisablePipelineVariables < BaseMutation
      graphql_name 'SafeDisablePipelineVariables'

      include Mutations::ResolvesGroup

      authorize :admin_group

      argument :full_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the group to disable pipeline variables for.'

      field :success,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates whether the migration was successfully enqueued.'

      def resolve(full_path:)
        group = authorized_find!(full_path)

        # rubocop:disable CodeReuse/Worker -- GraphQL mutation needs to enqueue worker
        ::Ci::SafeDisablePipelineVariablesWorker.perform_async(current_user.id, group.id)
        # rubocop:enable CodeReuse/Worker

        {
          success: true,
          errors: []
        }
      end

      private

      def find_object(full_path)
        resolve_group(full_path: full_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/clusters/agents/create.rb =====
# frozen_string_literal: true

module Mutations
  module Clusters
    module Agents
      class Create < BaseMutation
        graphql_name 'CreateClusterAgent'

        include FindsProject

        authorize :create_cluster

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the associated project for the cluster agent.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the cluster agent.'

        field :cluster_agent,
          Types::Clusters::AgentType,
          null: true,
          description: 'Cluster agent created after mutation.'

        def resolve(project_path:, name:)
          project = authorized_find!(project_path)
          result = ::Clusters::Agents::CreateService.new(project, current_user, { name: name }).execute

          {
            cluster_agent: result[:cluster_agent],
            errors: Array.wrap(result[:message])
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/clusters/agents/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Clusters
    module Agents
      class Delete < BaseMutation
        graphql_name 'ClusterAgentDelete'

        authorize :admin_cluster

        AgentID = ::Types::GlobalIDType[::Clusters::Agent]

        argument :id, AgentID,
          required: true,
          description: 'Global ID of the cluster agent that will be deleted.'

        def resolve(id:)
          cluster_agent = authorized_find!(id: id)
          result = ::Clusters::Agents::DeleteService
            .new(container: cluster_agent.project, current_user: current_user, params: { cluster_agent: cluster_agent })
            .execute

          {
            errors: Array.wrap(result.message)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/clusters/agent_tokens/create.rb =====
# frozen_string_literal: true

module Mutations
  module Clusters
    module AgentTokens
      class Create < BaseMutation
        graphql_name 'ClusterAgentTokenCreate'

        authorize :create_cluster

        ClusterAgentID = ::Types::GlobalIDType[::Clusters::Agent]

        argument :cluster_agent_id,
          ClusterAgentID,
          required: true,
          description: 'Global ID of the cluster agent that will be associated with the new token.'

        argument :description,
          GraphQL::Types::String,
          required: false,
          description: 'Description of the token.'

        argument :name,
          GraphQL::Types::String,
          required: true,
          description: 'Name of the token.'

        field :secret,
          GraphQL::Types::String,
          null: true,
          description: "Token secret value. Make sure you save it - you won't be able to access it again."

        field :token,
          Types::Clusters::AgentTokenType,
          null: true,
          description: 'Token created after mutation.'

        def resolve(args)
          cluster_agent = authorized_find!(id: args[:cluster_agent_id])

          result = ::Clusters::AgentTokens::CreateService
            .new(
              agent: cluster_agent,
              current_user: current_user,
              params: args
            )
            .execute

          payload = result.payload

          {
            secret: payload[:secret],
            token: payload[:token],
            errors: Array.wrap(result.message)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/clusters/agent_tokens/revoke.rb =====
# frozen_string_literal: true

module Mutations
  module Clusters
    module AgentTokens
      class Revoke < BaseMutation
        graphql_name 'ClusterAgentTokenRevoke'

        authorize :admin_cluster

        TokenID = ::Types::GlobalIDType[::Clusters::AgentToken]

        argument :id, TokenID,
          required: true,
          description: 'Global ID of the agent token that will be revoked.'

        def resolve(id:)
          token = authorized_find!(id: id)

          ::Clusters::AgentTokens::RevokeService.new(token: token, current_user: current_user).execute

          { errors: errors_on_object(token) }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/commits/create.rb =====
# frozen_string_literal: true

module Mutations
  module Commits
    class Create < BaseMutation
      graphql_name 'CommitCreate'

      include FindsProject

      class UrlHelpers
        include GitlabRoutingHelper
        include Gitlab::Routing
      end

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project full path the branch is associated with.'

      argument :branch, GraphQL::Types::String,
        required: true,
        description: 'Name of the branch to commit into, it can be a new branch.'

      argument :start_branch, GraphQL::Types::String,
        required: false,
        description: 'If on a new branch, name of the original branch.'

      argument :message,
        GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::Repositories::CommitType, :message)

      argument :actions,
        [Types::CommitActionType],
        required: true,
        description: 'Array of action hashes to commit as a batch.'

      field :commit_pipeline_path,
        GraphQL::Types::String,
        null: true,
        description: "ETag path for the commit's pipeline."

      field :commit,
        Types::Repositories::CommitType,
        null: true,
        description: 'Commit after mutation.'

      field :content,
        [GraphQL::Types::String],
        null: true,
        description: 'Contents of the commit.'

      authorize :push_code

      def resolve(project_path:, branch:, message:, actions:, **args)
        project = authorized_find!(project_path)

        attributes = {
          commit_message: message,
          branch_name: branch,
          start_branch: args[:start_branch] || branch,
          actions: actions.map(&:to_h)
        }

        result = ::Files::MultiService.new(project, current_user, attributes).execute

        {
          content: actions.pluck(:content), # rubocop:disable CodeReuse/ActiveRecord -- Array#pluck
          commit: (project.repository.commit(result[:result]) if result[:status] == :success),
          commit_pipeline_path: UrlHelpers.new.graphql_etag_pipeline_sha_path(result[:result]),
          errors: Array.wrap(result[:message])
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/assignable.rb =====
# frozen_string_literal: true

module Mutations
  module Assignable
    extend ActiveSupport::Concern

    included do
      argument :assignee_usernames,
        [GraphQL::Types::String],
        required: true,
        description: 'Usernames to assign to the resource. Replaces existing assignees by default.'

      argument :operation_mode,
        Types::MutationOperationModeEnum,
        required: false,
        default_value: Types::MutationOperationModeEnum.default_mode,
        description: 'Operation to perform. Defaults to REPLACE.'
    end

    def resolve(project_path:, iid:, assignee_usernames:, operation_mode:)
      resource = authorized_find!(project_path: project_path, iid: iid)
      users = new_assignees(resource, assignee_usernames)

      assign!(resource, users, operation_mode)

      {
        resource.class.name.underscore.to_sym => resource,
        errors: errors_on_object(resource)
      }
    end

    private

    def assign!(resource, users, operation_mode)
      update_service_class.new(
        **update_service_class.constructor_container_arg(resource.project),
        current_user: current_user,
        params: { assignee_ids: assignee_ids(resource, users, operation_mode) }
      ).execute(resource)
    end

    def new_assignees(resource, usernames)
      UsersFinder.new(current_user, username: usernames).execute.to_a
    end

    def assignee_ids(resource, users, mode)
      transform_list(mode, resource, users.map(&:id))
    end

    def current_assignee_ids(resource)
      resource.assignees.map(&:id)
    end

    def transform_list(mode, resource, new_values)
      case mode
      when 'REPLACE' then new_values
      when 'APPEND' then current_assignee_ids(resource) | new_values
      when 'REMOVE' then current_assignee_ids(resource) - new_values
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/finds_namespace.rb =====
# frozen_string_literal: true

module Mutations
  module FindsNamespace
    private

    def find_object(full_path)
      Routable.find_by_full_path(full_path)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/finds_project.rb =====
# frozen_string_literal: true

module Mutations
  module FindsProject
    private

    def find_object(full_path)
      Project.find_by_full_path(full_path)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/package_eventable.rb =====
# frozen_string_literal: true

module Mutations
  module PackageEventable
    extend ActiveSupport::Concern

    private

    def track_event(event, scope)
      ::Packages::CreateEventService.new(nil, current_user, event_name: event, scope: scope).execute
      ::Gitlab::Tracking.event(event.to_s, scope.to_s, user: current_user)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/resolves_group.rb =====
# frozen_string_literal: true

module Mutations
  module ResolvesGroup
    extend ActiveSupport::Concern

    def resolve_group(full_path:)
      group_resolver.resolve(full_path: full_path)
    end

    def group_resolver
      Resolvers::GroupResolver.new(object: nil, context: context, field: nil)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/resolves_issuable.rb =====
# frozen_string_literal: true

module Mutations
  module ResolvesIssuable
    extend ActiveSupport::Concern

    included do
      include ResolvesProject
    end

    def resolve_issuable(type:, parent_path:, iid:)
      parent = ::Gitlab::Graphql::Lazy.force(resolve_issuable_parent(type, parent_path))
      return unless parent.present?

      finder = issuable_finder(type, iids: [iid])
      Gitlab::Graphql::Loaders::IssuableLoader.new(parent, finder).find_all.first
    end

    private

    def issuable_finder(type, args)
      case type
      when :merge_request
        MergeRequestsFinder.new(current_user, args)
      when :issue
        IssuesFinder.new(current_user, args)
      else
        raise "Unsupported type: #{type}"
      end
    end

    def resolve_issuable_parent(type, parent_path)
      return unless parent_path.present?
      return unless type == :issue || type == :merge_request

      resolve_project(full_path: parent_path)
    end
  end
end

Mutations::ResolvesIssuable.prepend_mod_with('Mutations::ResolvesIssuable')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/resolves_namespace.rb =====
# frozen_string_literal: true

module Mutations
  module ResolvesNamespace
    extend ActiveSupport::Concern

    def resolve_namespace(full_path:)
      namespace_resolver.resolve(full_path: full_path)
    end

    def namespace_resolver
      Resolvers::NamespaceResolver.new(object: nil, context: context, field: nil)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/resolves_resource_parent.rb =====
# frozen_string_literal: true

module Mutations
  module ResolvesResourceParent
    extend ActiveSupport::Concern
    include Mutations::ResolvesGroup
    include ResolvesProject

    included do
      argument :project_path, GraphQL::Types::ID,
        required: false,
        description: 'Full path of the project with which the resource is associated.'

      argument :group_path, GraphQL::Types::ID,
        required: false,
        description: 'Full path of the group with which the resource is associated.'
    end

    def ready?(**args)
      unless args[:project_path].present? ^ args[:group_path].present?
        raise Gitlab::Graphql::Errors::ArgumentError,
          'Exactly one of group_path or project_path arguments is required'
      end

      super
    end

    private

    def authorized_resource_parent_find!(args)
      authorized_find!(project_path: args.delete(:project_path),
        group_path: args.delete(:group_path))
    end

    def find_object(project_path: nil, group_path: nil)
      if group_path.present?
        resolve_group(full_path: group_path)
      else
        resolve_project(full_path: project_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/resolves_subscription.rb =====
# frozen_string_literal: true

module Mutations
  module ResolvesSubscription
    extend ActiveSupport::Concern

    included do
      argument :subscribed_state,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Desired state of the subscription.'
    end

    def resolve(project_path:, iid:, subscribed_state:)
      resource = authorized_find!(project_path: project_path, iid: iid)
      project = resource.project

      resource.set_subscription(current_user, subscribed_state, project)

      {
        resource.class.name.underscore.to_sym => resource,
        errors: errors_on_object(resource)
      }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/spam_protection.rb =====
# frozen_string_literal: true

module Mutations
  # This concern can be mixed into a mutation to provide support for spam checking,
  # and optionally support the workflow to allow clients to display and solve CAPTCHAs.
  module SpamProtection
    extend ActiveSupport::Concern
    include Spam::Concerns::HasSpamActionResponseFields

    SpamActionError = Class.new(GraphQL::ExecutionError)
    NeedsCaptchaResponseError = Class.new(SpamActionError)
    SpamDisallowedError = Class.new(SpamActionError)

    NEEDS_CAPTCHA_RESPONSE_MESSAGE = "Request denied. Solve CAPTCHA challenge and retry"
    SPAM_DISALLOWED_MESSAGE = "Request denied. Spam detected"

    private

    def check_spam_action_response!(object)
      fields = spam_action_response_fields(object)

      if fields[:spam]
        # If the SpamActionService detected something as spam, this is non-recoverable and the
        # needs_captcha_response and other CAPTCHA-related fields should not be returned
        raise SpamDisallowedError.new(SPAM_DISALLOWED_MESSAGE, extensions: { spam: true })
      elsif fields[:needs_captcha_response]
        fields.delete :spam
        raise NeedsCaptchaResponseError.new(NEEDS_CAPTCHA_RESPONSE_MESSAGE, extensions: fields)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/validate_time_estimate.rb =====
# frozen_string_literal: true

module Mutations
  module ValidateTimeEstimate
    private

    def validate_time_estimate(time_estimate)
      return unless time_estimate

      parsed_time_estimate = Gitlab::TimeTrackingFormatter.parse(time_estimate, keep_zero: true)

      if parsed_time_estimate.nil?
        raise Gitlab::Graphql::Errors::ArgumentError,
          'timeEstimate must be formatted correctly, for example `1h 30m`'
      elsif parsed_time_estimate < 0
        raise Gitlab::Graphql::Errors::ArgumentError,
          'timeEstimate must be greater than or equal to zero. ' \
            'Remember that every new timeEstimate overwrites the previous value.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/work_items/shared_arguments.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module SharedArguments
      extend ActiveSupport::Concern

      included do
        argument :assignees_widget,
          ::Types::WorkItems::Widgets::AssigneesInputType,
          required: false,
          description: 'Input for assignees widget.'
        argument :confidential,
          GraphQL::Types::Boolean,
          required: false,
          description: 'Sets the work item confidentiality.'
        argument :description_widget,
          ::Types::WorkItems::Widgets::DescriptionInputType,
          required: false,
          description: 'Input for description widget.'
        argument :milestone_widget,
          ::Types::WorkItems::Widgets::MilestoneInputType,
          required: false,
          description: 'Input for milestone widget.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/concerns/mutations/work_items/widgetable.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module Widgetable
      extend ActiveSupport::Concern

      def extract_widget_params!(work_item_type, attributes, resource_parent)
        # Get the list of widgets for the work item's type to extract only the supported attributes
        widget_keys = ::WorkItems::WidgetDefinition.available_widgets.map(&:api_symbol)
        widget_params = attributes.extract!(*widget_keys)

        not_supported_keys = widget_params.keys - work_item_type.widget_classes(resource_parent).map(&:api_symbol)
        if not_supported_keys.present?
          raise Gitlab::Graphql::Errors::ArgumentError,
            "Following widget keys are not supported by #{work_item_type.name} type: #{not_supported_keys}"
        end

        # TODO: Refactor to use `#prepare` on the input types
        # https://gitlab.com/gitlab-org/gitlab/-/issues/519801
        widget_params.transform_values do |input|
          input.is_a?(Array) ? input.map(&:to_h) : input.to_h
        end
      end
    end
  end
end

# JH required
Mutations::WorkItems::Widgetable.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_expiration_policies/update.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerExpirationPolicies
    class Update < Mutations::BaseMutation
      graphql_name 'UpdateContainerExpirationPolicy'

      include FindsProject

      authorize :admin_container_image

      argument :project_path,
        GraphQL::Types::ID,
        required: true,
        description: 'Project path where the container expiration policy is located.'

      argument :enabled,
        GraphQL::Types::Boolean,
        required: false,
        description: copy_field_description(Types::ContainerRegistry::ContainerTagsExpirationPolicyType, :enabled)

      argument :cadence,
        Types::ContainerExpirationPolicyCadenceEnum,
        required: false,
        description: copy_field_description(Types::ContainerRegistry::ContainerTagsExpirationPolicyType, :cadence)

      argument :older_than,
        Types::ContainerExpirationPolicyOlderThanEnum,
        required: false,
        description: copy_field_description(Types::ContainerRegistry::ContainerTagsExpirationPolicyType, :older_than)

      argument :keep_n,
        Types::ContainerExpirationPolicyKeepEnum,
        required: false,
        description: copy_field_description(Types::ContainerRegistry::ContainerTagsExpirationPolicyType, :keep_n)

      argument :name_regex,
        Types::UntrustedRegexp,
        required: false,
        description: copy_field_description(Types::ContainerRegistry::ContainerTagsExpirationPolicyType, :name_regex)

      argument :name_regex_keep,
        Types::UntrustedRegexp,
        required: false,
        description: copy_field_description(Types::ContainerRegistry::ContainerTagsExpirationPolicyType,
          :name_regex_keep)

      field :container_tags_expiration_policy,
        Types::ContainerRegistry::ContainerTagsExpirationPolicyType,
        null: true,
        description: 'Container tags expiration policy after mutation.'

      field :container_expiration_policy, # rubocop:disable GraphQL/ExtractType -- not needed since this is deprecated
        Types::ContainerExpirationPolicyType,
        null: true,
        deprecated: { reason: 'Use `container_tags_expiration_policy`', milestone: '17.5' },
        description: 'Container expiration policy after mutation.'

      def resolve(project_path:, **args)
        project = authorized_find!(project_path)

        result = ::ContainerExpirationPolicies::UpdateService
          .new(container: project, current_user: current_user, params: args)
          .execute

        {
          container_expiration_policy: result.payload[:container_expiration_policy],
          container_tags_expiration_policy: result.payload[:container_expiration_policy],
          errors: result.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_registry/protection/rule/create.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRegistry
    module Protection
      module Rule
        class Create < ::Mutations::BaseMutation
          graphql_name 'CreateContainerProtectionRepositoryRule'
          description 'Creates a repository protection rule to restrict access to a project\'s container registry.'
          include FindsProject

          authorize :admin_container_image

          argument :project_path,
            GraphQL::Types::ID,
            required: true,
            description: 'Full path of the project where a protection rule is located.'

          argument :repository_path_pattern,
            GraphQL::Types::String,
            required: true,
            validates: { allow_blank: false },
            description: copy_field_description(
              Types::ContainerRegistry::Protection::RuleType,
              :repository_path_pattern
            )

          argument :minimum_access_level_for_delete,
            Types::ContainerRegistry::Protection::RuleAccessLevelEnum,
            required: false,
            description: copy_field_description(
              Types::ContainerRegistry::Protection::RuleType,
              :minimum_access_level_for_delete
            )

          argument :minimum_access_level_for_push,
            Types::ContainerRegistry::Protection::RuleAccessLevelEnum,
            required: false,
            description: copy_field_description(
              Types::ContainerRegistry::Protection::RuleType,
              :minimum_access_level_for_push
            )

          field :container_protection_repository_rule,
            Types::ContainerRegistry::Protection::RuleType,
            null: true,
            description: 'Container repository protection rule after mutation.'

          def resolve(project_path:, **kwargs)
            project = authorized_find!(project_path)

            response =
              ::ContainerRegistry::Protection::CreateRuleService
                .new(project: project, current_user: current_user, params: kwargs)
                .execute

            { container_protection_repository_rule: response.payload[:container_registry_protection_rule],
              errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_registry/protection/rule/delete.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRegistry
    module Protection
      module Rule
        class Delete < ::Mutations::BaseMutation
          graphql_name 'DeleteContainerProtectionRepositoryRule'
          description 'Deletes a container repository protection rule.'

          authorize :admin_container_image

          argument :id,
            ::Types::GlobalIDType[::ContainerRegistry::Protection::Rule],
            required: true,
            description: 'Global ID of the container repository protection rule to delete.'

          field :container_protection_repository_rule,
            Types::ContainerRegistry::Protection::RuleType,
            null: true,
            description: 'Container repository protection rule that was deleted successfully.'

          def resolve(id:, **_kwargs)
            container_registry_protection_rule = authorized_find!(id: id)

            response = ::ContainerRegistry::Protection::DeleteRuleService.new(container_registry_protection_rule,
              current_user: current_user).execute

            { container_protection_repository_rule: response.payload[:container_registry_protection_rule],
              errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_registry/protection/rule/update.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRegistry
    module Protection
      module Rule
        class Update < ::Mutations::BaseMutation
          graphql_name 'UpdateContainerProtectionRepositoryRule'
          description 'Updates a container repository protection rule that controls ' \
            'who can modify container images based on user roles.'

          authorize :admin_container_image

          argument :id,
            ::Types::GlobalIDType[::ContainerRegistry::Protection::Rule],
            required: true,
            description: 'Global ID of the container repository protection rule to be updated.'

          argument :repository_path_pattern,
            GraphQL::Types::String,
            required: false,
            validates: { allow_blank: false },
            description: copy_field_description(
              Types::ContainerRegistry::Protection::RuleType,
              :repository_path_pattern
            )

          argument :minimum_access_level_for_delete,
            Types::ContainerRegistry::Protection::RuleAccessLevelEnum,
            required: false,
            description: copy_field_description(
              Types::ContainerRegistry::Protection::RuleType,
              :minimum_access_level_for_delete
            )

          argument :minimum_access_level_for_push,
            Types::ContainerRegistry::Protection::RuleAccessLevelEnum,
            required: false,
            description: copy_field_description(
              Types::ContainerRegistry::Protection::RuleType,
              :minimum_access_level_for_push
            )

          field :container_protection_repository_rule,
            Types::ContainerRegistry::Protection::RuleType,
            null: true,
            description: 'Container repository protection rule after mutation.'

          def resolve(id:, **kwargs)
            container_registry_protection_rule = authorized_find!(id: id)

            response = ::ContainerRegistry::Protection::UpdateRuleService.new(container_registry_protection_rule,
              current_user: current_user, params: kwargs).execute

            { container_protection_repository_rule: response.payload[:container_registry_protection_rule],
              errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_registry/protection/tag_rule/create.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRegistry
    module Protection
      module TagRule
        class Create < ::Mutations::BaseMutation
          graphql_name 'createContainerProtectionTagRule'
          description 'Creates a protection rule to control which user roles ' \
            'can modify container image tags matching a specified pattern.'

          include FindsProject

          authorize :admin_container_image

          argument :project_path,
            GraphQL::Types::ID,
            required: true,
            description: 'Full path of the project containing the container image tags.'

          argument :tag_name_pattern,
            GraphQL::Types::String,
            required: true,
            validates: { allow_blank: false },
            description: copy_field_description(
              Types::ContainerRegistry::Protection::TagRuleType,
              :tag_name_pattern
            )

          argument :minimum_access_level_for_delete,
            Types::ContainerRegistry::Protection::TagRuleAccessLevelEnum,
            required: true,
            description: copy_field_description(
              Types::ContainerRegistry::Protection::TagRuleType,
              :minimum_access_level_for_delete
            )

          argument :minimum_access_level_for_push,
            Types::ContainerRegistry::Protection::TagRuleAccessLevelEnum,
            required: true,
            description: copy_field_description(
              Types::ContainerRegistry::Protection::TagRuleType,
              :minimum_access_level_for_push
            )

          field :container_protection_tag_rule,
            Types::ContainerRegistry::Protection::TagRuleType,
            null: true,
            experiment: { milestone: '17.8' },
            description: 'Protection rule for container image tags after creation.'

          def resolve(project_path:, **kwargs)
            project = authorized_find!(project_path)

            response =
              ::ContainerRegistry::Protection::CreateTagRuleService
                .new(project: project, current_user: current_user, params: kwargs)
                .execute

            { container_protection_tag_rule: response[:container_protection_tag_rule],
              errors: response.errors }
          end
        end
      end
    end
  end
end

Mutations::ContainerRegistry::Protection::TagRule::Create.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_registry/protection/tag_rule/delete.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRegistry
    module Protection
      module TagRule
        class Delete < ::Mutations::BaseMutation
          graphql_name 'DeleteContainerProtectionTagRule'
          description 'Deletes a protection rule that controls which user ' \
            'roles can modify container image tags matching a specified pattern.'

          authorize :destroy_container_registry_protection_tag_rule

          argument :id,
            ::Types::GlobalIDType[::ContainerRegistry::Protection::TagRule],
            required: true,
            description: 'Global ID of the tag protection rule to delete.'

          field :container_protection_tag_rule,
            Types::ContainerRegistry::Protection::TagRuleType,
            null: true,
            experiment: { milestone: '17.8' },
            description: 'Deleted protection rule for container image tags.'

          def resolve(id:, **_kwargs)
            container_protection_tag_rule = authorized_find!(id:)

            response = ::ContainerRegistry::Protection::DeleteTagRuleService.new(container_protection_tag_rule,
              current_user: current_user).execute

            { container_protection_tag_rule: response[:container_protection_tag_rule],
              errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_registry/protection/tag_rule/update.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRegistry
    module Protection
      module TagRule
        class Update < ::Mutations::BaseMutation
          graphql_name 'UpdateContainerProtectionTagRule'
          description 'Updates a protection rule that controls which user roles ' \
            'can modify container image tags matching a specified pattern.'

          authorize :admin_container_image

          argument :id,
            ::Types::GlobalIDType[::ContainerRegistry::Protection::TagRule],
            required: true,
            description: 'Global ID of the tag protection rule to update.'

          argument :tag_name_pattern,
            GraphQL::Types::String,
            required: false,
            validates: { allow_blank: false },
            experiment: { milestone: '17.8' },
            description: copy_field_description(
              Types::ContainerRegistry::Protection::TagRuleType,
              :tag_name_pattern
            )

          argument :minimum_access_level_for_delete,
            Types::ContainerRegistry::Protection::TagRuleAccessLevelEnum,
            required: false,
            experiment: { milestone: '17.8' },
            description: copy_field_description(
              Types::ContainerRegistry::Protection::TagRuleType,
              :minimum_access_level_for_delete
            )

          argument :minimum_access_level_for_push,
            Types::ContainerRegistry::Protection::TagRuleAccessLevelEnum,
            required: false,
            experiment: { milestone: '17.8' },
            description: copy_field_description(
              Types::ContainerRegistry::Protection::TagRuleType,
              :minimum_access_level_for_push
            )

          field :container_protection_tag_rule,
            Types::ContainerRegistry::Protection::TagRuleType,
            null: true,
            experiment: { milestone: '17.8' },
            description: 'Protection rule for container image tags after creation.'

          def resolve(id:, **kwargs)
            container_protection_tag_rule = authorized_find!(id:)

            response = ::ContainerRegistry::Protection::UpdateTagRuleService.new(container_protection_tag_rule,
              current_user: current_user, params: kwargs).execute

            { container_protection_tag_rule: response[:container_protection_tag_rule],
              errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_repositories/destroy_base.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRepositories
    class DestroyBase < Mutations::BaseMutation
      include ::Mutations::PackageEventable
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_repositories/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRepositories
    class Destroy < ::Mutations::ContainerRepositories::DestroyBase
      graphql_name 'DestroyContainerRepository'

      authorize :destroy_container_image

      argument :id,
        ::Types::GlobalIDType[::ContainerRepository],
        required: true,
        description: 'ID of the container repository.'

      field :container_repository,
        Types::ContainerRegistry::ContainerRepositoryType,
        null: false,
        description: 'Container repository policy after scheduling the deletion.'

      def resolve(id:)
        container_repository = authorized_find!(id: id)

        if protected_for_delete?(container_repository)
          return {
            container_repository: container_repository,
            errors: ['Deleting the protected repository path is forbidden']
          }
        end

        container_repository.delete_scheduled! && audit_event(container_repository)

        track_event(:delete_repository, :container)

        {
          container_repository: container_repository,
          errors: []
        }
      end

      private

      def audit_event(repository)
        # defined in EE
      end

      def protected_for_delete?(container_repository)
        return false unless Feature.enabled?(:container_registry_protected_containers_delete,
          container_repository.project&.root_ancestor)

        service_response = ::ContainerRegistry::Protection::CheckRuleExistenceService.for_delete(
          current_user: current_user,
          project: container_repository.project,
          params: { repository_path: container_repository.path.to_s }
        ).execute

        service_response.success? && service_response[:protection_rule_exists?]
      end
    end
  end
end

Mutations::ContainerRepositories::Destroy.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/container_repositories/destroy_tags.rb =====
# frozen_string_literal: true

module Mutations
  module ContainerRepositories
    class DestroyTags < ::Mutations::ContainerRepositories::DestroyBase
      graphql_name 'DestroyContainerRepositoryTags'

      LIMIT = 20
      TOO_MANY_TAGS_ERROR_MESSAGE = "Number of tags is greater than #{LIMIT}"

      authorize :destroy_container_image_tag

      argument :id,
        ::Types::GlobalIDType[::ContainerRepository],
        required: true,
        description: 'ID of the container repository.'

      argument :tag_names,
        [GraphQL::Types::String],
        required: true,
        description: "Container repository tag(s) to delete. Total number can't be greater than #{LIMIT}",
        prepare: ->(tag_names, _) do
          raise Gitlab::Graphql::Errors::ArgumentError, TOO_MANY_TAGS_ERROR_MESSAGE if tag_names.size > LIMIT

          tag_names
        end

      field :deleted_tag_names,
        [GraphQL::Types::String],
        description: 'Deleted container repository tags.',
        null: false

      def resolve(id:, tag_names:)
        container_repository = authorized_find!(id: id)

        result = ::Projects::ContainerRepository::DeleteTagsService
          .new(container_repository.project, current_user, tags: tag_names)
          .execute(container_repository)

        track_event(:delete_tag_bulk, :tag) if result[:status] == :success

        {
          errors: Array(result[:message]),
          deleted_tag_names: result[:deleted] || []
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/custom_emoji/create.rb =====
# frozen_string_literal: true

module Mutations
  module CustomEmoji
    class Create < BaseMutation
      graphql_name 'CreateCustomEmoji'

      include Mutations::ResolvesGroup

      authorize :create_custom_emoji

      field :custom_emoji,
        Types::CustomEmojiType,
        null: true,
        description: 'New custom emoji.'

      argument :group_path, GraphQL::Types::ID,
        required: true,
        description: 'Namespace full path the emoji is associated with.'

      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Name of the emoji.'

      argument :url, GraphQL::Types::String,
        required: true,
        as: :file,
        description: 'Location of the emoji file.'

      def resolve(group_path:, **args)
        group = authorized_find!(group_path: group_path)
        # See https://gitlab.com/gitlab-org/gitlab/-/merge_requests/37911#note_444682238
        args[:external] = true
        args[:creator] = current_user

        custom_emoji = group.custom_emoji.create(args)

        {
          custom_emoji: custom_emoji.valid? ? custom_emoji : nil,
          errors: errors_on_object(custom_emoji)
        }
      end

      private

      def find_object(group_path:)
        resolve_group(full_path: group_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/custom_emoji/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module CustomEmoji
    class Destroy < BaseMutation
      graphql_name 'DestroyCustomEmoji'

      authorize :delete_custom_emoji

      field :custom_emoji,
        Types::CustomEmojiType,
        null: true,
        description: 'Deleted custom emoji.'

      argument :id, ::Types::GlobalIDType[::CustomEmoji],
        required: true,
        description: 'Global ID of the custom emoji to destroy.'

      def resolve(id:)
        custom_emoji = authorized_find!(id: id)

        custom_emoji.destroy!

        {
          custom_emoji: custom_emoji
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/customer_relations/contacts/base.rb =====
# frozen_string_literal: true

module Mutations
  module CustomerRelations
    module Contacts
      class Base < BaseMutation
        include ResolvesIds
        include Gitlab::Graphql::Authorize::AuthorizeResource

        field :contact,
          Types::CustomerRelations::ContactType,
          null: true,
          description: 'Contact after the mutation.'

        authorize :admin_crm_contact

        def set_organization!(args)
          return unless args[:organization_id]

          args[:organization_id] = args[:organization_id].model_id
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/customer_relations/contacts/create.rb =====
# frozen_string_literal: true

module Mutations
  module CustomerRelations
    module Contacts
      class Create < Base
        graphql_name 'CustomerRelationsContactCreate'

        include Gitlab::Graphql::Authorize::AuthorizeResource

        argument :group_id, ::Types::GlobalIDType[::Group],
          required: true,
          description: 'Group for the contact.'

        argument :organization_id, ::Types::GlobalIDType[::CustomerRelations::Organization],
          required: false,
          description: 'Organization for the contact.'

        argument :first_name, GraphQL::Types::String,
          required: true,
          description: 'First name of the contact.'

        argument :last_name, GraphQL::Types::String,
          required: true,
          description: 'Last name of the contact.'

        argument :phone, GraphQL::Types::String,
          required: false,
          description: 'Phone number of the contact.'

        argument :email, GraphQL::Types::String,
          required: false,
          description: 'Email address of the contact.'

        argument :description, GraphQL::Types::String,
          required: false,
          description: 'Description of or notes for the contact.'

        def resolve(args)
          group = authorized_find!(id: args[:group_id])

          set_organization!(args)
          result = ::CustomerRelations::Contacts::CreateService.new(
            group: group,
            current_user: current_user,
            params: args
          ).execute
          { contact: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/customer_relations/contacts/update.rb =====
# frozen_string_literal: true

module Mutations
  module CustomerRelations
    module Contacts
      class Update < Base
        graphql_name 'CustomerRelationsContactUpdate'

        argument :id, ::Types::GlobalIDType[::CustomerRelations::Contact],
          required: true,
          description: 'Global ID of the contact.'

        argument :organization_id, ::Types::GlobalIDType[::CustomerRelations::Organization],
          required: false,
          description: 'Organization of the contact.'

        argument :first_name, GraphQL::Types::String,
          required: false,
          description: 'First name of the contact.'

        argument :last_name, GraphQL::Types::String,
          required: false,
          description: 'Last name of the contact.'

        argument :phone, GraphQL::Types::String,
          required: false,
          description: 'Phone number of the contact.'

        argument :email, GraphQL::Types::String,
          required: false,
          description: 'Email address of the contact.'

        argument :description, GraphQL::Types::String,
          required: false,
          description: 'Description of or notes for the contact.'

        argument :active, GraphQL::Types::Boolean,
          required: false,
          description: 'State of the contact.'

        def resolve(args)
          contact = ::Gitlab::Graphql::Lazy.force(GitlabSchema.object_from_id(
            args.delete(:id),
            expected_type: ::CustomerRelations::Contact)
                                                 )
          raise_resource_not_available_error! unless contact

          group = contact.group
          authorize!(group)

          set_organization!(args)
          result = ::CustomerRelations::Contacts::UpdateService.new(
            group: group,
            current_user: current_user,
            params: args
          ).execute(contact)
          { contact: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/customer_relations/organizations/create.rb =====
# frozen_string_literal: true

module Mutations
  module CustomerRelations
    module Organizations
      class Create < BaseMutation
        graphql_name 'CustomerRelationsOrganizationCreate'

        include ResolvesIds
        include Gitlab::Graphql::Authorize::AuthorizeResource

        field :organization,
          Types::CustomerRelations::OrganizationType,
          null: true,
          description: 'Organization after the mutation.'

        argument :group_id, ::Types::GlobalIDType[::Group],
          required: true,
          description: 'Group for the organization.'

        argument :name,
          GraphQL::Types::String,
          required: true,
          description: 'Name of the organization.'

        argument :default_rate,
          GraphQL::Types::Float,
          required: false,
          description: 'Standard billing rate for the organization.'

        argument :description,
          GraphQL::Types::String,
          required: false,
          description: 'Description of or notes for the organization.'

        authorize :admin_crm_organization

        def resolve(args)
          group = authorized_find!(id: args[:group_id])

          result = ::CustomerRelations::Organizations::CreateService.new(
            group: group,
            current_user: current_user,
            params: args
          ).execute
          { organization: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/customer_relations/organizations/update.rb =====
# frozen_string_literal: true

module Mutations
  module CustomerRelations
    module Organizations
      class Update < Mutations::BaseMutation
        graphql_name 'CustomerRelationsOrganizationUpdate'

        include ResolvesIds

        authorize :admin_crm_organization

        field :organization,
          Types::CustomerRelations::OrganizationType,
          null: false,
          description: 'Organization after the mutation.'

        argument :id, ::Types::GlobalIDType[::CustomerRelations::Organization],
          required: true,
          description: 'Global ID of the organization.'

        argument :name,
          GraphQL::Types::String,
          required: false,
          description: 'Name of the organization.'

        argument :default_rate,
          GraphQL::Types::Float,
          required: false,
          description: 'Standard billing rate for the organization.'

        argument :description,
          GraphQL::Types::String,
          required: false,
          description: 'Description of or notes for the organization.'

        argument :active, GraphQL::Types::Boolean,
          required: false,
          description: 'State of the organization.'

        def resolve(args)
          organization = ::Gitlab::Graphql::Lazy.force(
            GitlabSchema.object_from_id(args.delete(:id),
              expected_type: ::CustomerRelations::Organization)
          )
          raise_resource_not_available_error! unless organization

          group = organization.group
          authorize!(group)

          result = ::CustomerRelations::Organizations::UpdateService.new(
            group: group,
            current_user: current_user,
            params: args
          ).execute(organization)
          { organization: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/dependency_proxy/group_settings/update.rb =====
# frozen_string_literal: true

module Mutations
  module DependencyProxy
    module GroupSettings
      class Update < Mutations::BaseMutation
        graphql_name 'UpdateDependencyProxySettings'

        include Mutations::ResolvesGroup

        description 'These settings can be adjusted only by the group Owner.'

        authorize :admin_dependency_proxy

        argument :group_path,
          GraphQL::Types::ID,
          required: true,
          description: 'Group path for the group dependency proxy.'

        argument :enabled,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::DependencyProxy::ImageTtlGroupPolicyType, :enabled)

        argument :identity, GraphQL::Types::String, required: false,
          description: copy_field_description(Types::DependencyProxy::GroupSettingType, :identity)

        argument :secret, GraphQL::Types::String, required: false,
          description: 'Secret credential used to authenticate with Docker Hub when pulling images. ' \
            'Can be a password, personal access token (PAT), or organization access token (OAT).'

        field :dependency_proxy_setting,
          Types::DependencyProxy::GroupSettingType,
          null: true,
          description: 'Group dependency proxy settings after mutation.'

        def resolve(group_path:, **args)
          group = authorized_find!(group_path: group_path)

          result = ::DependencyProxy::GroupSettings::UpdateService
            .new(container: group, current_user: current_user, params: args)
            .execute

          {
            dependency_proxy_setting: result.payload[:dependency_proxy_setting],
            errors: result.errors
          }
        end

        private

        def find_object(group_path:)
          resolve_group(full_path: group_path)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/dependency_proxy/image_ttl_group_policy/update.rb =====
# frozen_string_literal: true

module Mutations
  module DependencyProxy
    module ImageTtlGroupPolicy
      class Update < Mutations::BaseMutation
        graphql_name 'UpdateDependencyProxyImageTtlGroupPolicy'

        include Mutations::ResolvesGroup

        description 'These settings can be adjusted only by the group Owner.'

        authorize :admin_dependency_proxy

        argument :group_path,
          GraphQL::Types::ID,
          required: true,
          description: 'Group path for the group dependency proxy image TTL policy.'

        argument :enabled,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::DependencyProxy::ImageTtlGroupPolicyType, :enabled)

        argument :ttl,
          GraphQL::Types::Int,
          required: false,
          description: copy_field_description(Types::DependencyProxy::ImageTtlGroupPolicyType, :ttl)

        field :dependency_proxy_image_ttl_policy,
          Types::DependencyProxy::ImageTtlGroupPolicyType,
          null: true,
          description: 'Group image TTL policy after mutation.'

        def resolve(group_path:, **args)
          group = authorized_find!(group_path: group_path)

          result = ::DependencyProxy::ImageTtlGroupPolicies::UpdateService
            .new(container: group, current_user: current_user, params: args)
            .execute

          {
            dependency_proxy_image_ttl_policy: result.payload[:dependency_proxy_image_ttl_policy],
            errors: result.errors
          }
        end

        private

        def find_object(group_path:)
          resolve_group(full_path: group_path)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/design_management/base.rb =====
# frozen_string_literal: true

module Mutations
  module DesignManagement
    class Base < ::Mutations::BaseMutation
      include Mutations::ResolvesIssuable

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Project where the issue is to upload designs for."

      argument :iid, GraphQL::Types::ID, # rubocop:disable Graphql/IDType -- Legacy argument using ID type kept for backwards compatibility
        required: true,
        description: "IID of the issue to modify designs for."

      private

      def find_object(project_path:, iid:)
        resolve_issuable(type: :issue, parent_path: project_path, iid: iid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/design_management/delete.rb =====
# frozen_string_literal: true

module Mutations
  module DesignManagement
    class Delete < Base
      graphql_name "DesignManagementDelete"

      Errors = ::Gitlab::Graphql::Errors

      argument :filenames, [GraphQL::Types::String],
        required: true,
        description: "Filenames of the designs to delete.",
        prepare: ->(names, _ctx) do
          names.presence || (raise Errors::ArgumentError, 'no filenames')
        end

      field :version, Types::DesignManagement::VersionType,
        null: true, # null on error
        description: 'New version in which the designs are deleted.'

      authorize :destroy_design

      def resolve(project_path:, iid:, filenames:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project
        designs = resolve_designs(issue, filenames)

        result = ::DesignManagement::DeleteDesignsService
          .new(project, current_user, issue: issue, designs: designs)
          .execute

        {
          version: result[:version],
          errors: Array.wrap(result[:message])
        }
      end

      private

      # Here we check that:
      #  * we find exactly as many designs as filenames
      def resolve_designs(issue, filenames)
        designs = issue.design_collection.designs_by_filename(filenames)

        validate_all_were_found!(designs, filenames)

        designs
      end

      def validate_all_were_found!(designs, filenames)
        found_filenames = designs.map(&:filename)
        missing = filenames.difference(found_filenames)

        if missing.present?
          raise Errors::ArgumentError, <<~MSG
            Not all the designs you named currently exist.
            The following filenames were not found:
            #{missing.join(', ')}

            They may have already been deleted.
          MSG
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/design_management/move.rb =====
# frozen_string_literal: true

module Mutations
  module DesignManagement
    class Move < ::Mutations::BaseMutation
      graphql_name "DesignManagementMove"

      DesignID = ::Types::GlobalIDType[::DesignManagement::Design]

      argument :id, DesignID,
        required: true, as: :current_design,
        description: "ID of the design to move."

      argument :previous, DesignID,
        required: false, as: :previous_design,
        description: "ID of the immediately preceding design."

      argument :next, DesignID,
        required: false, as: :next_design,
        description: "ID of the immediately following design."

      field :design_collection, Types::DesignManagement::DesignCollectionType,
        null: true,
        description: "Current state of the collection."

      def resolve(**args)
        service = ::DesignManagement::MoveDesignsService.new(current_user, parameters(**args))

        { design_collection: service.collection, errors: service.execute.errors }
      end

      private

      def parameters(**args)
        args.transform_values { |id| find_design(id) }.transform_values(&:sync).tap do |hash|
          hash.each { |k, design| not_found(args[k]) unless current_user.can?(:read_design, design) }
        end
      end

      def find_design(id)
        GitlabSchema.find_by_gid(id)
      end

      def not_found(gid)
        raise_resource_not_available_error! "Resource not available: #{gid}"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/design_management/update.rb =====
# frozen_string_literal: true

module Mutations
  module DesignManagement
    class Update < ::Mutations::BaseMutation
      graphql_name "DesignManagementUpdate"

      authorize :update_design

      argument :id, ::Types::GlobalIDType[::DesignManagement::Design],
        required: true,
        description: "ID of the design to update."

      argument :description, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::DesignManagement::DesignType, :description)

      field :design, Types::DesignManagement::DesignType,
        null: false,
        description: "Updated design."

      def resolve(id:, description:)
        design = authorized_find!(id: id)
        design.update(description: description)

        {
          design: design.reset,
          errors: errors_on_object(design)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/design_management/upload.rb =====
# frozen_string_literal: true

module Mutations
  module DesignManagement
    class Upload < Base
      graphql_name "DesignManagementUpload"

      argument :files, [ApolloUploadServer::Upload],
        required: true,
        description: "Files to upload."

      authorize :create_design

      field :designs, [Types::DesignManagement::DesignType],
        null: false,
        description: "Designs that were uploaded by the mutation."

      field :skipped_designs, [Types::DesignManagement::DesignType],
        null: false,
        description: "Any designs that were skipped from the upload due to there " \
          "being no change to their content since their last version"

      def resolve(project_path:, iid:, files:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project

        result = ::DesignManagement::SaveDesignsService.new(project, current_user, issue: issue, files: files)
                   .execute

        {
          designs: Array.wrap(result[:designs]),
          skipped_designs: Array.wrap(result[:skipped_designs]),
          errors: Array.wrap(result[:message])
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/discussions/toggle_resolve.rb =====
# frozen_string_literal: true

module Mutations
  module Discussions
    class ToggleResolve < BaseMutation
      graphql_name 'DiscussionToggleResolve'

      description 'Toggles the resolved state of a discussion'

      argument :id,
        Types::GlobalIDType[Discussion],
        required: true,
        description: 'Global ID of the discussion.'

      argument :resolve,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Will resolve the discussion when true, and unresolve the discussion when false.'

      field :discussion,
        Types::Notes::DiscussionType,
        null: true,
        description: 'Discussion after mutation.'

      def resolve(id:, resolve:)
        discussion = authorized_find_discussion!(id: id)
        errors = []

        begin
          if resolve
            resolve!(discussion)
          else
            unresolve!(discussion)
          end
        rescue ActiveRecord::RecordNotSaved
          errors << "Discussion failed to be #{'un' unless resolve}resolved"
        end

        {
          discussion: discussion,
          errors: errors
        }
      end

      private

      # `Discussion` permissions are checked through `Discussion#can_resolve?`,
      # so we use this method of checking permissions rather than by defining
      # an `authorize` permission and calling `authorized_find!`.
      def authorized_find_discussion!(id:)
        find_object(id: id).tap do |discussion|
          raise_resource_not_available_error! unless discussion&.can_resolve?(current_user)
        end
      end

      def resolve!(discussion)
        ::Discussions::ResolveService.new(
          discussion.project,
          current_user,
          one_or_more_discussions: discussion
        ).execute
      end

      def unresolve!(discussion)
        ::Discussions::UnresolveService.new(discussion, current_user).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/echo.rb =====
# frozen_string_literal: true

module Mutations
  class Echo < BaseMutation
    graphql_name 'EchoCreate'
    description <<~DOC
      A mutation that does not perform any changes.

      This is expected to be used for testing of endpoints, to verify
      that a user has mutation access.
    DOC

    argument :errors,
      type: [::GraphQL::Types::String],
      required: false,
      description: 'Errors to return to the user.'

    argument :messages,
      type: [::GraphQL::Types::String],
      as: :echoes,
      required: false,
      description: 'Messages to return to the user.'

    field :echoes,
      type: [::GraphQL::Types::String],
      null: true,
      description: 'Messages returned to the user.'

    def resolve(**args)
      args
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/environments/canary_ingress/update.rb =====
# frozen_string_literal: true

module Mutations
  module Environments
    module CanaryIngress
      class Update < ::Mutations::BaseMutation
        graphql_name 'EnvironmentsCanaryIngressUpdate'
        description '**Deprecated** This endpoint is planned to be removed along with certificate-based clusters. ' \
          '[See this epic](https://gitlab.com/groups/gitlab-org/configure/-/epics/8) for more information.'

        authorize :update_environment

        argument :id,
          ::Types::GlobalIDType[::Environment],
          required: true,
          description: 'Global ID of the environment to update.'

        argument :weight,
          GraphQL::Types::Int,
          required: true,
          description: 'Weight of the Canary Ingress.'

        REMOVAL_ERR_MSG = 'This endpoint was deactivated as part of the certificate-based' \
          'kubernetes integration removal. See Epic:' \
          'https://gitlab.com/groups/gitlab-org/configure/-/epics/8'

        def resolve(id:, **kwargs)
          return { errors: [REMOVAL_ERR_MSG] } unless certificate_based_clusters_enabled?

          environment = authorized_find!(id: id)

          result = ::Environments::CanaryIngress::UpdateService
            .new(environment.project, current_user, kwargs)
            .execute_async(environment)

          { errors: Array.wrap(result[:message]) }
        end

        private

        def certificate_based_clusters_enabled?
          instance_cluster = ::Clusters::Instance.new
          instance_cluster.certificate_based_clusters_enabled?
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/environments/create.rb =====
# frozen_string_literal: true

module Mutations
  module Environments
    class Create < ::Mutations::BaseMutation
      graphql_name 'EnvironmentCreate'
      description 'Create an environment.'

      include FindsProject

      authorize :create_environment

      argument :project_path,
        GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project.'

      argument :name,
        GraphQL::Types::String,
        required: true,
        description: 'Name of the environment.'

      argument :description,
        GraphQL::Types::String,
        required: false,
        description: 'Description of the environment.'

      argument :external_url,
        GraphQL::Types::String,
        required: false,
        description: 'External URL of the environment.'

      argument :tier,
        Types::DeploymentTierEnum,
        required: false,
        description: 'Tier of the environment.'

      argument :cluster_agent_id,
        ::Types::GlobalIDType[::Clusters::Agent],
        required: false,
        description: 'Cluster agent of the environment.'

      argument :kubernetes_namespace,
        GraphQL::Types::String,
        required: false,
        description: 'Kubernetes namespace of the environment.'

      argument :flux_resource_path,
        GraphQL::Types::String,
        required: false,
        description: 'Flux resource path of the environment.'

      argument :auto_stop_setting,
        Types::Environments::AutoStopSettingEnum,
        required: false,
        description: 'Auto stop setting of the environment.'

      field :environment,
        Types::EnvironmentType,
        null: true,
        description: 'Created environment.'

      def resolve(project_path:, **kwargs)
        project = authorized_find!(project_path)

        kwargs[:cluster_agent] = GitlabSchema.find_by_gid(kwargs.delete(:cluster_agent_id))&.sync

        response = ::Environments::CreateService.new(project, current_user, kwargs).execute

        if response.success?
          { environment: response.payload[:environment], errors: [] }
        else
          { environment: response.payload[:environment], errors: response.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/environments/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Environments
    class Delete < ::Mutations::BaseMutation
      graphql_name 'EnvironmentDelete'
      description 'Delete an environment.'

      authorize :destroy_environment

      argument :id,
        ::Types::GlobalIDType[::Environment],
        required: true,
        description: 'Global ID of the environment to Delete.'

      def resolve(id:, **kwargs)
        environment = authorized_find!(id: id)

        response = ::Environments::DestroyService.new(environment.project, current_user, kwargs).execute(environment)

        if response.success?
          { errors: [] }
        else
          { errors: response.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/environments/stop.rb =====
# frozen_string_literal: true

module Mutations
  module Environments
    class Stop < ::Mutations::BaseMutation
      graphql_name 'EnvironmentStop'
      description 'Stop an environment.'

      authorize :stop_environment

      argument :id,
        ::Types::GlobalIDType[::Environment],
        required: true,
        description: 'Global ID of the environment to stop.'

      argument :force,
        GraphQL::Types::Boolean,
        required: false,
        description: 'Force environment to stop without executing on_stop actions.'

      field :environment,
        Types::EnvironmentType,
        null: true,
        description: 'Environment after attempt to stop.'

      def resolve(id:, **kwargs)
        environment = authorized_find!(id: id)

        response = ::Environments::StopService.new(environment.project, current_user, kwargs).execute(environment)

        if response.success?
          { environment: response.payload[:environment], errors: [] }
        else
          { environment: response.payload[:environment], errors: response.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/environments/update.rb =====
# frozen_string_literal: true

module Mutations
  module Environments
    class Update < ::Mutations::BaseMutation
      graphql_name 'EnvironmentUpdate'
      description 'Update an environment.'

      authorize :update_environment

      argument :id,
        ::Types::GlobalIDType[::Environment],
        required: true,
        description: 'Global ID of the environment to update.'

      argument :description,
        GraphQL::Types::String,
        required: false,
        description: 'Description of the environment.'

      argument :external_url,
        GraphQL::Types::String,
        required: false,
        description: 'External URL of the environment.'

      argument :tier,
        Types::DeploymentTierEnum,
        required: false,
        description: 'Tier of the environment.'

      argument :cluster_agent_id,
        ::Types::GlobalIDType[::Clusters::Agent],
        required: false,
        description: 'Cluster agent of the environment.'

      argument :kubernetes_namespace,
        GraphQL::Types::String,
        required: false,
        description: 'Kubernetes namespace of the environment.'

      argument :flux_resource_path,
        GraphQL::Types::String,
        required: false,
        description: 'Flux resource path of the environment.'

      argument :auto_stop_setting,
        Types::Environments::AutoStopSettingEnum,
        required: false,
        description: 'Auto stop setting of the environment.'

      field :environment,
        Types::EnvironmentType,
        null: true,
        description: 'Environment after attempt to update.'

      def resolve(id:, **kwargs)
        environment = authorized_find!(id: id)

        convert_cluster_agent_id(kwargs)

        response = ::Environments::UpdateService.new(environment.project, current_user, kwargs).execute(environment)

        if response.success?
          { environment: response.payload[:environment], errors: [] }
        else
          { environment: response.payload[:environment], errors: response.errors }
        end
      end

      private

      def convert_cluster_agent_id(kwargs)
        return unless kwargs.key?(:cluster_agent_id)

        kwargs[:cluster_agent] = if kwargs[:cluster_agent_id]
                                   ::Clusters::Agent.find_by_id(kwargs[:cluster_agent_id].model_id)
                                 end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/groups/update.rb =====
# frozen_string_literal: true

module Mutations
  module Groups
    class Update < Mutations::BaseMutation
      graphql_name 'GroupUpdate'

      include ::Gitlab::Allowable
      include Mutations::ResolvesGroup

      authorize :admin_group_or_admin_runners

      field :group, Types::GroupType,
        null: true,
        description: 'Group after update.'

      argument :full_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the group that will be updated.'
      argument :lock_math_rendering_limits_enabled, GraphQL::Types::Boolean,
        required: false,
        description: copy_field_description(Types::GroupType, :lock_math_rendering_limits_enabled)
      argument :math_rendering_limits_enabled, GraphQL::Types::Boolean,
        required: false,
        description: copy_field_description(Types::GroupType, :math_rendering_limits_enabled)
      argument :name, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::GroupType, :name)
      argument :path, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::GroupType, :path)
      argument :shared_runners_setting, Types::Namespace::SharedRunnersSettingEnum,
        required: false,
        description: copy_field_description(Types::GroupType, :shared_runners_setting)
      argument :visibility, Types::VisibilityLevelsEnum,
        required: false,
        description: copy_field_description(Types::GroupType, :visibility)

      def resolve(full_path:, **args)
        group = authorized_find!(full_path: full_path)

        unless ::Groups::UpdateService.new(group, current_user, authorized_args(group, args)).execute
          return { group: nil, errors: group.errors.full_messages }
        end

        { group: group, errors: [] }
      end

      private

      def find_object(full_path:)
        resolve_group(full_path: full_path)
      end

      def authorized_args(group, args)
        return args if can?(current_user, :admin_group, group)

        if can?(current_user, :admin_runners, group) && args.keys == [:shared_runners_setting]
          return { shared_runners_setting: args[:shared_runners_setting] }
        end

        raise_resource_not_available_error!
      end
    end
  end
end

Mutations::Groups::Update.prepend_mod_with('Mutations::Groups::Update')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/import/source_users/cancel_reassignment.rb =====
# frozen_string_literal: true

module Mutations
  module Import
    module SourceUsers
      class CancelReassignment < BaseMutation
        graphql_name 'ImportSourceUserCancelReassignment'

        argument :id, Types::GlobalIDType[::Import::SourceUser],
          required: true,
          description: 'Global ID of the mapping of a user on source instance to a user on destination instance.'

        field :import_source_user,
          Types::Import::SourceUserType,
          null: true,
          description: "Mapping of a user on source instance to a user on destination instance after mutation."

        authorize :admin_import_source_user

        def resolve(args)
          import_source_user = authorized_find!(id: args[:id])
          result = ::Import::SourceUsers::CancelReassignmentService.new(import_source_user,
            current_user: current_user).execute

          { import_source_user: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/import/source_users/keep_all_as_placeholder.rb =====
# frozen_string_literal: true

module Mutations
  module Import
    module SourceUsers
      class KeepAllAsPlaceholder < BaseMutation
        graphql_name 'ImportSourceUserKeepAllAsPlaceholder'

        argument :namespace_id, Types::GlobalIDType[::Namespace],
          required: true,
          description: 'Global ID of the namespace.'

        field :updated_import_source_user_count,
          GraphQL::Types::Int,
          null: true,
          description: "Number of successfully updated mappings of users on source instance to their destination users."

        authorize :admin_namespace

        def resolve(args)
          namespace = authorized_find!(id: args[:namespace_id])
          result = ::Import::SourceUsers::KeepAllAsPlaceholderService.new(namespace, current_user: current_user).execute

          { updated_import_source_user_count: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/import/source_users/keep_as_placeholder.rb =====
# frozen_string_literal: true

module Mutations
  module Import
    module SourceUsers
      class KeepAsPlaceholder < BaseMutation
        graphql_name 'ImportSourceUserKeepAsPlaceholder'

        argument :id, Types::GlobalIDType[::Import::SourceUser],
          required: true,
          description: 'Global ID of the mapping of a user on source instance to a user on destination instance.'

        field :import_source_user,
          Types::Import::SourceUserType,
          null: true,
          description: "Mapping of a user on source instance to a user on destination instance after mutation."

        authorize :admin_import_source_user

        def resolve(args)
          import_source_user = authorized_find!(id: args[:id])
          result = ::Import::SourceUsers::KeepAsPlaceholderService.new(import_source_user,
            current_user: current_user).execute

          { import_source_user: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/import/source_users/reassign.rb =====
# frozen_string_literal: true

module Mutations
  module Import
    module SourceUsers
      class Reassign < BaseMutation
        graphql_name 'ImportSourceUserReassign'

        argument :id, Types::GlobalIDType[::Import::SourceUser],
          required: true,
          description: 'Global ID of the mapping of a user on source instance to a user on destination instance.'

        argument :assignee_user_id, Types::GlobalIDType[::User],
          required: true,
          loads: Types::UserType,
          description: 'Global ID of the assignee user.'

        field :import_source_user,
          Types::Import::SourceUserType,
          null: true,
          description: "Mapping of a user on source instance to a user on destination instance after mutation."

        authorize :admin_import_source_user

        def resolve(args)
          import_source_user = authorized_find!(id: args[:id])
          result = ::Import::SourceUsers::ReassignService.new(import_source_user, args[:assignee_user],
            current_user: current_user).execute

          { import_source_user: result.payload, errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/import/source_users/resend_notification.rb =====
# frozen_string_literal: true

module Mutations
  module Import
    module SourceUsers
      class ResendNotification < BaseMutation
        graphql_name 'ImportSourceUserResendNotification'

        argument :id, Types::GlobalIDType[::Import::SourceUser],
          required: true,
          description: 'Global ID of the mapping of a user on source instance to a user on destination instance.'

        field :import_source_user,
          Types::Import::SourceUserType,
          null: true,
          description: 'Mapping of a user on source instance to a user on destination instance after mutation.'

        authorize :admin_import_source_user

        def resolve(args)
          import_source_user = authorized_find!(id: args[:id])

          verify_rate_limit!(import_source_user)

          result = ::Import::SourceUsers::ResendNotificationService.new(import_source_user, current_user: current_user)
            .execute

          { import_source_user: result.payload, errors: result.errors }
        end

        private

        def verify_rate_limit!(import_source_user)
          return unless Gitlab::ApplicationRateLimiter.throttled?(
            :import_source_user_notification, scope: [import_source_user]
          )

          raise_resource_not_available_error! _('This endpoint has been requested too many times. Try again later.')
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event/base.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEvent
      class Base < BaseMutation
        field :timeline_event,
          ::Types::IncidentManagement::TimelineEventType,
          null: true,
          description: 'Timeline event.'

        authorize :admin_incident_management_timeline_event

        private

        def response(result)
          {
            timeline_event: result.payload[:timeline_event],
            errors: result.errors
          }
        end

        def find_object(id:)
          GitlabSchema.object_from_id(id, expected_type: ::IncidentManagement::TimelineEvent).sync
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event/create.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEvent
      class Create < Base
        graphql_name 'TimelineEventCreate'

        argument :incident_id, Types::GlobalIDType[::Issue],
          required: true,
          description: 'Incident ID of the timeline event.'

        argument :note, GraphQL::Types::String,
          required: true,
          description: 'Text note of the timeline event.'

        argument :occurred_at, Types::TimeType,
          required: true,
          description: 'Timestamp of when the event occurred.'

        argument :timeline_event_tag_names, [GraphQL::Types::String],
          required: false,
          description: copy_field_description(Types::IncidentManagement::TimelineEventType, :timeline_event_tags)

        def resolve(incident_id:, **args)
          incident = authorized_find!(id: incident_id)

          authorize!(incident)

          response ::IncidentManagement::TimelineEvents::CreateService.new(
            incident, current_user, args.merge(editable: true)
          ).execute
        end

        private

        def find_object(id:)
          GitlabSchema.object_from_id(id, expected_type: ::Issue).sync
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEvent
      class Destroy < Base
        graphql_name 'TimelineEventDestroy'

        argument :id, Types::GlobalIDType[::IncidentManagement::TimelineEvent],
          required: true,
          description: 'Timeline event ID to remove.'

        def resolve(id:)
          timeline_event = authorized_find!(id: id)

          response ::IncidentManagement::TimelineEvents::DestroyService.new(
            timeline_event,
            current_user
          ).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event/promote_from_note.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEvent
      class PromoteFromNote < Base
        graphql_name 'TimelineEventPromoteFromNote'

        include NotesHelper

        argument :note_id, Types::GlobalIDType[::Note],
          required: true,
          description: 'Note ID from which the timeline event promoted.'

        def resolve(note_id:)
          note = find_object(id: note_id)
          incident = note&.noteable

          authorize!(incident)

          response ::IncidentManagement::TimelineEvents::CreateService.new(
            incident,
            current_user,
            promoted_from_note: note,
            note: build_note_string(note),
            occurred_at: note.created_at,
            editable: true
          ).execute
        end

        private

        def find_object(id:)
          GitlabSchema.object_from_id(id, expected_type: ::Note).sync
        end

        def authorize!(object)
          raise_noteable_not_incident! if object && !object.try(:incident_type_issue?)

          super
        end

        def build_note_string(note)
          commented = _('commented')
          "@#{note.author.username} [#{commented}](#{noteable_note_url(note)}): '#{note.note}'"
        end

        def raise_noteable_not_incident!
          raise_resource_not_available_error! 'Note does not belong to an incident'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event_tag/base.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEventTag
      class Base < BaseMutation
        field :timeline_event_tag,
          ::Types::IncidentManagement::TimelineEventTagType,
          null: true,
          description: 'Timeline event tag.'

        authorize :admin_incident_management_timeline_event_tag

        private

        def response(result)
          {
            timeline_event_tag: result.payload[:timeline_event_tag],
            errors: result.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event_tag/create.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEventTag
      class Create < Base
        graphql_name 'TimelineEventTagCreate'

        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project to create the timeline event tag in.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the tag.'

        def resolve(project_path:, **args)
          project = authorized_find!(project_path)

          response ::IncidentManagement::TimelineEventTags::CreateService.new(
            project, current_user, args
          ).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/incident_management/timeline_event/update.rb =====
# frozen_string_literal: true

module Mutations
  module IncidentManagement
    module TimelineEvent
      class Update < Base
        graphql_name 'TimelineEventUpdate'

        argument :id, ::Types::GlobalIDType[::IncidentManagement::TimelineEvent],
          required: true,
          description: 'ID of the timeline event to update.'

        argument :note, GraphQL::Types::String,
          required: false,
          description: 'Text note of the timeline event.'

        argument :occurred_at, Types::TimeType,
          required: false,
          description: 'Timestamp when the event occurred.'

        argument :timeline_event_tag_names, [GraphQL::Types::String],
          required: false,
          description: copy_field_description(Types::IncidentManagement::TimelineEventType, :timeline_event_tags)

        def resolve(id:, **args)
          timeline_event = authorized_find!(id: id)

          response ::IncidentManagement::TimelineEvents::UpdateService.new(
            timeline_event,
            current_user,
            args
          ).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/integrations/exclusions/create.rb =====
# frozen_string_literal: true

module Mutations
  module Integrations
    module Exclusions
      class Create < BaseMutation
        graphql_name 'IntegrationExclusionCreate'
        include ResolvesIds

        MAX_PROJECT_IDS = ::Integrations::Exclusions::CreateService::MAX_PROJECTS
        MAX_GROUP_IDS = ::Integrations::Exclusions::CreateService::MAX_GROUPS

        field :exclusions, [::Types::Integrations::ExclusionType],
          null: true,
          description: 'Integration exclusions created by the mutation.'

        argument :integration_name,
          ::Types::Integrations::IntegrationTypeEnum,
          required: true,
          description: 'Type of integration to exclude.'

        argument :project_ids,
          [::Types::GlobalIDType[::Project]],
          required: false,
          prepare: ->(ids, _ctx) { ids.uniq },
          validates: { length: { maximum: MAX_PROJECT_IDS } },
          description: "IDs of projects to exclude up to a maximum of #{MAX_PROJECT_IDS}."

        argument :group_ids,
          [::Types::GlobalIDType[::Group]],
          required: false,
          prepare: ->(ids, _ctx) { ids.uniq },
          validates: { length: { maximum: MAX_GROUP_IDS } },
          description: "IDs of groups to exclude up to a maximum of #{MAX_GROUP_IDS}."

        authorize :admin_all_resources

        def resolve(integration_name:, project_ids: [], group_ids: [])
          authorize!(:global)

          result = ::Integrations::Exclusions::CreateService.new(
            current_user: current_user,
            projects: projects(project_ids),
            groups: groups(group_ids),
            integration_name: integration_name
          ).execute

          {
            exclusions: result.payload,
            errors: result.errors
          }
        end

        private

        def groups(group_ids)
          return [] unless group_ids.present?

          Group.id_in(resolve_ids(group_ids)).limit(MAX_GROUP_IDS)
        end

        def projects(project_ids)
          return [] unless project_ids.present?

          Project.id_in(resolve_ids(project_ids)).with_group.limit(MAX_PROJECT_IDS)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/integrations/exclusions/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Integrations
    module Exclusions
      class Delete < BaseMutation
        graphql_name 'IntegrationExclusionDelete'
        include ResolvesIds

        field :exclusions, [::Types::Integrations::ExclusionType],
          null: true,
          description: 'Project no longer excluded due to the mutation.'

        argument :integration_name,
          ::Types::Integrations::IntegrationTypeEnum,
          required: true,
          description: 'Type of integration.'

        argument :project_ids,
          [::Types::GlobalIDType[::Project]],
          required: false,
          description: 'IDs of excluded projects.'

        argument :group_ids,
          [::Types::GlobalIDType[::Group]],
          required: false,
          description: 'IDs of excluded groups.'

        authorize :admin_all_resources

        def resolve(integration_name:, project_ids: [], group_ids: [])
          authorize!(:global)

          result = ::Integrations::Exclusions::DestroyService.new(
            current_user: current_user,
            projects: projects(project_ids),
            groups: groups(group_ids),
            integration_name: integration_name
          ).execute

          exclusions = result.payload

          # Integrations::Exclusions::DestroyService calls destroy_all in some circumstances which returns a frozen
          # array.  We call dup here to allow entries to be redacted by field extensions.
          exclusions = exclusions.dup if exclusions.frozen?
          {
            exclusions: exclusions,
            errors: result.errors
          }
        end

        private

        def projects(project_ids)
          return [] unless project_ids.present?

          Project.id_in(resolve_ids(project_ids))
        end

        def groups(group_ids)
          return [] unless group_ids.present?

          Group.id_in(resolve_ids(group_ids))
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/base.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class Base < BaseMutation
      include Mutations::ResolvesIssuable

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Project the issue to mutate is in."

      argument :iid, GraphQL::Types::String,
        required: true,
        description: "IID of the issue to mutate."

      field :issue,
        Types::IssueType,
        null: true,
        description: "Issue after mutation."

      authorize :update_issue

      private

      def find_object(project_path:, iid:)
        resolve_issuable(type: :issue, parent_path: project_path, iid: iid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/common_mutation_arguments.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    module CommonMutationArguments
      extend ActiveSupport::Concern

      included do
        argument :description, GraphQL::Types::String,
          required: false,
          description: copy_field_description(Types::IssueType, :description)

        argument :due_date, GraphQL::Types::ISO8601Date,
          required: false,
          description: copy_field_description(Types::IssueType, :due_date)

        argument :confidential, GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::IssueType, :confidential)

        argument :locked, GraphQL::Types::Boolean,
          as: :discussion_locked,
          required: false,
          description: copy_field_description(Types::IssueType, :discussion_locked)

        argument :type, Types::IssueTypeEnum,
          as: :issue_type,
          required: false,
          description: copy_field_description(Types::IssueType, :type)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/create.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class Create < BaseMutation
      graphql_name 'CreateIssue'

      include Mutations::SpamProtection
      include FindsProject
      include CommonMutationArguments

      authorize :create_issue

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project full path the issue is associated with.'

      argument :iid, GraphQL::Types::Int,
        required: false,
        description: 'IID (internal ID) of a project issue. Only admins and project owners can modify.'

      argument :title, GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::IssueType, :title)

      argument :milestone_id, ::Types::GlobalIDType[::Milestone],
        required: false,
        description: 'ID of the milestone to assign to the issue. On update milestone will be removed if set to null.'

      argument :labels, [GraphQL::Types::String],
        required: false,
        description: copy_field_description(Types::IssueType, :labels)

      argument :label_ids, [::Types::GlobalIDType[::Label]],
        required: false,
        description: 'IDs of labels to be added to the issue.'

      argument :created_at, Types::TimeType,
        required: false,
        description: 'Timestamp when the issue was created. Available only for admins and project owners.'

      argument :merge_request_to_resolve_discussions_of, ::Types::GlobalIDType[::MergeRequest],
        required: false,
        description: 'IID of a merge request for which to resolve discussions.'

      argument :discussion_to_resolve, GraphQL::Types::String,
        required: false,
        description: 'ID of a discussion to resolve. Also pass `merge_request_to_resolve_discussions_of`.'

      argument :assignee_ids, [::Types::GlobalIDType[::User]],
        required: false,
        description: 'Array of user IDs to assign to the issue.'

      argument :move_before_id, ::Types::GlobalIDType[::Issue],
        required: false,
        description: 'Global ID of issue that should be placed before the current issue.'

      argument :move_after_id, ::Types::GlobalIDType[::Issue],
        required: false,
        description: 'Global ID of issue that should be placed after the current issue.'

      field :issue,
        Types::IssueType,
        null: true,
        description: 'Issue after mutation.'

      validates mutually_exclusive: [:labels, :label_ids]

      def ready?(**args)
        if args[:discussion_to_resolve].present? && args[:merge_request_to_resolve_discussions_of].blank?
          raise Gitlab::Graphql::Errors::ArgumentError,
            'to resolve a discussion please also provide `merge_request_to_resolve_discussions_of` parameter'
        end

        super
      end

      def resolve(project_path:, **attributes)
        project = authorized_find!(project_path)
        params = build_create_issue_params(attributes.merge(author_id: current_user.id), project)
        result = ::Issues::CreateService.new(container: project, current_user: current_user, params: params).execute

        check_spam_action_response!(result[:issue]) if result[:issue]

        {
          issue: result.success? ? result[:issue] : nil,
          errors: result.errors
        }
      end

      private

      # _project argument is unused here, but it is necessary on the EE version of the method
      def build_create_issue_params(params, _project)
        params[:milestone_id] &&= params[:milestone_id]&.model_id
        params[:assignee_ids] &&= params[:assignee_ids].map { |assignee_id| assignee_id&.model_id }
        params[:label_ids] &&= params[:label_ids].map { |label_id| label_id&.model_id }

        if params[:move_before_id].present? || params[:move_after_id].present?
          params[:move_between_ids] = [
            params.delete(:move_before_id)&.model_id,
            params.delete(:move_after_id)&.model_id
          ]
        end

        params
      end
    end
  end
end

Mutations::Issues::Create.prepend_mod_with('Mutations::Issues::Create')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/link_alerts.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class LinkAlerts < Base
      graphql_name 'IssueLinkAlerts'

      argument :alert_references, [GraphQL::Types::String],
        required: true,
        description: 'Alerts references to be linked to the incident.'

      authorize :admin_issue

      def resolve(project_path:, iid:, alert_references:)
        issue = authorized_find!(project_path: project_path, iid: iid)

        ::IncidentManagement::LinkAlerts::CreateService.new(issue, current_user, alert_references).execute

        {
          issue: issue,
          errors: errors_on_object(issue)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/move.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class Move < Base
      graphql_name 'IssueMove'

      argument :target_project_path,
        GraphQL::Types::ID,
        required: true,
        description: 'Project to move the issue to.'

      def resolve(project_path:, iid:, target_project_path:)
        Gitlab::QueryLimiting.disable!('https://gitlab.com/gitlab-org/gitlab/-/issues/20816')

        issue = authorized_find!(project_path: project_path, iid: iid)
        target_project = resolve_project(full_path: target_project_path).sync

        begin
          response = ::WorkItems::DataSync::MoveService.new(
            work_item: issue, current_user: current_user,
            target_namespace: target_project.project_namespace
          ).execute

          errors = response.message if response.error?
          moved_issue = response.payload[:work_item]
        end

        {
          issue: moved_issue,
          errors: Array.wrap(errors)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_assignees.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetAssignees < Base
      graphql_name 'IssueSetAssignees'

      include Assignable

      def assign!(issue, users, mode)
        permitted, forbidden = users.partition { |u| u.can?(:read_issue, issue.resource_parent) }

        super(issue, permitted, mode)

        forbidden.each do |user|
          issue.errors.add(
            :assignees,
            "Cannot assign #{user.to_reference} to #{issue.to_reference}"
          )
        end
      end

      def update_service_class
        ::Issues::UpdateService
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_confidential.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetConfidential < Base
      graphql_name 'IssueSetConfidential'

      include Mutations::SpamProtection

      argument :confidential,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Whether or not to set the issue as a confidential.'

      def resolve(project_path:, iid:, confidential:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project
        # Changing confidentiality affects spam checking rules, therefore we need to perform a spam check
        ::Issues::UpdateService.new(
          container: project,
          current_user: current_user,
          params: { confidential: confidential },
          perform_spam_check: true
        ).execute(issue)
        check_spam_action_response!(issue)

        {
          issue: issue.reset,
          errors: errors_on_object(issue)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_crm_contacts.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetCrmContacts < Base
      graphql_name 'IssueSetCrmContacts'

      argument :contact_ids,
        [::Types::GlobalIDType[::CustomerRelations::Contact]],
        required: true,
        description: 'Customer relations contact IDs to set. Replaces existing contacts by default.'

      argument :operation_mode,
        Types::MutationOperationModeEnum,
        required: false,
        description: 'Changes the operation mode. Defaults to REPLACE.'

      def resolve(project_path:, iid:, contact_ids:, operation_mode: Types::MutationOperationModeEnum.enum[:replace])
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project

        raise_resource_not_available_error! 'Feature disabled' unless feature_enabled?(project)

        contact_ids = contact_ids.compact.map do |contact_id|
          unless contact_id.respond_to?(:model_id)
            raise Gitlab::Graphql::Errors::ArgumentError, "Contact #{contact_id} is invalid."
          end

          contact_id.model_id.to_i
        end

        attribute_name = case operation_mode
                         when Types::MutationOperationModeEnum.enum[:append]
                           :add_ids
                         when Types::MutationOperationModeEnum.enum[:remove]
                           :remove_ids
                         else
                           :replace_ids
                         end

        response = ::Issues::SetCrmContactsService.new(
          container: project,
          current_user: current_user,
          params: { attribute_name => contact_ids }
        ).execute(issue)

        {
          issue: issue,
          errors: response.errors
        }
      end

      private

      def feature_enabled?(project)
        project.group&.crm_enabled?
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_due_date.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetDueDate < Base
      graphql_name 'IssueSetDueDate'

      argument :due_date,
        Types::TimeType,
        required: :nullable,
        description: 'Desired due date for the issue. Due date is removed if null.'

      def resolve(project_path:, iid:, due_date:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project

        ::Issues::UpdateService.new(container: project, current_user: current_user, params: { due_date: due_date })
          .execute(issue)

        {
          issue: issue,
          errors: errors_on_object(issue)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_escalation_status.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetEscalationStatus < Base
      graphql_name 'IssueSetEscalationStatus'

      argument :status, Types::IncidentManagement::EscalationStatusEnum,
        required: true,
        description: 'Set the escalation status.'

      def resolve(project_path:, iid:, status:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project

        authorize_escalation_status!(project)
        check_feature_availability!(issue)

        ::Issues::UpdateService.new(
          container: project,
          current_user: current_user,
          params: { escalation_status: { status: status } }
        ).execute(issue)

        {
          issue: issue,
          errors: errors_on_object(issue)
        }
      end

      private

      def authorize_escalation_status!(project)
        return if Ability.allowed?(current_user, :update_escalation_status, project)

        raise_resource_not_available_error!
      end

      def check_feature_availability!(issue)
        return if issue.supports_escalation?

        raise_resource_not_available_error! 'Feature unavailable for provided issue'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_locked.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetLocked < Base
      graphql_name 'IssueSetLocked'

      argument :locked,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Whether or not to lock discussion on the issue.'

      def resolve(project_path:, iid:, locked:)
        issue = authorized_find!(project_path: project_path, iid: iid)

        ::Issues::UpdateService.new(
          container: issue.project,
          current_user: current_user,
          params: { discussion_locked: locked }
        ).execute(issue)

        {
          issue: issue,
          errors: errors_on_object(issue)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_severity.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetSeverity < Base
      graphql_name 'IssueSetSeverity'

      argument :severity, Types::IssuableSeverityEnum,
        required: true,
        description: 'Set the incident severity level.'

      authorize :admin_issue

      def resolve(project_path:, iid:, severity:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project

        ::Issues::UpdateService.new(container: project, current_user: current_user, params: { severity: severity })
          .execute(issue)

        {
          issue: issue,
          errors: errors_on_object(issue)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/set_subscription.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class SetSubscription < BaseMutation
      graphql_name 'IssueSetSubscription'

      include ResolvesSubscription
      include Mutations::ResolvesIssuable

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Project the issue to mutate is in."

      argument :iid, GraphQL::Types::String,
        required: true,
        description: "IID of the issue to mutate."

      field :issue,
        Types::IssueType,
        null: true,
        description: "Issue after mutation."

      authorize :update_subscription

      private

      def find_object(project_path:, iid:)
        resolve_issuable(type: :issue, parent_path: project_path, iid: iid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/unlink_alert.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class UnlinkAlert < Base
      graphql_name 'IssueUnlinkAlert'

      argument :alert_id, ::Types::GlobalIDType[::AlertManagement::Alert],
        required: true,
        description: 'Global ID of the alert to unlink from the incident.'

      authorize :admin_issue

      def resolve(project_path:, iid:, alert_id:)
        issue = authorized_find!(project_path: project_path, iid: iid)
        alert = find_alert_by_gid(alert_id)

        result = ::IncidentManagement::LinkAlerts::DestroyService.new(issue, current_user, alert).execute

        {
          issue: issue,
          errors: result.errors
        }
      end

      private

      def find_alert_by_gid(alert_id)
        ::Gitlab::Graphql::Lazy.force(GitlabSchema.object_from_id(alert_id, expected_type: ::AlertManagement::Alert))
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/issues/update.rb =====
# frozen_string_literal: true

module Mutations
  module Issues
    class Update < Base
      graphql_name 'UpdateIssue'

      include CommonMutationArguments
      include ValidateTimeEstimate

      argument :title, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::IssueType, :title)

      argument :milestone_id, GraphQL::Types::ID, # rubocop: disable Graphql/IDType
        required: false,
        description: 'ID of the milestone to assign to the issue. On update milestone will be removed if set to null.'

      argument :add_label_ids, [GraphQL::Types::ID],
        required: false,
        description: 'IDs of labels to be added to the issue.'

      argument :remove_label_ids, [GraphQL::Types::ID],
        required: false,
        description: 'IDs of labels to be removed from the issue.'

      argument :label_ids, [GraphQL::Types::ID],
        required: false,
        description: 'IDs of labels to be set. Replaces existing issue labels.'

      argument :state_event, Types::IssueStateEventEnum,
        description: 'Close or reopen an issue.',
        required: false

      argument :time_estimate, GraphQL::Types::String,
        required: false,
        description: 'Estimated time to complete the issue. ' \
          'Use `null` or `0` to remove the current estimate.'

      def resolve(project_path:, iid:, **args)
        issue = authorized_find!(project_path: project_path, iid: iid)
        project = issue.project

        args = parse_arguments(args)

        ::Issues::UpdateService.new(
          container: project,
          current_user: current_user,
          params: args,
          perform_spam_check: true
        ).execute(issue)

        {
          issue: issue,
          errors: errors_on_object(issue)
        }
      end

      def ready?(label_ids: [], add_label_ids: [], remove_label_ids: [], time_estimate: nil, **args)
        if label_ids.any? && (add_label_ids.any? || remove_label_ids.any?)
          raise Gitlab::Graphql::Errors::ArgumentError,
            'labelIds is mutually exclusive with any of addLabelIds or removeLabelIds'
        end

        validate_time_estimate(time_estimate)

        super
      end

      private

      def parse_arguments(args)
        args[:add_label_ids] = parse_label_ids(args[:add_label_ids])
        args[:remove_label_ids] = parse_label_ids(args[:remove_label_ids])
        args[:label_ids] = parse_label_ids(args[:label_ids])

        if args.key?(:time_estimate)
          args[:time_estimate] =
            args[:time_estimate].nil? ? 0 : Gitlab::TimeTrackingFormatter.parse(args[:time_estimate], keep_zero: true)
        end

        args
      end

      def parse_label_ids(ids)
        ids&.map do |gid|
          GitlabSchema.parse_gid(gid, expected_type: ::Label).model_id
        rescue Gitlab::Graphql::Errors::ArgumentError
          gid
        end
      end
    end
  end
end

Mutations::Issues::Update.prepend_mod_with('Mutations::Issues::Update')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/jira_import/import_users.rb =====
# frozen_string_literal: true

module Mutations
  module JiraImport
    class ImportUsers < BaseMutation
      graphql_name 'JiraImportUsers'

      include FindsProject

      authorize :admin_project

      field :jira_users,
        [Types::JiraUserType],
        null: true,
        description: 'Users returned from Jira, matched by email and name if possible.'

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project to import the Jira users into.'
      argument :start_at, GraphQL::Types::Int,
        required: false,
        description: 'Index of the record the import should started at, default 0 (50 records returned).'

      def resolve(project_path:, start_at: 0)
        project = authorized_find!(project_path)

        service_response = ::JiraImport::UsersImporter.new(context[:current_user], project, start_at.to_i).execute

        {
          jira_users: service_response.payload,
          errors: service_response.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/jira_import/start.rb =====
# frozen_string_literal: true

module Mutations
  module JiraImport
    class Start < BaseMutation
      graphql_name 'JiraImportStart'

      include FindsProject

      authorize :admin_project

      field :jira_import,
        Types::JiraImportType,
        null: true,
        description: 'Jira import data after mutation.'

      argument :jira_project_key, GraphQL::Types::String,
        required: true,
        description: 'Project key of the importer Jira project.'
      argument :jira_project_name, GraphQL::Types::String,
        required: false,
        description: 'Project name of the importer Jira project.',
        deprecated: { milestone: '17.4', reason: 'Argument is not used' }
      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project to import the Jira project into.'
      argument :users_mapping,
        [Types::JiraUsersMappingInputType],
        required: false,
        description: 'Mapping of Jira to GitLab users.'

      def resolve(project_path:, jira_project_key:, users_mapping:) # rubocop: disable GraphQL/UnusedArgument -- `jira_project_name` must be deprecated before we can remove it
        project = authorized_find!(project_path)
        mapping = users_mapping.to_ary.map(&:to_hash)

        service_response = ::JiraImport::StartImportService
                             .new(context[:current_user], project, jira_project_key, mapping)
                             .execute
        jira_import = service_response.success? ? service_response.payload[:import_data] : nil

        {
          jira_import: jira_import,
          errors: service_response.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/labels/create.rb =====
# frozen_string_literal: true

module Mutations
  module Labels
    class Create < BaseMutation
      graphql_name 'LabelCreate'

      include Mutations::ResolvesResourceParent

      field :label,
        Types::LabelType,
        null: true,
        description: 'Label after mutation.'

      argument :title, GraphQL::Types::String,
        required: true,
        description: 'Title of the label.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description of the label.'

      argument :color, GraphQL::Types::String,
        required: false,
        default_value: Label::DEFAULT_COLOR,
        see: {
          'List of color keywords at mozilla.org' =>
            'https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords'
        },
        description: <<~DESC
                 The color of the label given in 6-digit hex notation with leading '#' sign
                 (for example, `#FFAABB`) or one of the CSS color names.
        DESC

      authorize :admin_label

      def resolve(args)
        parent = authorized_resource_parent_find!(args)
        parent_key = parent.is_a?(Project) ? :project : :group

        label = ::Labels::CreateService.new(args).execute(parent_key => parent)

        {
          label: label.persisted? ? label : nil,
          errors: errors_on_object(label)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/members/bulk_update_base.rb =====
# frozen_string_literal: true

module Mutations
  module Members
    class BulkUpdateBase < BaseMutation
      include ::API::Helpers::MembersHelpers

      argument :user_ids,
        [::Types::GlobalIDType[::User]],
        required: true,
        description: 'Global IDs of the members.'

      argument :access_level,
        ::Types::MemberAccessLevelEnum,
        required: true,
        description: 'Access level to update the members to.'

      argument :expires_at,
        Types::TimeType,
        required: false,
        description: 'Date and time the membership expires.'

      MAX_MEMBERS_UPDATE_LIMIT = 50
      MAX_MEMBERS_UPDATE_ERROR = "Count of members to be updated should be less than #{MAX_MEMBERS_UPDATE_LIMIT}."
                                   .freeze
      INVALID_MEMBERS_ERROR = 'Only access level of direct members can be updated.'

      def resolve(**args)
        source = authorized_find!(source_id: args[source_id_param_name])

        result = ::Members::UpdateService
                   .new(current_user, args.except(:user_ids, source_id_param_name).merge({ source: source }))
                   .execute(@updatable_members)

        present_result(result)
      rescue Gitlab::Access::AccessDeniedError
        {
          errors: ["Unable to update members, please check user permissions."]
        }
      end

      private

      def ready?(**args)
        source = authorized_find!(source_id: args[source_id_param_name])
        user_ids = args.fetch(:user_ids, {}).map(&:model_id)
        @updatable_members = only_direct_members(source, user_ids)

        if @updatable_members.size > MAX_MEMBERS_UPDATE_LIMIT
          raise Gitlab::Graphql::Errors::InvalidMemberCountError, MAX_MEMBERS_UPDATE_ERROR
        end

        if @updatable_members.size != user_ids.size
          raise Gitlab::Graphql::Errors::InvalidMembersError, INVALID_MEMBERS_ERROR
        end

        super
      end

      def find_object(source_id:)
        GitlabSchema.object_from_id(source_id, expected_type: source_type)
      end

      def only_direct_members(source, user_ids)
        source_members(source)
          .with_user(user_ids)
          .to_a
      end

      def source_id_param_name
        :"#{source_name}_id"
      end

      def source_members_key
        :"#{source_name}_members"
      end

      def source_name
        source_type.name.downcase
      end

      def present_result(result)
        {
          source_members_key => result[:members],
          errors: Array.wrap(result[:message])
        }
      end

      def source_type
        raise NotImplementedError
      end
    end
  end
end

Mutations::Members::BulkUpdateBase.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/members/groups/bulk_update.rb =====
# frozen_string_literal: true

module Mutations
  module Members
    module Groups
      class BulkUpdate < BulkUpdateBase
        graphql_name 'GroupMemberBulkUpdate'
        authorize :admin_group_member

        field :group_members,
          [Types::GroupMemberType],
          null: true,
          description: 'Group members after mutation.'

        argument :group_id,
          ::Types::GlobalIDType[::Group],
          required: true,
          description: 'Global ID of the group.'

        def source_type
          ::Group
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/members/projects/bulk_update.rb =====
# frozen_string_literal: true

module Mutations
  module Members
    module Projects
      class BulkUpdate < BulkUpdateBase
        graphql_name 'ProjectMemberBulkUpdate'
        description 'Updates multiple members of a project. ' \
          'To use this mutation, you must have at least the Maintainer role.'

        authorize :admin_project_member

        field :project_members,
          [Types::ProjectMemberType],
          null: true,
          description: 'Project members after mutation.'

        argument :project_id,
          ::Types::GlobalIDType[::Project],
          required: true,
          description: 'Global ID of the project.'

        def source_type
          ::Project
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/accept.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class Accept < Base
      graphql_name 'MergeRequestAccept'
      authorize :accept_merge_request
      description <<~DESC
        Accepts a merge request.
        When accepted, the source branch will be scheduled to merge into the target branch, either
        immediately if possible, or using one of the automatic merge strategies.

        [In GitLab 16.5](https://gitlab.com/gitlab-org/gitlab/-/issues/421510), the merging happens asynchronously.
        This results in `mergeRequest` and `state` not updating after a mutation request,
        because the merging may not have happened yet.
      DESC

      NOT_MERGEABLE = 'This branch cannot be merged'
      HOOKS_VALIDATION_ERROR = 'Pre-merge hooks failed'
      SHA_MISMATCH = 'The merge-head is not at the anticipated SHA'
      MERGE_FAILED = 'The merge failed'
      ALREADY_SCHEDULED = 'The merge request is already scheduled to be merged'

      argument :strategy,
        ::Types::MergeStrategyEnum,
        required: false,
        as: :auto_merge_strategy,
        description: 'How to merge the merge request.'

      argument :commit_message, ::GraphQL::Types::String,
        required: false,
        description: 'Custom merge commit message.'
      argument :sha, ::GraphQL::Types::String,
        required: true,
        description: 'HEAD SHA at the time when the merge was requested.'
      argument :squash_commit_message, ::GraphQL::Types::String,
        required: false,
        description: 'Custom squash commit message (if squash is true).'

      argument :should_remove_source_branch, ::GraphQL::Types::Boolean,
        required: false,
        description: 'Should the source branch be removed.'
      argument :squash, ::GraphQL::Types::Boolean,
        required: false,
        default_value: false,
        description: 'Squash commits on the source branch before merge.'

      def resolve(project_path:, iid:, **args)
        Gitlab::QueryLimiting.disable!('https://gitlab.com/gitlab-org/gitlab/-/issues/4796')

        merge_request = authorized_find!(project_path: project_path, iid: iid)
        project = merge_request.target_project
        merge_params = args.compact.with_indifferent_access
        merge_service = ::MergeRequests::MergeService.new(
          project: project,
          current_user: current_user,
          params: merge_params
        )

        if error = validate(merge_request, merge_service, merge_params)
          return { merge_request: merge_request, errors: [error] }
        end

        merge_request.update(merge_error: nil, squash: merge_params[:squash])

        result = if merge_params.key?(:auto_merge_strategy)
                   service = AutoMergeService.new(project, current_user, merge_params)
                   service.execute(merge_request, merge_params[:auto_merge_strategy])
                 else
                   merge_request.merge_async(current_user.id, merge_params)
                 end

        {
          merge_request: merge_request,
          errors: result == :failed ? [MERGE_FAILED] : []
        }
      rescue ::MergeRequests::MergeBaseService::MergeError => e
        {
          merge_request: merge_request,
          errors: [e.message]
        }
      end

      def validate(merge_request, merge_service, merge_params)
        skipped_checks = merge_request.skipped_mergeable_checks(
          auto_merge_strategy: merge_params[:auto_merge_strategy]
        )

        if merge_request.auto_merge_enabled?
          ALREADY_SCHEDULED
        elsif !merge_request.mergeable?(**skipped_checks)
          NOT_MERGEABLE
        elsif !merge_service.hooks_validation_pass?(merge_request)
          HOOKS_VALIDATION_ERROR
        elsif merge_params[:sha] != merge_request.diff_head_sha
          SHA_MISMATCH
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/base.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class Base < BaseMutation
      include Mutations::ResolvesIssuable

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Project the merge request to mutate is in."

      argument :iid, GraphQL::Types::String,
        required: true,
        description: "IID of the merge request to mutate."

      field :merge_request,
        Types::MergeRequestType,
        null: true,
        description: "Merge request after mutation."

      authorize :update_merge_request

      private

      def find_object(project_path:, iid:)
        resolve_issuable(type: :merge_request, parent_path: project_path, iid: iid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/create.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class Create < BaseMutation
      graphql_name 'MergeRequestCreate'

      include FindsProject

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project full path the merge request is associated with.'

      argument :title, GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::MergeRequestType, :title)

      argument :source_branch, GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::MergeRequestType, :source_branch)

      argument :target_branch, GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::MergeRequestType, :target_branch)

      argument :description, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::MergeRequestType, :description)

      argument :labels, [GraphQL::Types::String],
        required: false,
        description: copy_field_description(Types::MergeRequestType, :labels)

      argument :merge_after, ::Types::TimeType,
        required: false,
        description: copy_field_description(Types::MergeRequestType, :merge_after)

      field :merge_request,
        Types::MergeRequestType,
        null: true,
        description: 'Merge request after mutation.'

      authorize :create_merge_request_from

      def resolve(project_path:, **attributes)
        project = authorized_find!(project_path)
        params = attributes.merge(author_id: current_user.id)

        merge_request = ::MergeRequests::CreateService.new(
          project: project,
          current_user: current_user,
          params: params
        ).execute

        {
          merge_request: merge_request.valid? ? merge_request : nil,
          errors: errors_on_object(merge_request)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/reviewer_rereview.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class ReviewerRereview < Base
      graphql_name 'MergeRequestReviewerRereview'

      argument :user_id, ::Types::GlobalIDType[::User],
        loads: Types::UserType,
        required: true,
        description: <<~DESC
                            User ID for the user that has been requested for a new review.
        DESC

      def resolve(project_path:, iid:, user:)
        merge_request = authorized_find!(project_path: project_path, iid: iid)

        result = ::MergeRequests::RequestReviewService.new(
          project: merge_request.project,
          current_user: current_user
        ).execute(merge_request, user)

        {
          merge_request: merge_request,
          errors: Array(result[:message])
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_assignees.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetAssignees < Base
      graphql_name 'MergeRequestSetAssignees'

      include Assignable

      def update_service_class
        ::MergeRequests::UpdateAssigneesService
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_draft.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetDraft < Base
      graphql_name 'MergeRequestSetDraft'

      argument :draft,
        GraphQL::Types::Boolean,
        required: true,
        description: <<~DESC
                 Whether or not to set the merge request as a draft.
        DESC

      def resolve(project_path:, iid:, draft: nil)
        merge_request = authorized_find!(project_path: project_path, iid: iid)
        project = merge_request.project

        ::MergeRequests::UpdateService.new(
          project: project,
          current_user: current_user,
          params: { wip_event: wip_event(draft) }
        ).execute(merge_request)

        {
          merge_request: merge_request,
          errors: errors_on_object(merge_request)
        }
      end

      private

      def wip_event(draft)
        draft ? 'draft' : 'ready'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_labels.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetLabels < Base
      graphql_name 'MergeRequestSetLabels'

      argument :label_ids,
        [::Types::GlobalIDType[Label]],
        required: true,
        description: <<~DESC
                 Label IDs to set. Replaces existing labels by default.
        DESC

      argument :operation_mode,
        Types::MutationOperationModeEnum,
        required: false,
        description: <<~DESC
                 Changes the operation mode. Defaults to REPLACE.
        DESC

      def resolve(project_path:, iid:, label_ids:, operation_mode: Types::MutationOperationModeEnum.enum[:replace])
        merge_request = authorized_find!(project_path: project_path, iid: iid)
        project = merge_request.project

        # MergeRequests::UpdateService expects integers
        label_ids = label_ids.compact.map(&:model_id)

        attribute_name = case operation_mode
                         when Types::MutationOperationModeEnum.enum[:append]
                           :add_label_ids
                         when Types::MutationOperationModeEnum.enum[:remove]
                           :remove_label_ids
                         else
                           :label_ids
                         end

        ::MergeRequests::UpdateService.new(
          project: project,
          current_user: current_user,
          params: { attribute_name => label_ids }
        ).execute(merge_request)

        {
          merge_request: merge_request,
          errors: errors_on_object(merge_request)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_locked.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetLocked < Base
      graphql_name 'MergeRequestSetLocked'

      argument :locked,
        GraphQL::Types::Boolean,
        required: true,
        description: <<~DESC
                 Whether or not to lock the merge request.
        DESC

      def resolve(project_path:, iid:, locked:)
        merge_request = authorized_find!(project_path: project_path, iid: iid)
        project = merge_request.project

        ::MergeRequests::UpdateService.new(
          project: project,
          current_user: current_user,
          params: { discussion_locked: locked }
        ).execute(merge_request)

        {
          merge_request: merge_request,
          errors: errors_on_object(merge_request)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_milestone.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetMilestone < Base
      graphql_name 'MergeRequestSetMilestone'

      argument :milestone_id,
        ::Types::GlobalIDType[::Milestone],
        required: false,
        loads: Types::MilestoneType,
        description: <<~DESC
                 Milestone to assign to the merge request.
        DESC

      def resolve(project_path:, iid:, milestone: nil)
        merge_request = authorized_find!(project_path: project_path, iid: iid)
        project = merge_request.project

        ::MergeRequests::UpdateService.new(
          project: project,
          current_user: current_user,
          params: { milestone_id: milestone&.id }
        ).execute(merge_request)

        {
          merge_request: merge_request,
          errors: errors_on_object(merge_request)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_reviewers.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetReviewers < Base
      graphql_name 'MergeRequestSetReviewers'

      argument :reviewer_usernames,
        [GraphQL::Types::String],
        required: true,
        description: 'Usernames of reviewers to assign. Replaces existing reviewers by default.'

      argument :operation_mode,
        Types::MutationOperationModeEnum,
        required: false,
        default_value: Types::MutationOperationModeEnum.default_mode,
        description: 'Operation to perform. Defaults to REPLACE.'

      def resolve(project_path:, iid:, reviewer_usernames:, operation_mode:)
        resource = authorized_find!(project_path: project_path, iid: iid)

        ::MergeRequests::UpdateReviewersService.new(
          project: resource.project,
          current_user: current_user,
          params: { reviewer_ids: reviewer_ids(resource, reviewer_usernames, operation_mode) }
        ).execute(resource)

        {
          resource.class.name.underscore.to_sym => resource,
          errors: errors_on_object(resource)
        }
      end

      private

      def reviewer_ids(resource, usernames, mode)
        new_reviewers = UsersFinder.new(current_user, username: usernames).execute.to_a
        new_reviewer_ids = user_ids(new_reviewers)

        case mode
        when 'REPLACE' then new_reviewer_ids
        when 'APPEND' then user_ids(resource.reviewers) | new_reviewer_ids
        when 'REMOVE' then user_ids(resource.reviewers) - new_reviewer_ids
        end
      end

      def user_ids(users)
        users.map(&:id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/set_subscription.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class SetSubscription < BaseMutation
      graphql_name 'MergeRequestSetSubscription'

      include ResolvesSubscription
      include Mutations::ResolvesIssuable

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Project the merge request to mutate is in."

      argument :iid, GraphQL::Types::String,
        required: true,
        description: "IID of the merge request to mutate."

      field :merge_request,
        Types::MergeRequestType,
        null: true,
        description: "Merge request after mutation."

      authorize :update_subscription

      private

      def find_object(project_path:, iid:)
        resolve_issuable(type: :merge_request, parent_path: project_path, iid: iid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/merge_requests/update.rb =====
# frozen_string_literal: true

module Mutations
  module MergeRequests
    class Update < Base
      graphql_name 'MergeRequestUpdate'

      include ValidateTimeEstimate

      description 'Update attributes of a merge request'

      argument :title, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::MergeRequestType, :title)

      argument :target_branch, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::MergeRequestType, :target_branch)

      argument :description, GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::MergeRequestType, :description)

      argument :state, ::Types::MergeRequestStateEventEnum,
        required: false,
        as: :state_event,
        description: 'Action to perform to change the state.'

      argument :time_estimate, GraphQL::Types::String,
        required: false,
        description: 'Estimated time to complete the merge request. ' \
          'Use `null` or `0` to remove the current estimate.'

      argument :merge_after, ::Types::TimeType,
        required: false,
        description: copy_field_description(Types::MergeRequestType, :merge_after)

      def resolve(project_path:, iid:, **args)
        merge_request = authorized_find!(project_path: project_path, iid: iid)
        args = parse_arguments(args)

        ::MergeRequests::UpdateService
          .new(project: merge_request.project, current_user: current_user, params: args)
          .execute(merge_request)

        errors = errors_on_object(merge_request)

        {
          merge_request: merge_request.reset,
          errors: errors
        }
      end

      def ready?(time_estimate: nil, **args)
        validate_time_estimate(time_estimate)

        super
      end

      private

      def parse_arguments(args)
        if args.key?(:time_estimate)
          args[:time_estimate] =
            args[:time_estimate].nil? ? 0 : Gitlab::TimeTrackingFormatter.parse(args[:time_estimate], keep_zero: true)
        end

        args.compact
      end
    end
  end
end

Mutations::MergeRequests::Update.prepend_mod_with('Mutations::MergeRequests::Update')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/metrics/dashboard/annotations/create.rb =====
# frozen_string_literal: true

# Deprecated:
#   Remove from MutationType during any major release.
module Mutations
  module Metrics
    module Dashboard
      module Annotations
        class Create < BaseMutation
          graphql_name 'CreateAnnotation'

          field :annotation,
            Types::Metrics::Dashboards::AnnotationType,
            null: true,
            description: 'Created annotation.'

          argument :environment_id,
            ::Types::GlobalIDType[::Environment],
            required: false,
            description: 'Global ID of the environment to add an annotation to.'

          argument :cluster_id,
            ::Types::GlobalIDType[::Clusters::Cluster],
            required: false,
            description: 'Global ID of the cluster to add an annotation to.'

          argument :starting_at, Types::TimeType,
            required: true,
            description: 'Timestamp indicating starting moment to which the annotation relates.'

          argument :ending_at, Types::TimeType,
            required: false,
            description: 'Timestamp indicating ending moment to which the annotation relates.'

          argument :dashboard_path,
            GraphQL::Types::String,
            required: true,
            description: 'Path to a file defining the dashboard on which the annotation should be added.'

          argument :description,
            GraphQL::Types::String,
            required: true,
            description: 'Description of the annotation.'

          def resolve(_args)
            raise_resource_not_available_error!
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/metrics/dashboard/annotations/delete.rb =====
# frozen_string_literal: true

# Deprecated:
#   Remove from MutationType during any major release.
module Mutations
  module Metrics
    module Dashboard
      module Annotations
        class Delete < BaseMutation
          graphql_name 'DeleteAnnotation'

          argument :id, GraphQL::Types::String,
            required: true,
            description: 'Global ID of the annotation to delete.'

          def resolve(_args)
            raise_resource_not_available_error!
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/models/base.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module Models
      class Base < BaseMutation
        authorize :write_model_registry

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: "Project the model to mutate is in."

        field :model,
          Types::Ml::ModelType,
          null: true,
          description: 'Model after mutation.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/models/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module Models
      class Create < Base
        graphql_name 'MlModelCreate'

        include FindsProject

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the model.'

        argument :description, GraphQL::Types::String,
          required: false,
          description: 'Description of the model.'

        def resolve(**args)
          project = authorized_find!(args[:project_path])

          service_response = ::Ml::CreateModelService.new(project, args[:name], current_user,
            args[:description]).execute

          if service_response.success?
            {
              model: service_response.payload,
              errors: []
            }
          else
            {
              model: nil,
              errors: service_response.errors
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/models/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module Models
      class Delete < Base
        graphql_name 'MlModelDelete'

        include FindsProject

        argument :id, ::Types::GlobalIDType[::Ml::Model],
          required: true,
          description: 'Global ID of the model to be deleted.'

        def resolve(**args)
          project = authorized_find!(args[:project_path])

          model = ::Ml::Model.by_project_id_and_id(project.id, args[:id].model_id)

          return { errors: ['Model not found'] } unless model

          result = ::Ml::DestroyModelService.new(model, current_user).execute

          {
            model: result.payload[:model],
            errors: result.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/models/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module Models
      class Destroy < Base
        graphql_name 'MlModelDestroy'

        include FindsProject

        argument :id, ::Types::GlobalIDType[::Ml::Model],
          required: true,
          description: 'Global ID of the model to be deleted.'

        field :message, GraphQL::Types::String,
          null: true,
          description: 'Model deletion result message.'

        def resolve(**args)
          project = authorized_find!(args[:project_path])

          model = ::Ml::Model.by_project_id_and_id(project.id, args[:id].model_id)

          return { errors: ['Model not found'] } unless model

          result = ::Ml::DestroyModelService.new(model, current_user).execute

          {
            message: result.success? ? result[:message] : nil,
            errors: result.error? ? Array.wrap(result[:message]) : []
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/models/edit.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module Models
      class Edit < Base
        graphql_name 'MlModelEdit'

        include FindsProject

        argument :model_id, GraphQL::Types::Int,
          required: false,
          description: 'Id of the model.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the model.'

        argument :description, GraphQL::Types::String,
          required: false,
          description: 'Description of the model.'

        def resolve(project_path:, name:, model_id:, description:)
          project = authorized_find!(project_path)
          model = ::Ml::FindModelService.new(project, name, model_id).execute
          service_response = ::Ml::UpdateModelService.new(model, description).execute

          if service_response.success?
            {
              model: service_response.payload,
              errors: []
            }
          else
            {
              model: nil,
              errors: service_response.errors
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/model_versions/create.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module ModelVersions
      class Create < BaseMutation
        graphql_name 'MlModelVersionCreate'
        authorize :write_model_registry

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: "Project the model to mutate is in."

        include FindsProject

        argument :model_id, ::Types::GlobalIDType[::Ml::Model],
          required: true,
          description: 'Global ID of the model the version belongs to.'

        argument :version, GraphQL::Types::String,
          required: false,
          description: 'Model version.'

        argument :description, GraphQL::Types::String,
          required: false,
          description: 'Description of the model version.'

        argument :candidate_id, ::Types::GlobalIDType[::Ml::Candidate],
          required: false,
          description: 'Global ID of a candidate to promote optionally.'

        field :model_version,
          Types::Ml::ModelVersionType,
          null: true,
          description: 'Model after mutation.'

        def resolve(**args)
          project = authorized_find!(args[:project_path])
          model = ::Ml::Model.by_project_id_and_id(project.id, args[:model_id].model_id)

          return { errors: ['Model not found'] } unless model

          result = ::Ml::CreateModelVersionService.new(model,
            {
              version: args[:version],
              description: args[:description],
              candidate_id: args[:candidate_id],
              user: current_user
            }
          ).execute

          {
            model_version: result.payload[:model_version],
            errors: result.message
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/model_versions/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module ModelVersions
      class Delete < BaseMutation
        graphql_name 'MlModelVersionDelete'

        authorize :write_model_registry

        argument :id, ::Types::GlobalIDType[::Ml::ModelVersion],
          required: true,
          description: 'Global ID of the model version to be deleted.'

        field :model_version, ::Types::Ml::ModelVersionType,
          description: 'Deleted model version.', null: true

        def resolve(**args)
          model_version = ::Ml::ModelVersion.find_by_id(args[:id].model_id)

          return { errors: [_('Model version not found')] } unless model_version

          authorize!(model_version.project)

          result = ::Ml::DestroyModelVersionService.new(model_version, current_user).execute

          {
            model_version: result.payload[:model_version],
            errors: result.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/ml/model_versions/edit.rb =====
# frozen_string_literal: true

module Mutations
  module Ml
    module ModelVersions
      class Edit < BaseMutation
        graphql_name 'MlModelVersionEdit'
        include FindsProject

        authorize :write_model_registry

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: "Project the model to mutate is in."

        argument :model_id, ::Types::GlobalIDType[::Ml::Model],
          required: true,
          description: 'Global ID of the model the version belongs to.'

        argument :version, GraphQL::Types::String,
          required: true,
          description: 'Model version.'

        argument :description, GraphQL::Types::String,
          required: true,
          description: 'Description of the model version.'

        field :model_version,
          Types::Ml::ModelVersionType,
          null: true,
          description: 'Model after mutation.'

        def resolve(**args)
          project = authorized_find!(args[:project_path])
          model = ::Ml::Model.by_project_id_and_id(project.id, args[:model_id].model_id)

          return { errors: ['Model not found'] } unless model

          service_response = ::Ml::ModelVersions::UpdateModelVersionService.new(project, model.name, args[:version],
            args[:description]).execute

          if service_response.success?
            {
              model_version: service_response.payload,
              errors: []
            }
          else
            {
              model_version: nil,
              errors: service_response.errors
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/namespace/package_settings/update.rb =====
# frozen_string_literal: true

module Mutations
  module Namespace
    module PackageSettings
      class Update < Mutations::BaseMutation
        graphql_name 'UpdateNamespacePackageSettings'

        include Mutations::ResolvesNamespace

        description 'These settings can be adjusted only by the group Owner.'

        authorize :admin_package

        argument :namespace_path,
          GraphQL::Types::ID,
          required: true,
          description: 'Namespace path where the namespace package setting is located.'

        argument :maven_duplicates_allowed,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :maven_duplicates_allowed)

        argument :maven_duplicate_exception_regex,
          Types::UntrustedRegexp,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :maven_duplicate_exception_regex)

        argument :generic_duplicates_allowed,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :generic_duplicates_allowed)

        argument :generic_duplicate_exception_regex,
          Types::UntrustedRegexp,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :generic_duplicate_exception_regex)

        argument :nuget_duplicates_allowed,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :nuget_duplicates_allowed)

        argument :nuget_duplicate_exception_regex,
          Types::UntrustedRegexp,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :nuget_duplicate_exception_regex)

        argument :terraform_module_duplicates_allowed,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(
            Types::Namespace::PackageSettingsType,
            :terraform_module_duplicates_allowed
          )

        argument :terraform_module_duplicate_exception_regex,
          Types::UntrustedRegexp,
          required: false,
          description: copy_field_description(
            Types::Namespace::PackageSettingsType,
            :terraform_module_duplicate_exception_regex
          )

        argument :maven_package_requests_forwarding,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :maven_package_requests_forwarding)

        argument :npm_package_requests_forwarding,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :npm_package_requests_forwarding)

        argument :pypi_package_requests_forwarding,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :pypi_package_requests_forwarding)

        argument :lock_maven_package_requests_forwarding,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(
            Types::Namespace::PackageSettingsType,
            :lock_maven_package_requests_forwarding
          )

        argument :lock_npm_package_requests_forwarding,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(
            Types::Namespace::PackageSettingsType,
            :lock_npm_package_requests_forwarding
          )

        argument :lock_pypi_package_requests_forwarding,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(
            Types::Namespace::PackageSettingsType,
            :lock_pypi_package_requests_forwarding
          )

        argument :nuget_symbol_server_enabled,
          GraphQL::Types::Boolean,
          required: false,
          description: copy_field_description(Types::Namespace::PackageSettingsType, :nuget_symbol_server_enabled)

        field :package_settings,
          Types::Namespace::PackageSettingsType,
          null: true,
          description: 'Namespace package setting after mutation.'

        def resolve(namespace_path:, **args)
          namespace = authorized_find!(namespace_path: namespace_path)

          result = ::Namespaces::PackageSettings::UpdateService
            .new(container: namespace, current_user: current_user, params: args)
            .execute

          {
            package_settings: result.payload[:package_settings],
            errors: result.errors
          }
        end

        private

        def find_object(namespace_path:)
          resolve_namespace(full_path: namespace_path)
        end
      end
    end
  end
end

Mutations::Namespace::PackageSettings::Update.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/namespaces/regenerate_new_work_item_email_address.rb =====
# frozen_string_literal: true

module Mutations
  module Namespaces
    class RegenerateNewWorkItemEmailAddress < BaseMutation
      graphql_name 'NamespacesRegenerateNewWorkItemEmailAddress'
      include ResolvesNamespace

      argument :full_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the namespace to regenerate the new work item email address for.'

      field :namespace,
        Types::NamespaceType,
        null: true,
        description: 'Namespace after regenerating the new work item email address.'

      authorize :read_namespace

      def resolve(full_path:)
        namespace = authorized_find!(full_path)

        unless namespace.is_a?(::Namespaces::ProjectNamespace)
          return { namespace: nil, errors: [_('Work item creation via email is only supported for projects')] }
        end

        unless Gitlab::Email::IncomingEmail.supports_work_item_creation?
          return { namespace: nil, errors: [_('Work item creation via email is not supported')] }
        end

        return { namespace: namespace, errors: [] } if current_user.reset_incoming_email_token!

        { namespace: nil, errors: [_('Failed to regenerate new work item email address')] }
      end

      private

      def find_object(full_path)
        resolve_namespace(full_path: full_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/abuse_report/create.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module AbuseReport
      class Create < BaseMutation
        graphql_name 'CreateAbuseReportNote'
        description "Creates an abuse report Note."

        authorize :create_note

        field :note,
          Types::Notes::AbuseReport::NoteType,
          null: true, description: 'Abuse report note after mutation.'

        argument :abuse_report_id, Types::GlobalIDType[::AbuseReport],
          required: true, description: 'ID of the abuse report.'
        argument :body,
          GraphQL::Types::String,
          required: true,
          description: copy_field_description(Types::Notes::NoteType, :body)
        argument :discussion_id,
          ::Types::GlobalIDType[::Discussion],
          required: false,
          description: 'Global ID of the abuse report discussion the note is in reply to.'

        def resolve(args)
          raise_resource_not_available_error! unless Feature.enabled?(:abuse_report_notes, current_user)

          note = ::Notes::AbuseReport::CreateService.new(current_user, create_note_params(args)).execute

          {
            note: (note if note.persisted?),
            errors: errors_on_object(note)
          }
        end

        private

        def create_note_params(args)
          abuse_report = authorized_find!(id: args[:abuse_report_id])
          discussion_id = nil

          if args[:discussion_id]
            discussion = GitlabSchema.find_by_gid(args[:discussion_id])

            discussion_id = discussion.id
          end

          {
            abuse_report: abuse_report,
            note: args[:body],
            in_reply_to_discussion_id: discussion_id
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/abuse_report/update.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module AbuseReport
      class Update < BaseMutation
        graphql_name 'UpdateAbuseReportNote'
        description "Updates an abuse report Note."

        authorize :update_note

        field :note,
          Types::Notes::AbuseReport::NoteType,
          null: false, description: 'Abuse report note after mutation.'

        argument :id,
          ::Types::GlobalIDType[::AntiAbuse::Reports::Note],
          required: true,
          description: 'Global ID of the note to update.'

        argument :body,
          GraphQL::Types::String,
          required: true,
          description: copy_field_description(Types::Notes::NoteType, :body)

        def resolve(args)
          raise_resource_not_available_error! unless Feature.enabled?(:abuse_report_notes, current_user)

          note = authorized_find!(id: args[:id])

          response = ::Notes::AbuseReport::UpdateService.new(current_user, { note: args[:body] })
            .execute(note)

          {
            note: note,
            errors: response.error? ? response.message : []
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/base.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    class Base < BaseMutation
      QUICK_ACTION_ONLY_WARNING = <<~NB
        If the body of the Note contains only quick actions,
        the Note will be destroyed during an update, and no Note will be
        returned.
      NB

      field :note,
        Types::Notes::NoteType,
        null: true, scopes: [:api, :ai_workflows],
        description: 'Note after mutation.'

      field :quick_actions_status,
        Types::Notes::QuickActionsStatusType,
        null: true,
        description: 'Status of quick actions after mutation.',
        skip_type_authorization: [:read_note]
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/convert_to_thread.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    class ConvertToThread < Mutations::Notes::Base
      graphql_name 'NoteConvertToThread'
      description 'Convert a standard comment to a resolvable thread.'

      # Permissions are more lenient for converting to a thread because we do not
      # change the note body. Any user that can resolve notes can convert the note
      # to a thread.
      authorize :resolve_note

      argument :id,
        Types::GlobalIDType[Note],
        loads: Types::Notes::NoteType,
        as: :note,
        required: true,
        description: 'Global ID of the Note to convert.'

      def resolve(note:)
        authorize!(note)

        discussion = note.to_discussion

        unless discussion.can_convert_to_discussion?
          raise Gitlab::Graphql::Errors::ArgumentError, 'Note cannot be converted to a resolvable thread'
        end

        discussion = discussion.convert_to_discussion!

        if discussion.save
          { note: discussion.first_note, errors: [] }
        else
          { errors: errors_on_object(discussion.first_note) }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/create/base.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Create
      # This is a Base class for the Note creation Mutations and is not
      # mounted as a GraphQL mutation itself.
      class Base < Mutations::Notes::Base
        authorize :create_note

        argument :noteable_id,
          ::Types::GlobalIDType[::Noteable],
          required: true,
          description: 'Global ID of the resource to add a note to.'

        argument :body,
          GraphQL::Types::String,
          required: true,
          description: copy_field_description(Types::Notes::NoteType, :body)

        argument :internal,
          GraphQL::Types::Boolean,
          required: false,
          description: 'Internal flag for a note. Default is false.'

        def resolve(args)
          noteable = authorized_find!(id: args[:noteable_id])
          verify_rate_limit!(current_user)

          note = ::Notes::CreateService.new(
            noteable.project,
            current_user,
            create_note_params(noteable, args)
          ).execute

          data = {
            note: (note if note.persisted?),
            errors: errors_on_object(note)
          }

          data.tap do |payload|
            payload[:quick_actions_status] = note.quick_actions_status.to_h if note.quick_actions_status
          end
        end

        private

        def create_note_params(noteable, args)
          {
            noteable: noteable,
            note: args[:body],
            internal: args[:internal]
          }
        end

        def verify_rate_limit!(current_user)
          return unless rate_limit_throttled?

          raise_resource_not_available_error! 'This endpoint has been requested too many times. Try again later.'
        end

        def rate_limit_throttled?
          rate_limiter = ::Gitlab::ApplicationRateLimiter
          allowlist = Gitlab::CurrentSettings.current_application_settings.notes_create_limit_allowlist

          rate_limiter.throttled?(:notes_create, scope: [current_user], users_allowlist: allowlist)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/create/diff_note.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Create
      class DiffNote < Base
        graphql_name 'CreateDiffNote'

        argument :position,
          Types::Notes::DiffPositionInputType,
          required: true,
          description: copy_field_description(Types::Notes::NoteType, :position)

        def ready?(**args)
          # As both arguments are optional, validate here that one of the
          # arguments are present.
          #
          # This may be able to be done using InputUnions in the future
          # if this RFC is merged:
          # https://github.com/graphql/graphql-spec/blob/master/rfcs/InputUnion.md

          if args[:position].to_hash.values_at(:old_line, :new_line).compact.blank?
            raise Gitlab::Graphql::Errors::ArgumentError,
              'position oldLine or newLine arguments are required'
          end

          super
        end

        private

        def create_note_params(noteable, args)
          super.merge({
            type: 'DiffNote',
            position: position(noteable, args),
            merge_request_diff_head_sha: args[:position][:head_sha]
          })
        end

        def position(noteable, args)
          position = args[:position].to_h
          position[:position_type] = 'text'
          position.merge!(position[:paths].to_h)

          Gitlab::Diff::Position.new(position)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/create/discussion.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Create
      class Discussion < Base
        graphql_name 'CreateDiscussion'

        private

        def create_note_params(noteable, args)
          super.merge({ type: 'DiscussionNote' })
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/create/image_diff_note.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Create
      class ImageDiffNote < Base
        graphql_name 'CreateImageDiffNote'

        argument :position,
          Types::Notes::DiffImagePositionInputType,
          required: true,
          description: copy_field_description(Types::Notes::NoteType, :position)

        private

        def create_note_params(noteable, args)
          super.merge({
            type: 'DiffNote',
            position: position(noteable, args)
          })
        end

        def position(noteable, args)
          position = args[:position].to_h
          position[:position_type] = 'image'
          position.merge!(position[:paths].to_h)

          Gitlab::Diff::Position.new(position)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/create/note.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Create
      class Note < Base
        graphql_name 'CreateNote'
        description "Creates a Note.\n#{QUICK_ACTION_ONLY_WARNING}"

        def self.authorization_scopes
          super + [:ai_workflows]
        end

        argument :discussion_id,
          ::Types::GlobalIDType[::Discussion],
          required: false,
          description: 'Global ID of the discussion the note is in reply to.'

        argument :merge_request_diff_head_sha,
          GraphQL::Types::String,
          required: false,
          description: 'SHA of the head commit which is used to ensure that ' \
            'the merge request has not been updated since the request was sent.'

        private

        def create_note_params(noteable, args)
          discussion_id = nil

          if gid = args[:discussion_id]
            discussion_id = ::GitlabSchema.parse_gid(gid, expected_type: ::Discussion).model_id
            discussion = noteable.notes.find_discussion(discussion_id)

            authorize_discussion!(discussion)
          end

          super.merge({
            in_reply_to_discussion_id: discussion_id,
            merge_request_diff_head_sha: args[:merge_request_diff_head_sha]
          })
        end

        def authorize_discussion!(discussion)
          unless Ability.allowed?(current_user, :read_note, discussion, scope: :user)
            error_msg = <<~ERR.squish
              The discussion does not exist or you don't have permission to perform this action
            ERR

            raise_resource_not_available_error! error_msg
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    class Destroy < Base
      graphql_name 'DestroyNote'

      authorize :admin_note

      argument :id,
        ::Types::GlobalIDType[::Note],
        required: true,
        description: 'Global ID of the note to destroy.'

      def resolve(id:)
        note = authorized_find!(id: id)

        ::Notes::DestroyService.new(note.project, current_user).execute(note)

        {
          errors: []
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/reposition_image_diff_note.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    # This mutation differs from the update note mutations as it checks the
    # `reposition_note` permission, and doesn't allow updating a note's `body`.
    class RepositionImageDiffNote < Mutations::Notes::Base
      graphql_name 'RepositionImageDiffNote'

      description 'Repositions a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`)'

      authorize :reposition_note

      argument :id,
        Types::GlobalIDType[DiffNote],
        loads: Types::Notes::NoteType,
        as: :note,
        required: true,
        description: 'Global ID of the DiffNote to update.'

      argument :position,
        Types::Notes::UpdateDiffImagePositionInputType,
        required: true,
        description: copy_field_description(Types::Notes::NoteType, :position)

      def resolve(note:, position:)
        authorize!(note)

        position = position.to_h.compact
        pre_update_checks!(note, position)

        updated_note = ::Notes::UpdateService.new(
          note.project,
          current_user,
          note_params(note.position, position)
        ).execute(note)

        {
          note: updated_note.reset,
          errors: errors_on_object(updated_note)
        }
      end

      private

      # An ImageDiffNote does not exist as a class itself, but is instead
      # just a `DiffNote` with a particular kind of `Gitlab::Diff::Position`.
      # In addition to accepting a `DiffNote` Global ID we also need to
      # perform this check.
      def pre_update_checks!(note, _position)
        raise_resource_not_available_error! 'Resource is not an ImageDiffNote' unless note.position&.on_image?
      end

      def note_params(old_position, new_position)
        position = old_position.to_h.merge(new_position)

        {
          position: Gitlab::Diff::Position.new(position)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/update/base.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Update
      # This is a Base class for the Note update mutations and is not
      # mounted as a GraphQL mutation itself.
      class Base < Mutations::Notes::Base
        authorize :admin_note

        argument :id,
          ::Types::GlobalIDType[::Note],
          required: true,
          description: 'Global ID of the note to update.'

        def resolve(args)
          note = authorized_find!(id: args[:id])

          pre_update_checks!(note, args)

          updated_note = ::Notes::UpdateService.new(
            note.project,
            current_user,
            note_params(note, args)
          ).execute(note)

          {
            note: updated_note.destroyed? ? nil : updated_note.reset,
            errors: updated_note.destroyed? ? [] : errors_on_object(updated_note),
            quick_actions_status: updated_note.destroyed? ? nil : updated_note.quick_actions_status&.to_h
          }
        end

        private

        def pre_update_checks!(_note, _args)
          raise NotImplementedError
        end

        def note_params(_note, args)
          { note: args[:body], confidential: args[:confidential] }.compact
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/update/image_diff_note.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Update
      class ImageDiffNote < Mutations::Notes::Update::Base
        graphql_name 'UpdateImageDiffNote'
        description <<~DESC
          Updates a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`).
          #{QUICK_ACTION_ONLY_WARNING}
        DESC

        argument :body,
          GraphQL::Types::String,
          required: false,
          description: copy_field_description(Types::Notes::NoteType, :body)

        argument :position,
          Types::Notes::UpdateDiffImagePositionInputType,
          required: false,
          description: copy_field_description(Types::Notes::NoteType, :position)

        def ready?(**args)
          # As both arguments are optional, validate here that one of the
          # arguments are present.
          #
          # This may be able to be done using InputUnions in the future
          # if this RFC is merged:
          # https://github.com/graphql/graphql-spec/blob/master/rfcs/InputUnion.md
          if args.values_at(:body, :position).compact.blank?
            raise Gitlab::Graphql::Errors::ArgumentError,
              'body or position arguments are required'
          end

          super
        end

        private

        def pre_update_checks!(note, _args)
          return if note.is_a?(DiffNote) && note.position.on_image?

          raise_resource_not_available_error! 'Resource is not an ImageDiffNote'
        end

        def note_params(note, args)
          super.merge(
            position: position_params(note, args)
          ).compact
        end

        def position_params(note, args)
          return unless args[:position]

          original_position = note.position.to_h

          Gitlab::Diff::Position.new(original_position.merge(args[:position].to_h))
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/notes/update/note.rb =====
# frozen_string_literal: true

module Mutations
  module Notes
    module Update
      class Note < Mutations::Notes::Update::Base
        graphql_name 'UpdateNote'
        description "Updates a Note.\n#{QUICK_ACTION_ONLY_WARNING}"

        def self.authorization_scopes
          super + [:ai_workflows]
        end

        argument :body,
          GraphQL::Types::String,
          required: false,
          description: copy_field_description(Types::Notes::NoteType, :body)

        private

        def pre_update_checks!(_note, _args)
          # no-op
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/organizations/base.rb =====
# frozen_string_literal: true

module Mutations
  module Organizations
    class Base < BaseMutation
      field :organization,
        ::Types::Organizations::OrganizationType,
        null: true,
        description: 'Organization after mutation.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description of the organization.'

      argument :avatar, ApolloUploadServer::Upload,
        required: false,
        description: 'Avatar for the organization.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/organizations/create.rb =====
# frozen_string_literal: true

module Mutations
  module Organizations
    class Create < Base
      graphql_name 'OrganizationCreate'

      authorize :create_organization

      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Name for the organization.'

      argument :path, GraphQL::Types::String,
        required: true,
        description: 'Path for the organization.'

      def resolve(args)
        authorize!(:global)

        result = ::Organizations::CreateService.new(
          current_user: current_user,
          params: args
        ).execute

        { organization: result.payload[:organization], errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/organizations/organization_users/base.rb =====
# frozen_string_literal: true

module Mutations
  module Organizations
    module OrganizationUsers
      # rubocop:disable GraphQL/GraphqlName -- This is a base mutation so name is not needed here
      class Base < BaseMutation
        field :organization_user,
          ::Types::Organizations::OrganizationUserType,
          null: true,
          description: 'Organization user after mutation.',
          experiment: { milestone: '17.5' }

        argument :access_level,
          ::Types::Organizations::OrganizationUserAccessLevelEnum,
          required: true,
          description: 'Access level to update the organization user to.'
      end
      # rubocop:enable GraphQL/GraphqlName
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/organizations/organization_users/update.rb =====
# frozen_string_literal: true

module Mutations
  module Organizations
    module OrganizationUsers
      class Update < Base
        graphql_name 'OrganizationUserUpdate'

        authorize :admin_organization

        argument :id,
          Types::GlobalIDType[::Organizations::OrganizationUser],
          required: true,
          description: 'ID of the organization user to mutate.'

        def resolve(id:, **args)
          organization_user = authorized_find!(id: id)

          result = ::Organizations::OrganizationUsers::UpdateService.new(
            organization_user,
            current_user: current_user,
            params: args
          ).execute

          { organization_user: result.payload[:organization_user], errors: result.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/organizations/update.rb =====
# frozen_string_literal: true

module Mutations
  module Organizations
    class Update < Base
      graphql_name 'OrganizationUpdate'

      authorize :admin_organization

      argument :id,
        Types::GlobalIDType[::Organizations::Organization],
        required: true,
        description: 'ID of the organization to mutate.'

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Name for the organization.'

      argument :path, GraphQL::Types::String,
        required: false,
        description: 'Path for the organization.'

      def resolve(id:, **args)
        organization = authorized_find!(id: id)

        result = ::Organizations::UpdateService.new(
          organization,
          current_user: current_user,
          params: args
        ).execute

        { organization: result.payload[:organization], errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/bulk_destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    class BulkDestroy < ::Mutations::BaseMutation
      graphql_name 'DestroyPackages'

      MAX_PACKAGES = 100
      TOO_MANY_IDS_ERROR = "Cannot delete more than #{MAX_PACKAGES} packages"

      argument :ids,
        [::Types::GlobalIDType[::Packages::Package]],
        required: true,
        description: "Global IDs of the Packages. Max #{MAX_PACKAGES}"

      def resolve(ids:)
        raise_resource_not_available_error!(TOO_MANY_IDS_ERROR) if ids.size > MAX_PACKAGES

        model_ids = ids.map(&:model_id)

        service = ::Packages::MarkPackagesForDestructionService.new(
          packages: packages_from(model_ids),
          current_user: current_user
        )
        result = service.execute

        raise_resource_not_available_error! if result.reason == :unauthorized

        errors = result.error? ? Array.wrap(result[:message]) : []

        { errors: errors }
      end

      private

      def packages_from(ids)
        ::Packages::Package.displayable
                           .id_in(ids)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/cleanup/policy/update.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    module Cleanup
      module Policy
        class Update < Mutations::BaseMutation
          graphql_name 'UpdatePackagesCleanupPolicy'

          include FindsProject

          authorize :admin_package

          argument :project_path,
            GraphQL::Types::ID,
            required: true,
            description: 'Project path where the packages cleanup policy is located.'

          argument :keep_n_duplicated_package_files,
            Types::Packages::Cleanup::KeepDuplicatedPackageFilesEnum,
            required: false,
            description: copy_field_description(
              Types::Packages::Cleanup::PolicyType,
              :keep_n_duplicated_package_files
            )

          field :packages_cleanup_policy,
            Types::Packages::Cleanup::PolicyType,
            null: true,
            description: 'Packages cleanup policy after mutation.'

          def resolve(project_path:, **args)
            project = authorized_find!(project_path)

            result = ::Packages::Cleanup::UpdatePolicyService
              .new(project: project, current_user: current_user, params: args)
              .execute

            {
              packages_cleanup_policy: result.payload[:packages_cleanup_policy],
              errors: result.errors
            }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/destroy_file.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    class DestroyFile < ::Mutations::BaseMutation
      graphql_name 'DestroyPackageFile'

      authorize :destroy_package

      argument :id,
        ::Types::GlobalIDType[::Packages::PackageFile],
        required: true,
        description: 'ID of the Package file.'

      def resolve(id:)
        package_file = authorized_find!(id: id)

        return { errors: [] } if package_file.update(status: :pending_destruction)

        { errors: package_file.errors.full_messages }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/destroy_files.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    class DestroyFiles < ::Mutations::BaseMutation
      graphql_name 'DestroyPackageFiles'

      include FindsProject

      MAXIMUM_FILES = 100

      authorize :destroy_package

      argument :project_path,
        GraphQL::Types::ID,
        required: true,
        description: 'Project path where the packages cleanup policy is located.'

      argument :ids,
        [::Types::GlobalIDType[::Packages::PackageFile]],
        required: true,
        description: 'IDs of the Package file.'

      def resolve(project_path:, ids:)
        project = authorized_find!(project_path)
        raise_resource_not_available_error! "Cannot delete more than #{MAXIMUM_FILES} files" if ids.size > MAXIMUM_FILES

        package_files = ::Packages::PackageFile.id_in(parse_gids(ids))

        ensure_file_access!(project, package_files)

        result = ::Packages::MarkPackageFilesForDestructionService.new(package_files).execute

        errors = result.error? ? Array.wrap(result[:message]) : []

        { errors: errors }
      end

      private

      def ensure_file_access!(project, package_files)
        project_ids = package_files.map(&:project_id).uniq

        unless project_ids.size == 1 && project_ids.include?(project.id)
          raise_resource_not_available_error! 'All files must be in the requested project'
        end
      end

      def parse_gids(gids)
        GitlabSchema.parse_gids(gids, expected_type: ::Packages::PackageFile).map(&:model_id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    class Destroy < ::Mutations::BaseMutation
      graphql_name 'DestroyPackage'

      authorize :destroy_package

      argument :id,
        ::Types::GlobalIDType[::Packages::Package],
        required: true,
        description: 'ID of the Package.'

      def resolve(id:)
        package = authorized_find!(id: id)

        result = ::Packages::MarkPackageForDestructionService.new(
          container: package,
          current_user: current_user
        ).execute

        errors = result.error? ? Array.wrap(result[:message]) : []

        {
          errors: errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/protection/rule/create.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    module Protection
      module Rule
        class Create < ::Mutations::BaseMutation
          graphql_name 'CreatePackagesProtectionRule'
          description 'Creates a protection rule to restrict access to project packages.'

          include FindsProject

          authorize :admin_package

          argument :project_path,
            GraphQL::Types::ID,
            required: true,
            description: 'Full path of the project where a protection rule is located.'

          argument :package_name_pattern,
            GraphQL::Types::String,
            required: true,
            description: copy_field_description(Types::Packages::Protection::RuleType, :package_name_pattern)

          argument :package_type,
            Types::Packages::Protection::RulePackageTypeEnum,
            required: true,
            description: copy_field_description(Types::Packages::Protection::RuleType, :package_type)

          argument :minimum_access_level_for_delete,
            Types::Packages::Protection::RuleAccessLevelForDeleteEnum,
            required: false,
            experiment: { milestone: '17.10' },
            description: copy_field_description(Types::Packages::Protection::RuleType, :minimum_access_level_for_delete)

          argument :minimum_access_level_for_push,
            Types::Packages::Protection::RuleAccessLevelEnum,
            required: false,
            description: copy_field_description(Types::Packages::Protection::RuleType, :minimum_access_level_for_push)

          field :package_protection_rule,
            Types::Packages::Protection::RuleType,
            null: true,
            description: 'Packages protection rule after mutation.'

          def resolve(project_path:, **kwargs)
            project = authorized_find!(project_path)

            kwargs.except!(:minimum_access_level_for_delete) if Feature.disabled?(:packages_protected_packages_delete,
              project)

            response =
              ::Packages::Protection::CreateRuleService
                .new(project: project, current_user: current_user, params: kwargs)
                .execute

            { package_protection_rule: response.payload[:package_protection_rule], errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/protection/rule/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    module Protection
      module Rule
        class Delete < ::Mutations::BaseMutation
          graphql_name 'DeletePackagesProtectionRule'
          description 'Deletes a protection rule for packages.'

          authorize :admin_package

          argument :id,
            ::Types::GlobalIDType[::Packages::Protection::Rule],
            required: true,
            description: 'Global ID of the package protection rule to delete.'

          field :package_protection_rule,
            Types::Packages::Protection::RuleType,
            null: true,
            description: 'Packages protection rule that was deleted successfully.'

          def resolve(id:, **_kwargs)
            package_protection_rule = authorized_find!(id: id)

            response = ::Packages::Protection::DeleteRuleService.new(package_protection_rule,
              current_user: current_user).execute

            { package_protection_rule: response.payload[:package_protection_rule], errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/packages/protection/rule/update.rb =====
# frozen_string_literal: true

module Mutations
  module Packages
    module Protection
      module Rule
        class Update < ::Mutations::BaseMutation
          graphql_name 'UpdatePackagesProtectionRule'
          description 'Updates a package protection rule to restrict access to project packages. ' \
            'You can prevent users without certain permissions from altering packages.'

          authorize :admin_package

          argument :id,
            ::Types::GlobalIDType[::Packages::Protection::Rule],
            required: true,
            description: 'Global ID of the package protection rule to be updated.'

          argument :package_name_pattern,
            GraphQL::Types::String,
            required: false,
            validates: { allow_blank: false },
            description: copy_field_description(Types::Packages::Protection::RuleType, :package_name_pattern)

          argument :package_type,
            Types::Packages::Protection::RulePackageTypeEnum,
            required: false,
            validates: { allow_blank: false },
            description: copy_field_description(Types::Packages::Protection::RuleType, :package_type)

          argument :minimum_access_level_for_delete,
            Types::Packages::Protection::RuleAccessLevelForDeleteEnum,
            required: false,
            experiment: { milestone: '17.10' },
            description: copy_field_description(Types::Packages::Protection::RuleType, :minimum_access_level_for_delete)

          argument :minimum_access_level_for_push,
            Types::Packages::Protection::RuleAccessLevelEnum,
            required: false,
            description: copy_field_description(Types::Packages::Protection::RuleType, :minimum_access_level_for_push)

          field :package_protection_rule,
            Types::Packages::Protection::RuleType,
            null: true,
            description: 'Packages protection rule after mutation.'

          def resolve(id:, **kwargs)
            package_protection_rule = authorized_find!(id: id)

            kwargs.except!(:minimum_access_level_for_delete) if Feature.disabled?(:packages_protected_packages_delete,
              package_protection_rule.project)

            response = ::Packages::Protection::UpdateRuleService.new(package_protection_rule,
              current_user: current_user, params: kwargs).execute

            { package_protection_rule: response.payload[:package_protection_rule], errors: response.errors }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/pages/base.rb =====
# frozen_string_literal: true

module Mutations
  module Pages
    class Base < BaseMutation
      include FindsProject

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/pages/deployment/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Pages
    module Deployment
      class Delete < BaseMutation
        graphql_name 'DeletePagesDeployment'
        description "Deletes a Pages deployment."

        authorize :update_pages

        argument :id, ::Types::GlobalIDType[::PagesDeployment],
          required: true,
          description: 'ID of the Pages Deployment.'

        field :pages_deployment, Types::PagesDeploymentType,
          null: false,
          description: 'Deleted Pages Deployment.'

        def resolve(id:)
          deployment = authorized_find!(id: id)

          deployment.deactivate

          {
            errors: errors_on_object(deployment),
            pages_deployment: deployment
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/pages/deployment/restore.rb =====
# frozen_string_literal: true

module Mutations
  module Pages
    module Deployment
      class Restore < BaseMutation
        graphql_name 'RestorePagesDeployment'
        description "Restores a Pages deployment that has been scheduled for deletion."

        authorize :update_pages

        argument :id, ::Types::GlobalIDType[::PagesDeployment],
          required: true,
          description: 'ID of the Pages Deployment.'

        field :pages_deployment, Types::PagesDeploymentType,
          null: false,
          description: 'Restored Pages Deployment.'

        def resolve(id:)
          deployment = authorized_find!(id: id)

          deployment.restore

          {
            errors: errors_on_object(deployment),
            pages_deployment: deployment
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/pages/mark_onboarding_complete.rb =====
# frozen_string_literal: true

module Mutations
  module Pages
    class MarkOnboardingComplete < Base
      graphql_name 'PagesMarkOnboardingComplete'

      field :onboarding_complete,
        Boolean,
        null: false,
        description: "Indicates the new onboarding_complete state of the project's Pages metadata."

      authorize :admin_project

      def resolve(project_path:)
        project = authorized_find!(project_path)

        project.mark_pages_onboarding_complete

        {
          onboarding_complete: project.pages_metadatum.onboarding_complete,
          errors: errors_on_object(project)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/pages/set_pages_force_https.rb =====
# frozen_string_literal: true

module Mutations
  module Pages
    class SetPagesForceHttps < Base
      graphql_name 'SetPagesForceHttps'

      argument :value,
        GraphQL::Types::Boolean,
        required: true,
        description: "Indicates user wants to enforce HTTPS on their pages."

      argument :project_path,
        GraphQL::Types::ID,
        required: true,
        description: "Path of the project to set the pages force HTTPS."

      field :project,
        Types::ProjectType,
        null: true,
        description: "Project that was updated."

      authorize :admin_project

      def resolve(project_path:, value:)
        project = authorized_find!(project_path)

        return { project: project, errors: [] } if project.update(pages_https_only: value)

        { project: nil, errors: errors_on_object(project) }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/pages/set_pages_use_unique_domain.rb =====
# frozen_string_literal: true

module Mutations
  module Pages
    class SetPagesUseUniqueDomain < Base
      graphql_name 'SetPagesUseUniqueDomain'

      argument :value, GraphQL::Types::Boolean,
        required: true,
        description: "Indicates user wants to use unique subdomains for their pages."

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: "Path of the project to set the pages to use unique domains."

      field :project, Types::ProjectType,
        null: true,
        description: "Project that was updated."

      authorize :admin_project

      def resolve(project_path:, value:)
        project = authorized_find!(project_path)

        return { project: project, errors: [] } if project.project_setting.update(pages_unique_domain_enabled: value)

        { project: nil, errors: errors_on_object(project) + errors_on_object(project.project_setting) }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/projects/blobs_remove.rb =====
# frozen_string_literal: true

module Mutations
  module Projects
    class BlobsRemove < BaseMutation
      graphql_name 'projectBlobsRemove'

      include FindsProject

      EMPTY_BLOBS_OIDS_ARG = <<~ERROR
        Argument 'blobOids' on InputObject 'projectBlobsRemoveInput' is required. Expected type [String!]!
      ERROR

      authorize :owner_access

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project to replace.'

      argument :blob_oids, [GraphQL::Types::String],
        required: true,
        description: 'List of blob oids.',
        prepare: ->(blob_oids, _ctx) do
          blob_oids.reject!(&:blank?)

          break blob_oids if blob_oids.present?

          raise GraphQL::ExecutionError, EMPTY_BLOBS_OIDS_ARG
        end

      def resolve(project_path:, blob_oids:)
        project = authorized_find!(project_path)

        result = ::Repositories::RewriteHistoryService.new(project, current_user).async_execute(blob_oids: blob_oids)

        return { errors: result.errors } if result.error?

        { errors: [] }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/projects/branch_rules/squash_options/update.rb =====
# frozen_string_literal: true

module Mutations
  module Projects
    module BranchRules
      module SquashOptions
        class Update < BaseMutation
          graphql_name 'BranchRuleSquashOptionUpdate'
          description 'Update a squash option for a branch rule'

          authorize :update_squash_option
          argument :branch_rule_id, ::Types::GlobalIDType[::Projects::BranchRule],
            required: true,
            description: 'Global ID of the branch rule.'

          argument :squash_option, ::Types::Projects::BranchRules::SquashOptionSettingEnum,
            required: true,
            description: 'Squash option after mutation.'

          field :squash_option,
            type: ::Types::Projects::BranchRules::SquashOptionType,
            null: true,
            description: 'Updated squash option after mutation.'

          def resolve(branch_rule_id:, squash_option:)
            branch_rule = authorized_find!(id: branch_rule_id)

            service_response = ::Projects::BranchRules::SquashOptions::UpdateService.new(
              branch_rule,
              squash_option: squash_option,
              current_user: current_user
            ).execute

            {
              squash_option: (service_response.payload if service_response.success?),
              errors: service_response.errors
            }
          end
        end
      end
    end
  end
end

Mutations::Projects::BranchRules::SquashOptions::Update.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/projects/star.rb =====
# frozen_string_literal: true

module Mutations
  module Projects
    class Star < BaseMutation
      graphql_name 'StarProject'

      authorize :read_project

      argument :project_id,
        ::Types::GlobalIDType[::Project],
        required: true,
        description: 'Full path of the project to star or unstar.'

      argument :starred,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Indicates whether to star or unstar the project.'

      field :count,
        GraphQL::Types::String,
        null: false,
        description: 'Number of stars for the project.'

      def resolve(project_id:, starred:)
        project = authorized_find!(id: project_id)

        if current_user.starred?(project) != starred
          current_user.toggle_star(project)
          project.reset
        end

        {
          count: project.star_count
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/projects/sync_fork.rb =====
# frozen_string_literal: true

module Mutations
  module Projects
    class SyncFork < BaseMutation
      graphql_name 'ProjectSyncFork'

      include FindsProject

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project to initialize.'

      argument :target_branch, GraphQL::Types::String,
        required: true,
        description: 'Ref of the fork to fetch into.'

      field :details, Types::Projects::ForkDetailsType,
        null: true,
        description: 'Updated fork details.'

      def resolve(project_path:, target_branch:)
        project = authorized_find!(project_path, target_branch)

        return respond(nil, ['Target branch does not exist']) unless project.repository.branch_exists?(target_branch)

        details_resolver = Resolvers::Projects::ForkDetailsResolver.new(object: project, context: context, field: nil)
        details = details_resolver.resolve(ref: target_branch)

        return respond(nil, ['This branch of this project cannot be updated from the upstream']) unless details

        enqueue_sync_fork(project, target_branch, details)
      end

      def enqueue_sync_fork(project, target_branch, details)
        return respond(details, []) if details.counts[:behind] == 0

        if details.has_conflicts?
          return respond(details, ['The synchronization cannot happen due to the merge conflict'])
        end

        return respond(details, ['This service has been called too many times.']) if rate_limit_throttled?(project)
        return respond(details, ['Another fork sync is already in progress']) unless details.exclusive_lease.try_obtain

        ::Projects::Forks::SyncWorker.perform_async(project.id, current_user.id, target_branch) # rubocop:disable CodeReuse/Worker

        respond(details, [])
      end

      def rate_limit_throttled?(project)
        Gitlab::ApplicationRateLimiter.throttled?(:project_fork_sync, scope: [project, current_user])
      end

      def respond(details, errors)
        { details: details, errors: errors }
      end

      def authorized_find!(project_path, target_branch)
        project = find_object(project_path)

        return project if ::Gitlab::UserAccess.new(current_user, container: project).can_push_to_branch?(target_branch)

        raise_resource_not_available_error!
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/projects/text_replace.rb =====
# frozen_string_literal: true

module Mutations
  module Projects
    class TextReplace < BaseMutation
      graphql_name 'projectTextReplace'

      include FindsProject

      UNSUPPORTED_REPLACEMENT_PREFIX = %r{(?:regex|glob):}
      SUPPORTED_REPLACEMENT_PREFIX = %r{literal:}
      EMPTY_REPLACEMENTS_ARG_ERROR = <<~ERROR
        Argument 'replacements' on InputObject 'projectTextReplaceInput' is required. Expected type [String!]!
      ERROR
      UNSUPPORTED_REPLACEMENTS_ARG_ERROR = <<~ERROR
        Argument 'replacements' on InputObject 'projectTextReplaceInput' does not support 'regex:' or 'glob:' values.
      ERROR

      authorize :owner_access

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project to replace.'

      argument :replacements, [GraphQL::Types::String],
        required: true,
        description: 'List of text patterns to replace project-wide.',
        prepare: ->(replacements, _ctx) do
          replacements.reject!(&:blank?)

          raise(GraphQL::ExecutionError, EMPTY_REPLACEMENTS_ARG_ERROR) if replacements.empty?

          if replacements.any? { |r| r.starts_with?(UNSUPPORTED_REPLACEMENT_PREFIX) }
            raise(GraphQL::ExecutionError, UNSUPPORTED_REPLACEMENTS_ARG_ERROR)
          end

          replacements.map { |r| r.starts_with?(SUPPORTED_REPLACEMENT_PREFIX) ? r : "literal:#{r}" }
        end

      def resolve(project_path:, replacements:)
        project = authorized_find!(project_path)

        result = ::Repositories::RewriteHistoryService.new(project, current_user)
                   .async_execute(redactions: replacements)

        return { errors: result.errors } if result.error?

        { errors: [] }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/release_asset_links/create.rb =====
# frozen_string_literal: true

module Mutations
  module ReleaseAssetLinks
    class Create < BaseMutation
      graphql_name 'ReleaseAssetLinkCreate'

      include FindsProject
      include SafeFormatHelper
      include Types::ReleaseAssetLinkSharedInputArguments

      authorize :create_release

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project the asset link is associated with.'

      argument :tag_name, GraphQL::Types::String,
        required: true, as: :tag,
        description: "Name of the associated release's tag."

      field :link,
        Types::ReleaseAssetLinkType,
        null: true,
        description: 'Asset link after mutation.'

      def resolve(project_path:, tag:, **link_attrs)
        project = authorized_find!(project_path)
        release = project.releases.find_by_tag(tag)

        if release.nil?
          message = safe_format(_('Release with tag "%{tag}" was not found'), tag: tag)
          return { link: nil, errors: [message] }
        end

        raise_resource_not_available_error! unless Ability.allowed?(current_user, :update_release, release)

        result = ::Releases::Links::CreateService
          .new(release, current_user, link_attrs)
          .execute

        if result.success?
          { link: result.payload[:link], errors: [] }
        else
          { link: nil, errors: result.message }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/release_asset_links/delete.rb =====
# frozen_string_literal: true

module Mutations
  module ReleaseAssetLinks
    class Delete < BaseMutation
      graphql_name 'ReleaseAssetLinkDelete'

      authorize :destroy_release

      ReleaseAssetLinkID = ::Types::GlobalIDType[::Releases::Link]

      argument :id, ReleaseAssetLinkID,
        required: true,
        description: 'ID of the release asset link to delete.'

      field :link,
        Types::ReleaseAssetLinkType,
        null: true,
        description: 'Deleted release asset link.'

      def resolve(id:)
        link = authorized_find!(id: id)

        result = ::Releases::Links::DestroyService
          .new(link.release, current_user)
          .execute(link)

        if result.success?
          { link: result.payload[:link], errors: [] }
        else
          { link: nil, errors: result.message }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/release_asset_links/update.rb =====
# frozen_string_literal: true

module Mutations
  module ReleaseAssetLinks
    class Update < BaseMutation
      graphql_name 'ReleaseAssetLinkUpdate'

      authorize :update_release

      ReleaseAssetLinkID = ::Types::GlobalIDType[::Releases::Link]

      argument :id, ReleaseAssetLinkID,
        required: true,
        description: 'ID of the release asset link to update.'

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Name of the asset link.'

      argument :url, GraphQL::Types::String,
        required: false,
        description: 'URL of the asset link.'

      argument :direct_asset_path, GraphQL::Types::String,
        required: false, as: :filepath,
        description: 'Relative path for a direct asset link.'

      argument :link_type, Types::ReleaseAssetLinkTypeEnum,
        required: false,
        description: 'Type of the asset link.'

      field :link,
        Types::ReleaseAssetLinkType,
        null: true,
        description: 'Asset link after mutation.'

      def ready?(**args)
        if args.key?(:link_type) && args[:link_type].nil?
          raise Gitlab::Graphql::Errors::ArgumentError,
            'if the linkType argument is provided, it cannot be null'
        end

        super
      end

      def resolve(id:, **link_attrs)
        link = authorized_find!(id: id)

        result = ::Releases::Links::UpdateService
          .new(link.release, current_user, link_attrs)
          .execute(link)

        if result.success?
          { link: result.payload[:link], errors: [] }
        else
          { link: nil, errors: result.message }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/releases/base.rb =====
# frozen_string_literal: true

module Mutations
  module Releases
    class Base < BaseMutation
      include FindsProject

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Full path of the project the release is associated with.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/releases/create.rb =====
# frozen_string_literal: true

module Mutations
  module Releases
    class Create < Base
      graphql_name 'ReleaseCreate'

      field :release,
        Types::ReleaseType,
        null: true,
        description: 'Release after mutation.'

      argument :tag_name, GraphQL::Types::String,
        required: true, as: :tag,
        description: 'Name of the tag to associate with the release.'

      argument :tag_message, GraphQL::Types::String,
        required: false,
        description: 'Message to use if creating a new annotated tag.'

      argument :ref, GraphQL::Types::String,
        required: false,
        description: 'Commit SHA or branch name to use if creating a new tag.'

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Name of the release.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description (also known as "release notes") of the release.'

      argument :released_at, Types::TimeType,
        required: false,
        description: 'Date and time for the release. Defaults to the current time. Expected in ISO 8601 format ' \
          '(`2019-03-15T08:00:00Z`). Only provide this field if creating an upcoming or historical release.'

      argument :milestones, [GraphQL::Types::String],
        required: false,
        description: 'Title of each milestone the release is associated with. ' \
          'GitLab Premium customers can specify group milestones.'

      argument :assets, Types::ReleaseAssetsInputType,
        required: false,
        description: 'Assets associated to the release.'

      authorize :create_release

      def resolve(project_path:, assets: nil, **scalars)
        project = authorized_find!(project_path)

        params = {
          **scalars,
          assets: assets.to_h
        }.with_indifferent_access

        result = ::Releases::CreateService.new(project, current_user, params).execute

        if result[:status] == :success
          {
            release: result[:release],
            errors: []
          }
        else
          {
            release: nil,
            errors: [result[:message]]
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/releases/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Releases
    class Delete < Base
      graphql_name 'ReleaseDelete'

      field :release,
        Types::ReleaseType,
        null: true,
        description: 'Deleted release.'

      argument :tag_name, GraphQL::Types::String,
        required: true, as: :tag,
        description: 'Name of the tag associated with the release to delete.'

      authorize :destroy_release

      def resolve(project_path:, tag:)
        project = authorized_find!(project_path)

        params = { tag: tag }.with_indifferent_access

        result = ::Releases::DestroyService.new(project, current_user, params).execute

        if result[:status] == :success
          {
            release: result[:release],
            errors: []
          }
        else
          {
            release: nil,
            errors: [result[:message]]
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/releases/update.rb =====
# frozen_string_literal: true

module Mutations
  module Releases
    class Update < Base
      graphql_name 'ReleaseUpdate'

      field :release,
        Types::ReleaseType,
        null: true,
        description: 'Release after mutation.'

      argument :tag_name, GraphQL::Types::String,
        required: true, as: :tag,
        description: 'Name of the tag associated with the release.'

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Name of the release.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description (release notes) of the release.'

      argument :released_at, Types::TimeType,
        required: false,
        description: 'Release date.'

      argument :milestones, [GraphQL::Types::String],
        required: false,
        description: 'Title of each milestone the release is associated with. ' \
          'GitLab Premium customers can specify group milestones.'

      authorize :update_release

      def ready?(**args)
        if args.key?(:released_at) && args[:released_at].nil?
          raise Gitlab::Graphql::Errors::ArgumentError,
            'if the releasedAt argument is provided, it cannot be null'
        end

        if args.key?(:milestones) && args[:milestones].nil?
          raise Gitlab::Graphql::Errors::ArgumentError,
            'if the milestones argument is provided, it cannot be null'
        end

        super
      end

      def resolve(project_path:, **scalars)
        project = authorized_find!(project_path)

        params = scalars.with_indifferent_access

        result = ::Releases::UpdateService.new(project, current_user, params).execute

        if result[:status] == :success
          {
            release: result[:release],
            errors: []
          }
        else
          {
            release: nil,
            errors: [result[:message]]
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/repositories/branches/create.rb =====
# frozen_string_literal: true

module Mutations
  module Repositories
    module Branches
      class Create < BaseMutation
        graphql_name 'CreateBranch'

        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project full path the branch is associated with.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the branch.'

        argument :ref,
          GraphQL::Types::String,
          required: true,
          description: 'Branch name or commit SHA to create branch from.'

        field :branch,
          Types::BranchType,
          null: true,
          description: 'Branch after mutation.'

        authorize :push_code

        def resolve(project_path:, name:, ref:)
          project = authorized_find!(project_path)

          result = ::Branches::CreateService.new(project, current_user)
                     .execute(name, ref)

          {
            branch: (result[:branch] if result[:status] == :success),
            errors: Array.wrap(result[:message])
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/repositories/branches/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Repositories
    module Branches
      class Delete < BaseMutation
        graphql_name 'BranchDelete'

        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project full path the branch is associated with.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the branch.'

        field :branch,
          Types::BranchType,
          null: true,
          description: 'Branch after mutation.'

        authorize :push_code

        def resolve(project_path:, name:)
          project = authorized_find!(project_path)

          result = ::Branches::DeleteService.new(project, current_user).execute(name)

          {
            branch: (result.payload[:branch] if result.error?),
            errors: result.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/repositories/tags/create.rb =====
# frozen_string_literal: true

module Mutations
  module Repositories
    module Tags
      class Create < BaseMutation
        graphql_name 'TagCreate'

        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project full path the branch is associated with.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the tag.'

        argument :ref,
          GraphQL::Types::String,
          required: true,
          description: 'Tag name or commit SHA to create tag from.'

        argument :message,
          GraphQL::Types::String,
          required: false,
          default_value: '',
          description: 'Tagging message.'

        field :tag,
          Types::Repositories::TagType,
          null: true,
          description: 'Tag after mutation.'

        authorize :admin_tag

        def resolve(project_path:, name:, ref:, message:)
          project = authorized_find!(project_path)

          result = ::Tags::CreateService.new(project, current_user)
                     .execute(name, ref, message)

          {
            tag: (result[:tag] if result[:status] == :success),
            errors: Array.wrap(result[:message])
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/repositories/tags/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Repositories
    module Tags
      class Delete < BaseMutation
        graphql_name 'TagDelete'

        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Project full path the branch is associated with.'

        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the tag.'

        field :tag,
          Types::Repositories::TagType,
          null: true,
          description: 'Tag after mutation.'

        authorize :admin_tag

        def resolve(project_path:, name:)
          project = authorized_find!(project_path)

          result = ::Tags::DestroyService.new(project, current_user)
                     .execute(name)
          {
            tag: nil,
            errors: result[:status] == :success ? [] : Array.wrap(result[:message])
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/saved_replies/base.rb =====
# frozen_string_literal: true

module Mutations
  module SavedReplies
    class Base < BaseMutation
      private

      def present_result(result)
        if result[:status] == :success
          {
            saved_reply: result[:saved_reply],
            errors: []
          }
        else
          {
            saved_reply: nil,
            errors: result[:message]
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/saved_replies/create.rb =====
# frozen_string_literal: true

module Mutations
  module SavedReplies
    class Create < Base
      authorize :create_saved_replies

      argument :name, GraphQL::Types::String,
        required: true,
        description: copy_field_description(::Types::SavedReplyType, :name)

      argument :content, GraphQL::Types::String,
        required: true,
        description: copy_field_description(::Types::SavedReplyType, :content)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/saved_replies/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module SavedReplies
    class Destroy < Base
      authorize :destroy_saved_replies

      def resolve(id:)
        saved_reply = authorized_find!(id: id)
        result = ::SavedReplies::DestroyService.new(saved_reply: saved_reply).execute
        present_result(result)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/saved_replies/update.rb =====
# frozen_string_literal: true

module Mutations
  module SavedReplies
    class Update < Base
      authorize :update_saved_replies

      argument :name, GraphQL::Types::String,
        required: true,
        description: copy_field_description(::Types::SavedReplyType, :name)

      argument :content, GraphQL::Types::String,
        required: true,
        description: copy_field_description(::Types::SavedReplyType, :content)

      def resolve(id:, name:, content:)
        saved_reply = authorized_find!(id: id)
        result = ::SavedReplies::UpdateService.new(saved_reply: saved_reply, name: name, content: content).execute
        present_result(result)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/security/ci_configuration/base_security_analyzer.rb =====
# frozen_string_literal: true

module Mutations
  module Security
    module CiConfiguration
      class BaseSecurityAnalyzer < BaseMutation
        include FindsProject

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full path of the project.'

        field :success_path, GraphQL::Types::String,
          null: true,
          description: 'Redirect path to use when the response is successful.'

        field :branch, GraphQL::Types::String,
          null: true,
          description: 'Branch that has the new/modified `.gitlab-ci.yml` file.'

        authorize :push_code

        def resolve(project_path:, **args)
          project = authorized_find!(project_path)

          result = configure_analyzer(project, **args)
          prepare_response(result)
        end

        private

        def configure_analyzer(project, **args)
          raise NotImplementedError
        end

        def prepare_response(result)
          {
            branch: result.payload[:branch],
            success_path: result.payload[:success_path],
            errors: result.errors
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/security/ci_configuration/configure_sast_iac.rb =====
# frozen_string_literal: true

module Mutations
  module Security
    module CiConfiguration
      class ConfigureSastIac < BaseSecurityAnalyzer
        graphql_name 'ConfigureSastIac'
        description <<~DESC
          Enable SAST IaC for a project in a new or
          modified `.gitlab-ci.yml` file in a new branch. The new
          branch and a URL to create a merge request are a part of the
          response.
        DESC

        def configure_analyzer(project, **_args)
          ::Security::CiConfiguration::SastIacCreateService.new(project, current_user).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/security/ci_configuration/configure_sast.rb =====
# frozen_string_literal: true

module Mutations
  module Security
    module CiConfiguration
      class ConfigureSast < BaseSecurityAnalyzer
        graphql_name 'ConfigureSast'
        description <<~DESC
          Configure SAST for a project by enabling SAST in a new or modified
          `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
          create a Merge Request are a part of the response.
        DESC

        argument :configuration, ::Types::CiConfiguration::Sast::InputType,
          required: true,
          description: 'SAST CI configuration for the project.'

        def configure_analyzer(project, **args)
          ::Security::CiConfiguration::SastCreateService.new(project, current_user, args[:configuration].to_h).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/security/ci_configuration/configure_secret_detection.rb =====
# frozen_string_literal: true

module Mutations
  module Security
    module CiConfiguration
      class ConfigureSecretDetection < BaseSecurityAnalyzer
        graphql_name 'ConfigureSecretDetection'
        description <<~DESC
          Configure Secret Detection for a project by enabling Secret Detection
          in a new or modified `.gitlab-ci.yml` file in a new branch. The new
          branch and a URL to create a Merge Request are a part of the
          response.
        DESC

        def configure_analyzer(project, **_args)
          ::Security::CiConfiguration::SecretDetectionCreateService.new(project, current_user).execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/snippets/base.rb =====
# frozen_string_literal: true

module Mutations
  module Snippets
    class Base < BaseMutation
      field :snippet,
        Types::SnippetType,
        null: true,
        description: 'Snippet after mutation.'

      private

      def authorized_resource?(snippet)
        return false if snippet.nil?

        Ability.allowed?(context[:current_user], ability_for(snippet), snippet)
      end

      def ability_for(snippet)
        :"#{ability_name}_#{snippet.to_ability_name}"
      end

      def ability_name
        raise NotImplementedError
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/snippets/create.rb =====
# frozen_string_literal: true

module Mutations
  module Snippets
    class Create < BaseMutation
      graphql_name 'CreateSnippet'

      include ServiceCompatibility
      include Mutations::SpamProtection
      include Gitlab::InternalEventsTracking

      authorize :create_snippet

      field :snippet,
        Types::SnippetType,
        null: true,
        description: 'Snippet after mutation.'

      argument :title, GraphQL::Types::String,
        required: true,
        description: 'Title of the snippet.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description of the snippet.'

      argument :visibility_level, Types::VisibilityLevelsEnum,
        description: 'Visibility level of the snippet.',
        required: true

      argument :project_path, GraphQL::Types::ID,
        required: false,
        description: 'Full path of the project the snippet is associated with.'

      argument :uploaded_files, [GraphQL::Types::String],
        required: false,
        description: 'Paths to files uploaded in the snippet description.'

      argument :blob_actions, [Types::Snippets::BlobActionInputType],
        description: 'Actions to perform over the snippet repository and blobs.',
        required: false

      def resolve(project_path: nil, **args)
        if project_path.present?
          project = authorized_find!(project_path)
        else
          authorize!(:global)
        end

        process_args_for_params!(args)

        service = ::Snippets::CreateService.new(project: project, current_user: current_user, params: args)
        service_response = service.execute

        # Only when the user is not an api user and the operation was successful
        if !api_user? && service_response.success?
          track_internal_event(
            'g_edit_by_snippet_ide',
            user: current_user,
            project: project
          )
        end

        snippet = service_response.payload[:snippet]
        check_spam_action_response!(snippet)

        {
          snippet: service_response.success? ? snippet : nil,
          errors: errors_on_object(snippet)
        }
      end

      private

      def find_object(full_path)
        Project.find_by_full_path(full_path)
      end

      # process_args_for_params!(args)    -> nil
      #
      # Modifies/adds/deletes mutation resolve args as necessary to be passed as params to service layer.
      def process_args_for_params!(args)
        convert_blob_actions_to_snippet_actions!(args)

        # We need to rename `uploaded_files` into `files` because
        # it's the expected key param
        args[:files] = args.delete(:uploaded_files)
        args[:organization_id] = Current.organization.id
        # Return nil to make it explicit that this method is mutating the args parameter, and that
        # the return value is not relevant and is not to be used.
        nil
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/snippets/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Snippets
    class Destroy < Base
      graphql_name 'DestroySnippet'

      ERROR_MSG = 'Error deleting the snippet'

      argument :id, ::Types::GlobalIDType[::Snippet],
        required: true,
        description: 'Global ID of the snippet to destroy.'

      def resolve(id:)
        snippet = authorized_find!(id: id)

        response = ::Snippets::DestroyService.new(current_user, snippet).execute
        errors = response.success? ? [] : [ERROR_MSG]

        {
          errors: errors
        }
      end

      private

      def ability_name
        "admin"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/snippets/mark_as_spam.rb =====
# frozen_string_literal: true

module Mutations
  module Snippets
    class MarkAsSpam < Base
      graphql_name 'MarkAsSpamSnippet'

      argument :id, ::Types::GlobalIDType[::Snippet],
        required: true,
        description: 'Global ID of the snippet to update.'

      def resolve(id:)
        snippet = authorized_find!(id: id)

        result = mark_as_spam(snippet)
        errors = result ? [] : ['Error with Akismet. Please check the logs for more info.']

        {
          errors: errors
        }
      end

      private

      def mark_as_spam(snippet)
        Spam::AkismetMarkAsSpamService.new(target: snippet).execute
      end

      def authorized_resource?(snippet)
        super && snippet.submittable_as_spam_by?(context[:current_user])
      end

      def ability_name
        "admin"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/snippets/service_compatibility.rb =====
# frozen_string_literal: true

module Mutations
  module Snippets
    # Translates graphql mutation field params to be compatible with those expected by the service layer
    module ServiceCompatibility
      extend ActiveSupport::Concern

      # convert_blob_actions_to_snippet_actions!(args)    -> nil
      #
      # Converts the blob_actions mutation argument into the
      # snippet_actions hash which the service layer expects
      def convert_blob_actions_to_snippet_actions!(args)
        # We need to rename `blob_actions` into `snippet_actions` because
        # it's the expected key param
        args[:snippet_actions] = args.delete(:blob_actions)&.map(&:to_h)

        # Return nil to make it explicit that this method is mutating the args parameter
        nil
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/snippets/update.rb =====
# frozen_string_literal: true

module Mutations
  module Snippets
    class Update < Base
      graphql_name 'UpdateSnippet'

      include ServiceCompatibility
      include Mutations::SpamProtection
      include Gitlab::InternalEventsTracking

      argument :id, ::Types::GlobalIDType[::Snippet],
        required: true,
        description: 'Global ID of the snippet to update.'

      argument :title, GraphQL::Types::String,
        required: false,
        description: 'Title of the snippet.'

      argument :description, GraphQL::Types::String,
        required: false,
        description: 'Description of the snippet.'

      argument :visibility_level, Types::VisibilityLevelsEnum,
        description: 'Visibility level of the snippet.',
        required: false

      argument :blob_actions, [Types::Snippets::BlobActionInputType],
        description: 'Actions to perform over the snippet repository and blobs.',
        required: false

      def resolve(id:, **args)
        snippet = authorized_find!(id: id)

        process_args_for_params!(args)

        service = ::Snippets::UpdateService.new(
          project: snippet.project,
          current_user: current_user,
          params: args,
          perform_spam_check: true
        )
        service_response = service.execute(snippet)

        # TODO: DRY this up - From here down, this is all duplicated with Mutations::Snippets::Create#resolve, except
        # for `snippet.reset`, which is required in order to return the object in its non-dirty, unmodified, database
        # state.
        # See issue here: https://gitlab.com/gitlab-org/gitlab/-/issues/300250.

        # Only when the user is not an api user and the operation was successful
        if !api_user? && service_response.success?
          track_internal_event(
            'g_edit_by_snippet_ide',
            user: current_user,
            project: snippet.project
          )
        end

        snippet = service_response.payload[:snippet]
        check_spam_action_response!(snippet)

        {
          snippet: service_response.success? ? snippet : snippet.reset,
          errors: errors_on_object(snippet)
        }
      end

      private

      # process_args_for_params!(args)    -> nil
      #
      # Modifies/adds/deletes mutation resolve args as necessary to be passed as params to service layer.
      def process_args_for_params!(args)
        convert_blob_actions_to_snippet_actions!(args)

        # Return nil to make it explicit that this method is mutating the args parameter, and that
        # the return value is not relevant and is not to be used.
        nil
      end

      def ability_name
        'update'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/terraform/state/base.rb =====
# frozen_string_literal: true

module Mutations
  module Terraform
    module State
      class Base < BaseMutation
        authorize :admin_terraform_state

        argument :id,
          Types::GlobalIDType[::Terraform::State],
          required: true,
          description: 'Global ID of the Terraform state.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/terraform/state/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Terraform
    module State
      class Delete < Base
        graphql_name 'TerraformStateDelete'

        def resolve(id:)
          state = authorized_find!(id: id)
          response = ::Terraform::States::TriggerDestroyService.new(state, current_user: current_user).execute

          { errors: response.errors }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/terraform/state/lock.rb =====
# frozen_string_literal: true

module Mutations
  module Terraform
    module State
      class Lock < Base
        graphql_name 'TerraformStateLock'

        def resolve(id:)
          state = authorized_find!(id: id)

          if state.locked?
            state.errors.add(:base, 'state is already locked')
          else
            state.update(lock_xid: lock_xid, locked_by_user: current_user, locked_at: Time.current)
          end

          { errors: errors_on_object(state) }
        end

        private

        def lock_xid
          SecureRandom.uuid
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/terraform/state/unlock.rb =====
# frozen_string_literal: true

module Mutations
  module Terraform
    module State
      class Unlock < Base
        graphql_name 'TerraformStateUnlock'

        def resolve(id:)
          state = authorized_find!(id: id)
          state.update(lock_xid: nil, locked_by_user: nil, locked_at: nil)

          { errors: errors_on_object(state) }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/timelogs/base.rb =====
# frozen_string_literal: true

module Mutations
  module Timelogs
    class Base < Mutations::BaseMutation
      field :timelog,
        Types::TimelogType,
        null: true,
        description: 'Timelog.'

      private

      def response(result)
        { timelog: result.payload[:timelog], errors: result.errors }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/timelogs/create.rb =====
# frozen_string_literal: true

module Mutations
  module Timelogs
    class Create < Base
      graphql_name 'TimelogCreate'

      argument :time_spent,
        GraphQL::Types::String,
        required: true,
        description: 'Amount of time spent.'

      argument :spent_at,
        Types::TimeType,
        required: false,
        description: 'Timestamp of when the time was spent. If empty, defaults to current time.'

      argument :summary,
        GraphQL::Types::String,
        required: true,
        description: 'Summary of time spent.'

      argument :issuable_id,
        ::Types::GlobalIDType[::Issuable],
        required: true,
        description: 'Global ID of the issuable (Issue, WorkItem or MergeRequest).'

      authorize :create_timelog

      def resolve(issuable_id:, time_spent:, summary:, **args)
        return { timelog: nil, errors: [_('Time spent must start with a number.')] } unless time_spent.match?(/\A\d/)

        parsed_time_spent = Gitlab::TimeTrackingFormatter.parse(time_spent)
        if parsed_time_spent.nil?
          return { timelog: nil, errors: [_('Time spent must be formatted correctly. For example: 1h 30m.')] }
        end

        issuable = authorized_find!(id: issuable_id)

        spent_at = args[:spent_at].nil? ? DateTime.current : args[:spent_at]

        result = ::Timelogs::CreateService.new(
          issuable, parsed_time_spent, spent_at, summary, current_user
        ).execute

        response(result)
      end

      private

      def find_object(id:)
        GitlabSchema.object_from_id(id, expected_type: [::Issue, ::WorkItem, ::MergeRequest]).sync
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/timelogs/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Timelogs
    class Delete < Base
      graphql_name 'TimelogDelete'

      argument :id,
        ::Types::GlobalIDType[::Timelog],
        required: true,
        description: 'Global ID of the timelog.'

      authorize :admin_timelog

      def resolve(id:)
        timelog = authorized_find!(id: id)
        result = ::Timelogs::DeleteService.new(timelog, current_user).execute

        # Return the result payload, not the loaded timelog, so that it returns null in case of unauthorized access
        response(result)
      end

      private

      def find_object(id:)
        GitlabSchema.object_from_id(id, expected_type: ::Timelog).sync
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/base_many.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    # Base class for bulk todo operations

    class BaseMany < ::Mutations::BaseMutation # rubocop:disable GraphQL/GraphqlName -- Base class needs no name.
      MAX_UPDATE_AMOUNT = 100

      argument :ids,
        [::Types::GlobalIDType[::Todo]],
        required: true,
        description: 'Global IDs of the to-do items to process (a maximum of 100 is supported at once).'

      def resolve(ids:, **kwargs)
        check_update_limit!(amount: ids.size)

        todos = authorized_find_all_pending_by_current_user(model_ids_of(ids))
        updated_ids = process_todos(todos, **kwargs)

        {
          updated_ids: updated_ids,
          todos: Todo.id_in(updated_ids),
          errors: errors_on_objects(todos)
        }
      end

      private

      def process_todos(todos)
        raise NotImplementedError, "#{self.class} must implement #process_todos"
      end

      def todo_state_to_find
        raise NotImplementedError, "#{self.class} must implement #todo_state_to_find"
      end

      def model_ids_of(ids)
        ids.filter_map { |gid| gid.model_id.to_i }
      end

      def raise_too_many_todos_requested_error
        raise Gitlab::Graphql::Errors::ArgumentError, 'Too many to-do items requested.'
      end

      def check_update_limit!(amount:)
        raise_too_many_todos_requested_error if amount > MAX_UPDATE_AMOUNT
      end

      def errors_on_objects(todos)
        todos.flat_map { |todo| errors_on_object(todo) }
      end

      def authorized_find_all_pending_by_current_user(ids)
        return Todo.none if ids.blank? || current_user.nil?

        Todo.id_in(ids).for_user(current_user).with_state(todo_state_to_find)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/create.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class Create < ::Mutations::BaseMutation
      graphql_name 'TodoCreate'

      authorize :create_todo

      argument :target_id,
        Types::GlobalIDType[Todoable],
        required: true,
        description: "Global ID of the to-do item's parent. Issues, " \
          "merge requests, designs, and epics are supported."

      field :todo, Types::TodoType,
        null: true,
        description: 'To-do item created.'

      def resolve(target_id:)
        target = authorized_find!(id: target_id)

        todo = TodoService.new.mark_todo(target, current_user)&.first
        errors = errors_on_object(todo) if todo

        {
          todo: todo,
          errors: errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/delete_all_done.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class DeleteAllDone < ::Mutations::BaseMutation
      graphql_name 'TodoDeleteAllDone'

      argument :updated_before,
        ::Types::TimeType,
        required: false,
        description: 'To-do items marked as done before the timestamp will be deleted.'

      def resolve(updated_before: nil)
        verify_rate_limit!

        delete_until = (updated_before || Time.now).utc.to_datetime.to_s

        ::Todos::DeleteAllDoneWorker.perform_async(current_user.id, delete_until) # rubocop:disable CodeReuse/Worker -- we need to do this asynchronously

        {
          message: format(_('Your request has succeeded. Results will be visible in a couple of minutes.')),
          errors: []
        }
      end

      private

      def verify_rate_limit!
        return unless Gitlab::ApplicationRateLimiter.throttled?(:delete_all_todos, scope: [current_user])

        raise_resource_not_available_error!('This endpoint has been requested too many times. Try again later.')
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/delete_many.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class DeleteMany < BaseMany
      graphql_name 'TodoDeleteMany'

      def resolve(ids:)
        verify_rate_limit!
        check_update_limit!(amount: ids.size)

        todos = authorized_find_all_pending_by_current_user(model_ids_of(ids))
        deleted_ids = process_todos(todos)

        {
          deleted_ids: deleted_ids,
          errors: errors_on_objects(todos)
        }
      end

      private

      def process_todos(todos)
        ::Todos::Delete::DoneTodosService.new.execute(todos)
      end

      def todo_state_to_find
        :done
      end

      def verify_rate_limit!
        return unless Gitlab::ApplicationRateLimiter.throttled?(:bulk_delete_todos, scope: [current_user])

        raise_resource_not_available_error!('This endpoint has been requested too many times. Try again later.')
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/mark_all_done.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class MarkAllDone < ::Mutations::BaseMutation
      graphql_name 'TodosMarkAllDone'

      authorize :update_user

      TodoableID = Types::GlobalIDType[Todoable]

      argument :target_id,
        TodoableID,
        required: false,
        description: "Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. " \
          "If argument is omitted, all pending to-do items of the current user are marked as done."

      argument :author_id, [GraphQL::Types::ID],
        required: false,
        description: 'ID of an author.'

      argument :project_id, [GraphQL::Types::ID],
        required: false,
        description: 'ID of a project.'

      argument :group_id, [GraphQL::Types::ID],
        required: false,
        description: 'ID of a group.'

      argument :action, [Types::TodoActionEnum],
        required: false,
        description: 'Action to be filtered.'

      argument :type, [Types::TodoTargetEnum],
        required: false,
        description: 'Type of the todo.'

      field :todos, [::Types::TodoType],
        null: false,
        description: 'Updated to-do items.'

      def resolve(**args)
        authorize!(current_user)

        updated_ids = mark_all_todos_done(**args)

        {
          todos: Todo.id_in(updated_ids),
          errors: []
        }
      end

      private

      def mark_all_todos_done(**args)
        return [] unless current_user

        finder_params = todo_finder_params(args)

        if args[:target_id].present?
          target = Gitlab::Graphql::Lazy.force(
            GitlabSchema.find_by_gid(args[:target_id])
          )

          raise_resource_not_available_error! "Resource not available: #{args[:target_id]}" if target.nil?

          finder_params[:type] = target.class.name
          finder_params[:target_id] = target.id
        end

        todos = TodosFinder.new(users: current_user, **finder_params).execute

        TodoService.new.resolve_todos(todos, current_user, resolved_by_action: :api_all_done)
      end

      def todo_finder_params(args)
        {
          state: :pending,
          type: args[:type],
          group_id: args[:group_id],
          author_id: args[:author_id],
          action_id: args[:action],
          project_id: args[:project_id]
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/mark_done.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class MarkDone < ::Mutations::BaseMutation
      graphql_name 'TodoMarkDone'

      authorize :update_todo

      argument :id,
        ::Types::GlobalIDType[::Todo],
        required: true,
        description: 'Global ID of the to-do item to mark as done.'

      field :todo, Types::TodoType,
        null: false,
        description: 'Requested to-do item.'

      def resolve(id:)
        todo = authorized_find!(id: id)

        mark_done(todo)

        {
          todo: todo.reset,
          errors: errors_on_object(todo)
        }
      end

      private

      def mark_done(todo)
        TodoService.new.resolve_todo(todo, current_user, resolved_by_action: :api_done)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/resolve_many.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class ResolveMany < BaseMany
      graphql_name 'TodoResolveMany'

      field :todos, [::Types::TodoType],
        null: false,
        description: 'Resolved to-do items.'

      private

      def process_todos(todos)
        TodoService.new.resolve_todos(todos, current_user, resolved_by_action: :api_all_done)
      end

      def todo_state_to_find
        :pending
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/restore_many.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class RestoreMany < BaseMany
      graphql_name 'TodoRestoreMany'

      field :todos, [::Types::TodoType],
        null: false,
        description: 'Restored to-do items.'

      private

      def process_todos(todos)
        TodoService.new.restore_todos(todos, current_user)
      end

      def todo_state_to_find
        :done
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/restore.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class Restore < ::Mutations::BaseMutation
      graphql_name 'TodoRestore'

      authorize :update_todo

      argument :id,
        ::Types::GlobalIDType[::Todo],
        required: true,
        description: 'Global ID of the to-do item to restore.'

      field :todo, Types::TodoType,
        null: false,
        description: 'Requested to-do item.'

      def resolve(id:)
        todo = authorized_find!(id: id)
        restore(todo)

        {
          todo: todo.reset,
          errors: errors_on_object(todo)
        }
      end

      private

      def restore(todo)
        TodoService.new.restore_todo(todo, current_user)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/snooze_many.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class SnoozeMany < BaseMany
      graphql_name 'TodoSnoozeMany'

      argument :snooze_until,
        ::Types::TimeType,
        required: true,
        description: 'Time until which the todos should be snoozed.'

      field :todos, [::Types::TodoType],
        null: false,
        description: 'Snoozed to-do items.'

      private

      def process_todos(todos, snooze_until:)
        ::Todos::SnoozingService.new.snooze_todos(todos, snooze_until)
      end

      def todo_state_to_find
        :pending
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/snooze.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class Snooze < ::Mutations::BaseMutation
      graphql_name 'TodoSnooze'

      authorize :update_todo

      argument :id,
        ::Types::GlobalIDType[::Todo],
        required: true,
        description: 'Global ID of the to-do item to be snoozed.'

      argument :snooze_until,
        ::Types::TimeType,
        required: true,
        description: 'Time until which the todo should be snoozed.'

      field :todo, Types::TodoType,
        null: false,
        description: 'Requested to-do item.'

      def resolve(id:, snooze_until:)
        todo = authorized_find!(id: id)
        service_response = ::Todos::SnoozingService.new.snooze_todo(todo, snooze_until)

        {
          todo: todo,
          errors: service_response.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/unsnooze_many.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class UnsnoozeMany < BaseMany
      graphql_name 'TodoUnsnoozeMany'

      field :todos, [::Types::TodoType],
        null: false,
        description: 'Unsnoozed to-do items.'

      private

      def process_todos(todos)
        ::Todos::SnoozingService.new.unsnooze_todos(todos)
      end

      def todo_state_to_find
        :pending
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/todos/un_snooze.rb =====
# frozen_string_literal: true

module Mutations
  module Todos
    class UnSnooze < ::Mutations::BaseMutation
      graphql_name 'TodoUnSnooze'

      authorize :update_todo

      argument :id,
        ::Types::GlobalIDType[::Todo],
        required: true,
        description: 'Global ID of the to-do item to be snoozed.'

      field :todo, Types::TodoType,
        null: false,
        description: 'Requested to-do item.'

      def resolve(id:)
        todo = authorized_find!(id: id)
        service_response = ::Todos::SnoozingService.new.un_snooze_todo(todo)

        {
          todo: todo,
          errors: service_response.errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/uploads/delete.rb =====
# frozen_string_literal: true

module Mutations
  module Uploads
    class Delete < BaseMutation
      graphql_name 'UploadDelete'
      description 'Deletes an upload.'

      include Mutations::ResolvesResourceParent

      authorize :destroy_upload

      argument :secret, GraphQL::Types::String,
        required: true,
        description: 'Secret part of upload path.'

      argument :filename, GraphQL::Types::String,
        required: true,
        description: 'Upload filename.'

      field :upload, Types::UploadType,
        null: true,
        description: 'Deleted upload.'

      def resolve(args)
        parent = authorized_resource_parent_find!(args)

        upload = Banzai::UploadsFinder.new(parent: parent)
                  .find_by_secret_and_filename(args[:secret], args[:filename])
        result = ::Uploads::DestroyService.new(parent, current_user).execute(upload)

        {
          upload: result[:status] == :success ? result[:upload] : nil,
          errors: Array(result[:message])
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/user_callouts/create.rb =====
# frozen_string_literal: true

module Mutations
  module UserCallouts
    class Create < ::Mutations::BaseMutation
      graphql_name 'UserCalloutCreate'

      argument :feature_name,
        GraphQL::Types::String,
        required: true,
        description: "Feature name you want to dismiss the callout for."

      field :user_callout, Types::UserCalloutType,
        null: false,
        description: 'User callout dismissed.'

      def resolve(feature_name:)
        callout = ::Users::DismissCalloutService.new(
          container: nil, current_user: current_user, params: { feature_name: feature_name }
        ).execute
        errors = errors_on_object(callout)

        {
          user_callout: callout,
          errors: errors
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/user_preferences/update.rb =====
# frozen_string_literal: true

module Mutations
  module UserPreferences
    class Update < BaseMutation
      graphql_name 'UserPreferencesUpdate'

      NON_NULLABLE_ARGS = [
        :extensions_marketplace_opt_in_status,
        :organization_groups_projects_display,
        :visibility_pipeline_id_type,
        :use_work_items_view,
        :merge_request_dashboard_list_type
      ].freeze

      argument :extensions_marketplace_opt_in_status, Types::ExtensionsMarketplaceOptInStatusEnum,
        required: false,
        description: 'Status of the Web IDE Extension Marketplace opt-in for the user.'
      argument :issues_sort, Types::IssueSortEnum,
        required: false,
        description: 'Sort order for issue lists.'
      argument :merge_request_dashboard_list_type, Types::MergeRequests::DashboardListTypeEnum,
        required: false,
        description: 'Merge request dashboard list rendering type.'
      argument :merge_requests_sort, Types::MergeRequestSortEnum,
        required: false,
        description: 'Sort order for issue lists.'
      argument :use_work_items_view, GraphQL::Types::Boolean,
        required: false,
        description: 'Use work item view instead of legacy issue view.'
      argument :visibility_pipeline_id_type, Types::VisibilityPipelineIdTypeEnum,
        required: false,
        description: 'Determines whether the pipeline list shows ID or IID.'

      argument :projects_sort, Types::Projects::ProjectSortEnum,
        required: false,
        description: 'Sort order for projects.'

      argument :organization_groups_projects_sort, Types::Organizations::GroupsProjectsSortEnum,
        required: false,
        description: 'Sort order for organization groups and projects.',
        experiment: { milestone: '17.2' }

      argument :organization_groups_projects_display, Types::Organizations::GroupsProjectsDisplayEnum,
        required: false,
        description: 'Default list view for organization groups and projects.',
        experiment: { milestone: '17.2' }

      argument :work_items_display_settings,
        type: GraphQL::Types::JSON,
        description: 'Display settings for the work item lists, e.g.: "{ shouldOpenItemsInSidePanel: false }".',
        required: false,
        experiment: { milestone: '18.1' }

      field :user_preferences,
        Types::UserPreferencesType,
        null: true,
        description: 'User preferences after mutation.'

      def resolve(**attributes)
        attributes.delete_if { |key, value| NON_NULLABLE_ARGS.include?(key) && value.nil? }

        if attributes.include?(:extensions_marketplace_opt_in_status)
          attributes[:extensions_marketplace_opt_in_url] =
            ::WebIde::ExtensionMarketplace.marketplace_home_url(user: current_user)
        end

        user_preferences = current_user.user_preference
        if attributes[:work_items_display_settings].present?
          existing_settings = user_preferences.work_items_display_settings
          attributes[:work_items_display_settings] =
            existing_settings.merge(attributes[:work_items_display_settings])
        end

        user_preferences.update(attributes)

        {
          user_preferences: user_preferences.valid? ? user_preferences : nil,
          errors: errors_on_object(user_preferences)
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/users/saved_replies/create.rb =====
# frozen_string_literal: true

module Mutations
  module Users
    module SavedReplies
      class Create < ::Mutations::SavedReplies::Create
        graphql_name 'SavedReplyCreate'

        field :saved_reply, ::Types::Users::SavedReplyType,
          null: true,
          description: 'Saved reply after mutation.'

        def resolve(name:, content:)
          result = ::SavedReplies::CreateService.new(object: current_user, name: name, content: content).execute
          present_result(result)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/users/saved_replies/destroy.rb =====
# frozen_string_literal: true

module Mutations
  module Users
    module SavedReplies
      class Destroy < ::Mutations::SavedReplies::Destroy
        graphql_name 'SavedReplyDestroy'

        field :saved_reply, ::Types::Users::SavedReplyType,
          null: true,
          description: 'Saved reply after mutation.'

        argument :id, Types::GlobalIDType[::Users::SavedReply],
          required: true,
          description: copy_field_description(::Types::Users::SavedReplyType, :id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/users/saved_replies/update.rb =====
# frozen_string_literal: true

module Mutations
  module Users
    module SavedReplies
      class Update < ::Mutations::SavedReplies::Update
        graphql_name 'SavedReplyUpdate'

        field :saved_reply, ::Types::Users::SavedReplyType,
          null: true,
          description: 'Saved reply after mutation.'

        argument :id, Types::GlobalIDType[::Users::SavedReply],
          required: true,
          description: copy_field_description(::Types::Users::SavedReplyType, :id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/users/set_namespace_commit_email.rb =====
# frozen_string_literal: true

module Mutations
  module Users
    class SetNamespaceCommitEmail < BaseMutation
      graphql_name 'UserSetNamespaceCommitEmail'

      argument :namespace_id,
        ::Types::GlobalIDType[::Namespace],
        required: true,
        description: 'ID of the namespace to set the namespace commit email for.'

      argument :email_id,
        ::Types::GlobalIDType[::Email],
        required: false,
        description: 'ID of the email to set.'

      field :namespace_commit_email,
        Types::Users::NamespaceCommitEmailType,
        null: true,
        description: 'User namespace commit email after mutation.'

      authorize :read_namespace

      def resolve(args)
        namespace = authorized_find!(args[:namespace_id])
        args[:email_id] = args[:email_id].model_id

        result = ::Users::SetNamespaceCommitEmailService.new(current_user, namespace, args[:email_id], {}).execute
        {
          namespace_commit_email: result.payload[:namespace_commit_email],
          errors: result.errors
        }
      end

      private

      def find_object(id)
        GitlabSchema.object_from_id(
          id, expected_type: [::Namespace, ::Namespaces::UserNamespace, ::Namespaces::ProjectNamespace]).sync
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/wikis/wiki_page_subscribe.rb =====
# frozen_string_literal: true

module Mutations
  module Wikis
    class WikiPageSubscribe < BaseMutation
      graphql_name 'WikiPageSubscribe'

      argument :id, ::Types::GlobalIDType[::WikiPage::Meta],
        required: true,
        description: 'Global ID of the wiki page meta record.'

      argument :subscribed,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Desired state of the subscription.'

      field :wiki_page, ::Types::Wikis::WikiPageType,
        null: true,
        description: 'Wiki page after mutation.'

      authorize :update_subscription

      def resolve(args)
        wiki_page_meta = authorized_find!(id: args[:id])

        update_subscription(wiki_page_meta, args[:subscribed])

        {
          wiki_page: wiki_page_meta,
          errors: []
        }
      end

      private

      def update_subscription(wiki_page_meta, subscribed_state)
        wiki_page_meta.set_subscription(current_user, subscribed_state, wiki_page_meta.project)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/add_closing_merge_request.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class AddClosingMergeRequest < BaseMutation
      graphql_name 'WorkItemAddClosingMergeRequest'
      description 'Adds a closing merge request to a work item'

      authorize :update_work_item

      argument :context_namespace_path, GraphQL::Types::ID,
        required: false,
        description: 'Full path of the context namespace (project or group). Only project full paths are used to ' \
          'find a merge request using a short reference syntax like `!1`. Ignored for full references and URLs. ' \
          'Defaults to the namespace of the work item if not provided.'
      argument :id, ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item.'
      argument :merge_request_reference, GraphQL::Types::String,
        required: true,
        description: 'Merge request reference (short, full or URL). Example: ' \
          '`!1`, `project_full_path!1` or `https://gitlab.com/gitlab-org/gitlab/-/merge_requests/1`.'

      field :closing_merge_request,
        ::Types::WorkItems::ClosingMergeRequestType,
        null: true,
        description: 'Closing merge request added to the work item.'
      field :work_item, ::Types::WorkItemType,
        null: true,
        description: 'Work item with new closing merge requests.'

      def resolve(id:, merge_request_reference:, context_namespace_path: nil)
        work_item = authorized_find!(id: id)

        result = ::WorkItems::ClosingMergeRequests::CreateService.new(
          current_user: current_user,
          work_item: work_item,
          merge_request_reference: merge_request_reference,
          namespace_path: context_namespace_path
        ).execute

        {
          work_item: result.success? ? work_item : nil,
          closing_merge_request: result.success? ? result[:merge_request_closing_issue] : nil,
          errors: result.errors
        }
      rescue ::WorkItems::ClosingMergeRequests::CreateService::ResourceNotAvailable
        raise_resource_not_available_error!
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/bulk_move.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class BulkMove < BaseMutation
      graphql_name 'WorkItemBulkMove'

      include ::Gitlab::Utils::StrongMemoize
      include ResolvesProject

      MAX_WORK_ITEMS = 100

      description 'Allows move several work items.'

      argument :ids,
        [::Types::GlobalIDType[::WorkItem]],
        required: true,
        description: <<~DESC.squish
          Global ID array of the work items that will be moved.
          IDs that the user can\'t move will be ignored. A max of #{MAX_WORK_ITEMS} can be provided.
        DESC

      argument :source_full_path,
        GraphQL::Types::String,
        required: true,
        description: 'Full path of the source namespace. For example, `gitlab-org/gitlab-foss`.'

      argument :target_full_path,
        GraphQL::Types::String,
        required: true,
        description: 'Full path of the target namespace. For example, `gitlab-org/gitlab-foss`. ' \
          'Only project namespaces are supported.'

      field :moved_work_item_count, GraphQL::Types::Int,
        null: true,
        description: 'Number of work items that were successfully moved.'

      def ready?(**args)
        if args[:ids].size > MAX_WORK_ITEMS
          raise Gitlab::Graphql::Errors::ArgumentError,
            format(
              _('No more than %{max_work_items} work items can be moved at the same time'),
              max_work_items: MAX_WORK_ITEMS
            )
        end

        super
      end

      def resolve(ids:, source_full_path:, target_full_path:)
        target_project = resolve_project(full_path: target_full_path).sync

        if target_project.blank?
          raise Gitlab::Graphql::Errors::ArgumentError,
            _('At this moment, it is only possible to move work items to projects.')
        end

        result = ::WorkItems::BulkMoveService.new(
          current_user: current_user,
          work_item_ids: ids.map(&:model_id),
          source_namespace: namespace_for(source_full_path),
          target_namespace: target_project.project_namespace
        ).execute

        if result.success?
          { moved_work_item_count: result[:moved_work_item_count], errors: result.errors }
        else
          { errors: result.errors }
        end
      end

      private

      def namespace_for(full_path)
        ::Gitlab::Graphql::Loaders::FullPathModelLoader.new(::Namespace, full_path).find&.sync
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/bulk_update.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class BulkUpdate < BaseMutation
      graphql_name 'WorkItemBulkUpdate'

      include ::Gitlab::Utils::StrongMemoize

      MAX_WORK_ITEMS = 100

      description 'Allows updating several properties for a set of work items. '

      argument :assignees_widget,
        ::Types::WorkItems::Widgets::AssigneesInputType,
        required: false,
        description: 'Input for assignees widget.',
        experiment: { milestone: '18.2' }
      argument :confidential,
        GraphQL::Types::Boolean,
        required: false,
        description: 'Sets the work item confidentiality.',
        experiment: { milestone: '18.2' }
      argument :ids, [::Types::GlobalIDType[::WorkItem]],
        required: true,
        description: 'Global ID array of the work items that will be updated. ' \
          "IDs that the user can\'t update will be ignored. A max of #{MAX_WORK_ITEMS} can be provided."
      argument :milestone_widget,
        ::Types::WorkItems::Widgets::MilestoneInputType,
        required: false,
        description: 'Input for milestone widget.',
        experiment: { milestone: '18.2' }
      argument :state_event, ::Types::WorkItems::StateEventEnum,
        required: false,
        description: 'Close or reopen multiple work items at once.',
        experiment: { milestone: '18.2' }
      argument :subscription_event, ::Types::WorkItems::SubscriptionEventEnum,
        required: false,
        description: 'Subscribe or unsubscribe from the work items.',
        experiment: { milestone: '18.2' }

      argument :parent_id, ::Types::GlobalIDType[::WorkItems::Parent],
        required: false,
        description: 'Global ID of the parent to which the bulk update will be scoped. ' \
          'The parent can be a project. The parent can also be a group (Premium and Ultimate only). ' \
          'Example `WorkItemsParentID` are `"gid://gitlab/Project/1"` and `"gid://gitlab/Group/1"`.',
        deprecated: { milestone: '18.2', reason: 'Use full_path instead' }

      argument :full_path, GraphQL::Types::ID,
        required: false,
        description: 'Full path of the project or group (Premium and Ultimate only) containing the work items that ' \
          'will be updated. User paths are not supported.',
        experiment: { milestone: '18.2' }

      argument :labels_widget,
        ::Types::WorkItems::Widgets::LabelsUpdateInputType,
        required: false,
        description: 'Input for labels widget.'

      argument :hierarchy_widget, ::Types::WorkItems::Widgets::HierarchyCreateInputType,
        required: false,
        description: 'Input for hierarchy widget.',
        experiment: { milestone: '18.2' }

      field :updated_work_item_count, GraphQL::Types::Int,
        null: true,
        description: 'Number of work items that were successfully updated.'

      validates exactly_one_of: [:full_path, :parent_id]

      def ready?(**args)
        if args[:ids].size > MAX_WORK_ITEMS
          raise Gitlab::Graphql::Errors::ArgumentError,
            format(
              _('No more than %{max_work_items} work items can be updated at the same time'),
              max_work_items: MAX_WORK_ITEMS
            )
        end

        super
      end

      def resolve(ids:, parent_id: nil, full_path: nil, **attributes)
        parent = resource_parent!(parent_id, full_path)

        result = ::WorkItems::BulkUpdateService.new(
          parent: parent,
          current_user: current_user,
          work_item_ids: ids.map(&:model_id),
          attributes: attributes
        ).execute

        if result.success?
          { updated_work_item_count: result[:updated_work_item_count], errors: result.errors }
        else
          { errors: result.errors }
        end
      end

      private

      def resource_parent!(parent_id, full_path)
        strong_memoize_with(:resource_parent, parent_id, full_path) do
          parent = parent_id ? GitlabSchema.find_by_gid(parent_id).sync : find_parent_by_full_path(full_path)

          unless parent && current_user.can?("read_#{parent.to_ability_name}", parent)
            raise_resource_not_available_error!
          end

          parent
        end
      end

      def find_parent_by_full_path(full_path, model = ::Project)
        # Note: Group support is added in the EE module. For CE, we only support bulk edit for projects
        ::Gitlab::Graphql::Loaders::FullPathModelLoader.new(model, full_path).find.sync
      end
    end
  end
end

Mutations::WorkItems::BulkUpdate.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/convert.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class Convert < BaseMutation
      graphql_name 'WorkItemConvert'
      description "Converts the work item to a new type"

      include Mutations::SpamProtection

      authorize :update_work_item

      argument :id, ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item.'
      argument :work_item_type_id, ::Types::GlobalIDType[::WorkItems::Type],
        required: true,
        description: 'Global ID of the new work item type.'

      field :work_item, ::Types::WorkItemType,
        null: true,
        description: 'Updated work item.'

      def resolve(attributes)
        work_item = authorized_find!(id: attributes[:id])

        work_item_type = find_work_item_type!(attributes[:work_item_type_id])
        authorize_work_item_type!(work_item, work_item_type)

        update_result = ::WorkItems::UpdateService.new(
          container: work_item.project,
          current_user: current_user,
          params: { work_item_type: work_item_type, issue_type: work_item_type.base_type },
          perform_spam_check: true
        ).execute(work_item)

        check_spam_action_response!(work_item)

        {
          work_item: (update_result[:work_item] if update_result[:status] == :success),
          errors: Array.wrap(update_result[:message])
        }
      end

      private

      def find_work_item_type!(gid)
        work_item_type = ::WorkItems::Type.find_by_id(gid.model_id)

        return work_item_type if work_item_type.present?

        message = format(_('Work Item type with id %{id} was not found'), id: gid.model_id)
        raise_resource_not_available_error! message
      end

      def authorize_work_item_type!(work_item, work_item_type)
        return if current_user.can?(:"create_#{work_item_type.base_type}", work_item)

        message = format(_('You are not allowed to change the Work Item type to %{name}.'), name: work_item_type.name)
        raise_resource_not_available_error! message
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/create_from_task.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class CreateFromTask < BaseMutation
      graphql_name 'WorkItemCreateFromTask'

      include Mutations::SpamProtection

      description "Creates a work item from a task in another work item's description."

      authorize :update_work_item

      argument :id, ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item.'
      argument :work_item_data, ::Types::WorkItems::ConvertTaskInputType,
        required: true,
        description: 'Arguments necessary to convert a task into a work item.',
        prepare: ->(attributes, _ctx) { attributes.to_h }

      field :work_item, ::Types::WorkItemType,
        null: true,
        description: 'Updated work item.'

      field :new_work_item, ::Types::WorkItemType,
        null: true,
        description: 'New work item created from task.'

      def resolve(id:, work_item_data:)
        work_item = authorized_find!(id: id)

        result = ::WorkItems::CreateFromTaskService.new(
          work_item: work_item,
          current_user: current_user,
          work_item_params: work_item_data
        ).execute

        check_spam_action_response!(result[:work_item]) if result[:work_item]

        response = { errors: result.errors }
        response.merge!(work_item: work_item, new_work_item: result[:work_item]) if result.success?

        response
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/create.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class Create < BaseMutation
      graphql_name 'WorkItemCreate'

      include Mutations::SpamProtection
      include FindsNamespace
      include Mutations::WorkItems::SharedArguments
      include Mutations::WorkItems::Widgetable

      description "Creates a work item."

      authorize :create_work_item

      MUTUALLY_EXCLUSIVE_ARGUMENTS_ERROR = 'Please provide either projectPath or namespacePath argument, but not both.'
      DISABLED_FF_ERROR = 'create_group_level_work_items feature flag is disabled. Only project paths allowed.'

      def self.authorization_scopes
        super + [:ai_workflows]
      end

      argument :created_at, Types::TimeType,
        required: false,
        description: 'Timestamp when the work item was created. Available only for admins and project owners.'
      argument :crm_contacts_widget,
        ::Types::WorkItems::Widgets::CrmContactsCreateInputType,
        required: false,
        description: 'Input for CRM contacts widget.'
      argument :description,
        GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::WorkItemType, :description),
        deprecated: { milestone: '16.9', reason: 'use description widget instead' }
      argument :discussions_to_resolve,
        ::Types::WorkItems::ResolveDiscussionsInputType,
        required: false,
        description: 'Information required to resolve discussions in a noteable, when the work item is created.',
        prepare: ->(attributes, _ctx) { attributes.to_h }
      argument :hierarchy_widget,
        ::Types::WorkItems::Widgets::HierarchyCreateInputType,
        required: false,
        description: 'Input for hierarchy widget.'
      argument :labels_widget,
        ::Types::WorkItems::Widgets::LabelsCreateInputType,
        required: false,
        description: 'Input for labels widget.'
      argument :linked_items_widget,
        ::Types::WorkItems::Widgets::LinkedItemsCreateInputType,
        required: false,
        description: 'Input for linked items widget.'
      argument :namespace_path,
        GraphQL::Types::ID,
        required: false,
        description: 'Full path of the namespace(project or group) the work item is created in.'
      argument :project_path,
        GraphQL::Types::ID,
        required: false,
        description: 'Full path of the project the work item is associated with.',
        deprecated: {
          reason: 'Please use namespacePath instead. That will cover for both projects and groups',
          milestone: '15.10'
        }
      argument :start_and_due_date_widget,
        ::Types::WorkItems::Widgets::StartAndDueDateUpdateInputType,
        required: false,
        description: 'Input for start and due date widget.'
      argument :title,
        GraphQL::Types::String,
        required: true,
        description: copy_field_description(Types::WorkItemType, :title)
      argument :work_item_type_id,
        ::Types::GlobalIDType[::WorkItems::Type],
        required: true,
        description: 'Global ID of a work item type.'

      field :work_item,
        ::Types::WorkItemType,
        null: true, scopes: [:api, :ai_workflows],
        description: 'Created work item.'

      field :errors, [GraphQL::Types::String],
        null: false,
        scopes: [:api, :ai_workflows],
        description: 'Errors encountered during the mutation.'

      def ready?(**args)
        if args.slice(:project_path, :namespace_path)&.length != 1
          raise Gitlab::Graphql::Errors::ArgumentError, MUTUALLY_EXCLUSIVE_ARGUMENTS_ERROR
        end

        super
      end

      def resolve(project_path: nil, namespace_path: nil, **attributes)
        container_path = project_path || namespace_path
        container = authorized_find!(container_path)
        params = params_with_work_item_type(attributes).merge(author_id: current_user.id)
        params = params_with_resolve_discussion_params(params)
        type = params[:work_item_type]
        raise_resource_not_available_error! unless type

        check_feature_available!(container, type, params)
        widget_params = extract_widget_params!(type, params, container)

        create_result = ::WorkItems::CreateService.new(
          container: container,
          current_user: current_user,
          params: params,
          widget_params: widget_params
        ).execute

        check_spam_action_response!(create_result[:work_item]) if create_result[:work_item]

        {
          work_item: create_result.success? ? create_result[:work_item] : nil,
          errors: create_result.errors
        }
      end

      private

      def check_feature_available!(container, type, params)
        return unless container.is_a?(::Group)

        if params[:merge_request_to_resolve_discussions_object]
          raise Gitlab::Graphql::Errors::ArgumentError,
            _('Only project level work items can be created to resolve noteable discussions')
        end

        return if ::WorkItems::Type.allowed_group_level_types(container).include?(type.base_type)

        raise_feature_not_available_error!(type)
      end

      def params_with_resolve_discussion_params(attributes)
        discussion_attributes = attributes.delete(:discussions_to_resolve)
        return attributes if discussion_attributes.blank?

        noteable = discussion_attributes[:noteable_id].find
        unless noteable.is_a?(::MergeRequest)
          raise Gitlab::Graphql::Errors::ArgumentError,
            _('Only Merge Requests are allowed as a noteable to resolve discussions of at the moment.')
        end

        raise_resource_not_available_error! unless current_user.can?(:resolve_note, noteable)

        attributes[:discussion_to_resolve] = discussion_attributes[:discussion_id]
        attributes[:merge_request_to_resolve_discussions_object] = noteable
        attributes
      end

      def params_with_work_item_type(attributes)
        work_item_type_id = attributes.delete(:work_item_type_id)&.model_id
        work_item_type = ::WorkItems::Type.find_by_id(work_item_type_id)

        attributes[:work_item_type] = work_item_type

        attributes
      end

      # type is used in overridden EE method
      def raise_feature_not_available_error!(_type)
        raise Gitlab::Graphql::Errors::ArgumentError, DISABLED_FF_ERROR
      end
    end
  end
end

Mutations::WorkItems::Create.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/csv/export.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module CSV
      class Export < BaseMutation
        graphql_name 'WorkItemsCsvExport'

        include FindsProject
        include ::SearchArguments
        include ::WorkItems::SharedFilterArguments

        authorize :export_work_items

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full project path.'

        argument :selected_fields, [::Types::WorkItems::AvailableExportFieldsEnum],
          required: false,
          description: 'List of selected fields to be exported. Omit to export all available fields.'

        field :message, GraphQL::Types::String,
          null: true,
          description: 'Export request result message.'

        def resolve(args)
          project_path = args.delete(:project_path)
          project = authorized_find!(project_path)

          check_export_available_for!(project)

          # This is some old code, moved to a different module. We should definitely seek to move this code
          # to a service class.
          # rubocop:disable CodeReuse/Worker -- see above
          IssuableExportCsvWorker.perform_async(:work_item, current_user.id, project.id, prepare_finder_params(args))
          # rubocop:enable CodeReuse/Worker

          {
            message: format(
              _('Your CSV export request has succeeded. The result will be emailed to %{email}.'),
              { email: current_user.notification_email_or_default }
            ),
            errors: []
          }
        end

        def check_export_available_for!(project)
          return if project.work_items_project_issues_list_feature_flag_enabled?

          error = '`work_items_project_issues_list` feature flag is disabled.'

          raise_resource_not_available_error! error
        end
      end
    end
  end
end

Mutations::WorkItems::CSV::Export.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/csv/import.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module CSV
      class Import < BaseMutation
        graphql_name 'WorkItemsCsvImport'

        include FindsProject

        EXTENSION_ALLOWLIST = %w[csv].map(&:downcase).freeze

        authorize :import_work_items

        argument :project_path, GraphQL::Types::ID,
          required: true,
          description: 'Full project path.'

        argument :file, ApolloUploadServer::Upload,
          required: true,
          description: 'CSV file to import work items from.'

        field :message, GraphQL::Types::String,
          null: true,
          description: 'Import request result message.'

        def resolve(args)
          project_path = args.delete(:project_path)
          project = authorized_find!(project_path)

          validate_import_available_for!(project)

          file = args[:file]

          unless file_is_valid?(file)
            return {
              message: nil,
              errors: [invalid_file_message]
            }
          end

          result = ::WorkItems::PrepareImportCsvService.new(project, current_user, file:).execute

          return { message: result.message, errors: [] } if result.success?

          { message: nil, errors: [result.message] }
        end

        private

        def validate_import_available_for!(project)
          return if project.work_items_project_issues_list_feature_flag_enabled?

          raise_resource_not_available_error! '`work_items_project_issues_list` feature flag is disabled.'
        end

        def file_is_valid?(file)
          return false unless file.respond_to?(:original_filename)

          file_extension = File.extname(file.original_filename).downcase.delete('.')
          EXTENSION_ALLOWLIST.include?(file_extension)
        end

        def invalid_file_message
          supported_file_extensions = ".#{EXTENSION_ALLOWLIST.join(', .')}"
          format(_("The uploaded file was invalid. Supported file extensions are %{extensions}."),
            { extensions: supported_file_extensions })
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/delete.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class Delete < BaseMutation
      graphql_name 'WorkItemDelete'
      description "Deletes a work item."

      authorize :delete_work_item

      argument :id, ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item.'

      field :project, ::Types::ProjectType,
        null: true,
        description: 'Project the deleted work item belonged to.',
        deprecated: {
          reason: 'Use `namespace`',
          milestone: '16.9'
        }

      field :namespace, ::Types::NamespaceType,
        null: true,
        description: 'Namespace the deleted work item belonged to.'

      def resolve(id:)
        work_item = authorized_find!(id: id)

        result = ::WorkItems::DeleteService.new(
          container: work_item.resource_parent,
          current_user: current_user
        ).execute(work_item)

        response = { errors: result.errors }

        if result.success?
          response.merge(project: work_item.project, namespace: work_item.namespace)
        else
          response
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/hierarchy/add_children_items.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module Hierarchy
      class AddChildrenItems < BaseMutation
        graphql_name 'WorkItemHierarchyAddChildrenItems'
        description "Adds children to a given work item's hierarchy by Global ID."

        authorize :read_work_item

        argument :children_ids, [::Types::GlobalIDType[::WorkItem]],
          required: true,
          description: 'Global IDs of children work items.',
          loads: ::Types::WorkItemType,
          as: :children
        argument :id,
          ::Types::GlobalIDType[::WorkItem],
          required: true,
          description: 'Global ID of the work item.'

        field :added_children, [::Types::WorkItemType],
          null: false,
          description: 'Work items that were added as children.'

        def resolve(id:, **attributes)
          Gitlab::QueryLimiting.disable!('https://gitlab.com/gitlab-org/gitlab/-/issues/408575')

          work_item = authorized_find!(id: id)
          children = attributes[:children]

          update_result = ::WorkItems::ParentLinks::CreateService
            .new(work_item, current_user, { issuable_references: children })
            .execute

          {
            added_children: update_result[:created_references]&.map(&:work_item) || [],
            errors: Array.wrap(update_result[:message])
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/hierarchy/reorder.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module Hierarchy
      class Reorder < BaseMutation
        graphql_name 'workItemsHierarchyReorder'
        description 'Reorder a work item in the hierarchy tree.'

        argument :id, ::Types::GlobalIDType[::WorkItem],
          required: true, description: 'Global ID of the work item to be reordered.'

        argument :adjacent_work_item_id,
          ::Types::GlobalIDType[::WorkItem],
          required: false,
          description: 'ID of the work item to move next to. For example, the item above or below.'

        argument :parent_id, ::Types::GlobalIDType[::WorkItem],
          required: false,
          description: 'Global ID of the new parent work item.'

        argument :relative_position,
          ::Types::RelativePositionTypeEnum,
          required: false,
          description: 'Position relative to the adjacent work item. Valid values are `BEFORE` or `AFTER`.'

        field :work_item, ::Types::WorkItemType,
          null: true, description: 'Work item after mutation.'

        field :adjacent_work_item, ::Types::WorkItemType,
          null: true, description: 'Adjacent work item after mutation.'

        field :parent_work_item, ::Types::WorkItemType,
          null: true, description: "Work item's parent after mutation."

        authorize :read_work_item

        def ready?(**args)
          validate_position_args!(args)

          @work_item = authorized_find!(id: args.delete(:id))
          @adjacent_item = authorized_find!(id: args.delete(:adjacent_work_item_id)) if args[:adjacent_work_item_id]
          new_parent = authorized_find!(id: args.delete(:parent_id)) if args[:parent_id]
          @parent = new_parent || work_item.work_item_parent

          validate_parent!

          super
        end

        def resolve(**args)
          arguments = {
            target_issuable: work_item,
            adjacent_work_item: adjacent_item,
            relative_position: args.delete(:relative_position)
          }

          service_response = ::WorkItems::ParentLinks::ReorderService.new(parent, current_user, arguments).execute

          {
            work_item: work_item,
            adjacent_work_item: adjacent_item,
            parent_work_item: parent,
            errors: service_response[:status] == :error ? Array.wrap(service_response[:message]) : []
          }
        end

        private

        attr_reader :work_item, :parent, :adjacent_item

        def validate_parent!
          return unless adjacent_item
          return if parent == adjacent_item.work_item_parent

          raise Gitlab::Graphql::Errors::ArgumentError,
            _("The adjacent work item's parent must match the moving work item's parent.")
        end

        def validate_position_args!(args)
          return unless args.slice(:adjacent_work_item_id, :relative_position).one?

          raise Gitlab::Graphql::Errors::ArgumentError,
            _('Both adjacentWorkItemId and relativePosition are required.')
        end

        def find_object(id:)
          GitlabSchema.object_from_id(id, expected_type: ::WorkItem).sync
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/linked_items/add.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module LinkedItems
      class Add < Base
        graphql_name 'WorkItemAddLinkedItems'
        description 'Add linked items to the work item.'

        argument :link_type, ::Types::WorkItems::RelatedLinkTypeEnum,
          required: false, description: 'Type of link. Defaults to `RELATED`.'
        argument :work_items_ids, [::Types::GlobalIDType[::WorkItem]],
          required: true,
          description: "Global IDs of the items to link. Maximum number of IDs you can provide: #{MAX_WORK_ITEMS}."

        private

        def update_links(work_item, params)
          gids = params.delete(:work_items_ids)
          work_items = begin
            GitlabSchema.parse_gids(gids, expected_type: ::WorkItem).map(&:find)
          rescue ActiveRecord::RecordNotFound => e
            raise Gitlab::Graphql::Errors::ArgumentError, e
          end

          ::WorkItems::RelatedWorkItemLinks::CreateService
            .new(work_item, current_user, { target_issuable: work_items, link_type: params[:link_type] })
            .execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/linked_items/base.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module LinkedItems
      class Base < BaseMutation
        # Limit maximum number of items that can be linked at a time to avoid overloading the DB
        MAX_WORK_ITEMS = 10

        argument :id, ::Types::GlobalIDType[::WorkItem],
          required: true, description: 'Global ID of the work item.'

        field :work_item, ::Types::WorkItemType,
          null: true, description: 'Updated work item.'

        field :message, GraphQL::Types::String,
          null: true, description: 'Linked items update result message.'

        authorize :read_work_item

        def ready?(**args)
          if args[:work_items_ids].size > MAX_WORK_ITEMS
            raise Gitlab::Graphql::Errors::ArgumentError,
              format(
                _('No more than %{max_work_items} work items can be modified at the same time.'),
                max_work_items: MAX_WORK_ITEMS
              )
          end

          super
        end

        def resolve(**args)
          work_item = authorized_find!(id: args.delete(:id))
          service_response = update_links(work_item, args)

          {
            work_item: work_item,
            errors: service_response[:status] == :error ? Array.wrap(service_response[:message]) : [],
            message: service_response[:status] == :success ? service_response[:message] : ''
          }
        end

        private

        def update_links(work_item, params)
          raise NotImplementedError, "#{self.class} does not implement #{__method__}"
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/linked_items/remove.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module LinkedItems
      class Remove < Base
        graphql_name 'WorkItemRemoveLinkedItems'
        description 'Remove items linked to the work item.'

        argument :work_items_ids, [::Types::GlobalIDType[::WorkItem]],
          required: true,
          description: "Global IDs of the items to unlink. Maximum number of IDs you can provide: #{MAX_WORK_ITEMS}."

        private

        def update_links(work_item, params)
          gids = params.delete(:work_items_ids)
          raise Gitlab::Graphql::Errors::ArgumentError, "workItemsIds cannot be empty" if gids.empty?

          work_item_ids = gids.filter_map { |gid| gid.model_id.to_i }
          ::WorkItems::RelatedWorkItemLinks::DestroyService
            .new(work_item, current_user, { item_ids: work_item_ids })
            .execute
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/reorder.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class Reorder < BaseMutation
      graphql_name 'workItemsReorder'
      description 'Reorders a project level work item.'

      argument :id,
        ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item to be reordered.'

      argument :move_before_id,
        ::Types::GlobalIDType[::WorkItem],
        required: false,
        description: 'Global ID of a project’s work item that should be placed before the work item.',
        prepare: ->(id, _ctx) { GitlabSchema.parse_gid(id)&.model_id }

      argument :move_after_id,
        ::Types::GlobalIDType[::WorkItem],
        required: false,
        description: 'Global ID of a project’s work item that should be placed after the work item.',
        prepare: ->(id, _ctx) { GitlabSchema.parse_gid(id)&.model_id }

      field :work_item,
        ::Types::WorkItemType,
        null: true,
        description: 'Work item after mutation.'

      authorize :update_work_item

      def ready?(**args)
        return super if args.slice(:move_after_id, :move_before_id).compact.present?

        raise Gitlab::Graphql::Errors::ArgumentError,
          'At least one of move_before_id and move_after_id are required'
      end

      def resolve(**args)
        work_item = authorized_find!(id: args[:id])

        ::WorkItems::ReorderService.new(
          current_user: current_user,
          params: args.slice(:move_before_id, :move_after_id)
        ).execute(work_item).payload
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/subscribe.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class Subscribe < BaseMutation
      graphql_name 'WorkItemSubscribe'

      argument :id, ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item.'

      argument :subscribed,
        GraphQL::Types::Boolean,
        required: true,
        description: 'Desired state of the subscription.'

      field :work_item, ::Types::WorkItemType,
        null: true,
        description: 'Work item after mutation.'

      authorize :update_subscription

      def resolve(args)
        work_item = authorized_find!(id: args[:id])

        update_subscription(work_item, args[:subscribed])

        {
          work_item: work_item,
          errors: []
        }
      end

      private

      def update_subscription(work_item, subscribed_state)
        work_item.set_subscription(current_user, subscribed_state, work_item.project)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/update.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    class Update < BaseMutation
      graphql_name 'WorkItemUpdate'
      description "Updates a work item by Global ID."

      include Mutations::SpamProtection
      include Mutations::WorkItems::SharedArguments
      include Mutations::WorkItems::Widgetable

      authorize :read_work_item

      def self.authorization_scopes
        super + [:ai_workflows]
      end

      argument :award_emoji_widget,
        ::Types::WorkItems::Widgets::AwardEmojiUpdateInputType,
        required: false,
        description: 'Input for emoji reactions widget.'
      argument :crm_contacts_widget,
        ::Types::WorkItems::Widgets::CrmContactsUpdateInputType,
        required: false,
        description: 'Input for CRM contacts widget.'
      argument :current_user_todos_widget,
        ::Types::WorkItems::Widgets::CurrentUserTodosInputType,
        required: false,
        description: 'Input for to-dos widget.'
      argument :hierarchy_widget,
        ::Types::WorkItems::Widgets::HierarchyUpdateInputType,
        required: false,
        description: 'Input for hierarchy widget.'
      argument :id,
        ::Types::GlobalIDType[::WorkItem],
        required: true,
        description: 'Global ID of the work item.'
      argument :labels_widget,
        ::Types::WorkItems::Widgets::LabelsUpdateInputType,
        required: false,
        description: 'Input for labels widget.'
      argument :notes_widget,
        ::Types::WorkItems::Widgets::NotesInputType,
        required: false,
        description: 'Input for notes widget.'
      argument :notifications_widget,
        ::Types::WorkItems::Widgets::NotificationsUpdateInputType,
        required: false,
        description: 'Input for notifications widget.'
      argument :start_and_due_date_widget,
        ::Types::WorkItems::Widgets::StartAndDueDateUpdateInputType,
        required: false,
        description: 'Input for start and due date widget.'
      argument :state_event,
        ::Types::WorkItems::StateEventEnum,
        description: 'Close or reopen a work item.',
        required: false
      argument :time_tracking_widget,
        ::Types::WorkItems::Widgets::TimeTracking::TimeTrackingInputType,
        required: false,
        description: 'Input for time tracking widget.'
      argument :title,
        GraphQL::Types::String,
        required: false,
        description: copy_field_description(Types::WorkItemType, :title)

      field :work_item, ::Types::WorkItemType,
        null: true, scopes: [:api, :ai_workflows],
        description: 'Updated work item.'

      field :errors, [GraphQL::Types::String],
        null: false,
        scopes: [:api, :ai_workflows],
        description: 'Errors encountered during the mutation.'

      def resolve(id:, **attributes)
        Gitlab::QueryLimiting.disable!('https://gitlab.com/gitlab-org/gitlab/-/issues/408575')

        work_item = authorized_find!(id: id)

        widget_params = extract_widget_params!(work_item.work_item_type, attributes, work_item.resource_parent)

        # Only checks permissions for base attributes because widgets define their own permissions independently
        raise_resource_not_available_error! unless attributes.empty? || can_update?(work_item)

        update_result = ::WorkItems::UpdateService.new(
          container: work_item.resource_parent,
          current_user: current_user,
          params: attributes,
          widget_params: widget_params,
          perform_spam_check: true
        ).execute(work_item)

        check_spam_action_response!(work_item)

        {
          work_item: (update_result[:work_item] if update_result[:status] == :success),
          errors: Array.wrap(update_result[:message])
        }
      end

      private

      def can_update?(work_item)
        current_user.can?(:update_work_item, work_item)
      end
    end
  end
end

Mutations::WorkItems::Update.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/mutations/work_items/user_preference/update.rb =====
# frozen_string_literal: true

module Mutations
  module WorkItems
    module UserPreference
      class Update < BaseMutation
        graphql_name 'WorkItemUserPreferenceUpdate'
        description "Create or Update user preferences for a work item type and namespace."

        include Mutations::SpamProtection
        include FindsNamespace

        authorize :read_namespace

        argument :namespace_path,
          type: GraphQL::Types::ID,
          required: true,
          description: 'Full path of the namespace on which the preference is set.'

        argument :work_item_type_id,
          type: ::Types::GlobalIDType[::WorkItems::Type],
          required: false,
          description: 'Global ID of a work item type.'

        argument :sort,
          type: ::Types::WorkItems::SortEnum,
          description: 'Sort order for work item lists.',
          required: false,
          default_value: :created_asc

        argument :display_settings,
          type: GraphQL::Types::JSON,
          description: 'Display settings for the work item lists.',
          required: false

        field :user_preferences,
          type: ::Types::WorkItems::UserPreference,
          description: 'User preferences.'

        def resolve(namespace_path:, work_item_type_id: nil, **attributes)
          namespace = find_object(namespace_path)
          namespace = namespace.project_namespace if namespace.is_a?(Project)
          authorize!(namespace)

          work_item_type_id = work_item_type_id&.model_id

          preferences = ::WorkItems::UserPreference.create_or_update(
            namespace: namespace,
            work_item_type_id: work_item_type_id,
            user: current_user,
            **attributes)

          {
            user_preferences: preferences.valid? ? preferences : nil,
            errors: errors_on_object(preferences)
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/burndown_chart/burnup.iteration.query.graphql =====
query BurnupTimesSeriesIterationData(
  $iterationId: IterationID!
  $weight: Boolean = false
  $fullPath: String
) {
  iteration(id: $iterationId) {
    __typename
    id
    title
    report(fullPath: $fullPath) {
      __typename
      burnupTimeSeries {
        __typename
        date
        completedCount @skip(if: $weight)
        scopeCount @skip(if: $weight)
        completedWeight @include(if: $weight)
        scopeWeight @include(if: $weight)
      }
      stats {
        __typename
        total {
          __typename
          count @skip(if: $weight)
          weight @include(if: $weight)
        }
        complete {
          __typename
          count @skip(if: $weight)
          weight @include(if: $weight)
        }
        incomplete {
          __typename
          count @skip(if: $weight)
          weight @include(if: $weight)
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/burndown_chart/burnup.milestone.query.graphql =====
query BurnupTimesSeriesMilestoneData($milestoneId: MilestoneID!, $weight: Boolean = false) {
  milestone(id: $milestoneId) {
    __typename
    id
    title
    report {
      __typename
      burnupTimeSeries {
        __typename
        date
        completedCount @skip(if: $weight)
        scopeCount @skip(if: $weight)
        completedWeight @include(if: $weight)
        scopeWeight @include(if: $weight)
      }
      stats {
        __typename
        total {
          __typename
          count @skip(if: $weight)
          weight @include(if: $weight)
        }
        complete {
          __typename
          count @skip(if: $weight)
          weight @include(if: $weight)
        }
        incomplete {
          __typename
          count @skip(if: $weight)
          weight @include(if: $weight)
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/container_registry/get_container_repositories.query.graphql =====
query getProjectContainerRepositories(
  $fullPath: ID!
  $name: String
  $first: Int
  $last: Int
  $after: String
  $before: String
  $isGroupPage: Boolean!
  $sort: ContainerRepositorySort
) {
  project(fullPath: $fullPath) @skip(if: $isGroupPage) {
    __typename
    id
    containerRepositoriesCount
    containerRepositories(
      name: $name
      after: $after
      before: $before
      first: $first
      last: $last
      sort: $sort
    ) {
      __typename
      nodes {
        id
        migrationState
        name
        path
        status
        location
        createdAt
        expirationPolicyStartedAt
        expirationPolicyCleanupStatus
        project {
          id
          path
        }
        protectionRuleExists
        userPermissions {
          destroyContainerRepository
        }
        __typename
      }
      pageInfo {
        __typename
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
    }
  }
  group(fullPath: $fullPath) @include(if: $isGroupPage) {
    __typename
    id
    containerRepositoriesCount
    containerRepositories(
      name: $name
      after: $after
      before: $before
      first: $first
      last: $last
      sort: $sort
    ) {
      __typename
      nodes {
        id
        migrationState
        name
        path
        status
        location
        createdAt
        expirationPolicyStartedAt
        expirationPolicyCleanupStatus
        project {
          id
          name
          path
          webUrl
        }
        protectionRuleExists
        userPermissions {
          destroyContainerRepository
        }
        __typename
      }
      pageInfo {
        __typename
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/design_management/design_permissions.query.graphql =====
query permissions($fullPath: ID!, $iid: String!) {
  project(fullPath: $fullPath) {
    __typename
    id
    issue(iid: $iid) {
      __typename
      id
      userPermissions {
        __typename
        createDesign
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/design_management/get_design_list.query.graphql =====
query getDesignList($fullPath: ID!, $iid: String!, $atVersion: DesignManagementVersionID) {
  project(fullPath: $fullPath) {
    __typename
    id
    issue(iid: $iid) {
      __typename
      id
      designCollection {
        __typename
        copyState
        designs(atVersion: $atVersion) {
          __typename
          nodes {
            __typename
            id
            event
            filename
            notesCount
            image
            imageV432x230
            currentUserTodos(state: pending) {
              __typename
              nodes {
                __typename
                id
              }
            }
          }
        }
        versions {
          __typename
          nodes {
            __typename
            id
            sha
            createdAt
            author {
              __typename
              id
              name
              avatarUrl
            }
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/epic/epic_details.query.graphql =====
query epicDetails($fullPath: ID!, $iid: ID!) {
  group(fullPath: $fullPath) {
    __typename
    id
    epic(iid: $iid) {
      __typename
      id
      participants {
        __typename
        edges {
          __typename
          node {
            __typename
            id
            name
            avatarUrl
            webUrl
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/pipelines/get_pipeline_details.query.graphql =====
fragment CiNeeds on JobNeedUnion {
  ...CiBuildNeedFields
  ...CiJobNeedFields
}

fragment CiBuildNeedFields on CiBuildNeed {
  id
  name
}

fragment CiJobNeedFields on CiJob {
  id
  name
}

fragment LinkedPipelineData on Pipeline {
  __typename
  id
  iid
  path
  cancelable
  retryable
  userPermissions {
    updatePipeline
  }
  # @graphql-eslint/eslint-plugin@4.0.0 reports missing IDs in `FragmentDefinition`. For now, we are
  # ignoring the newly uncovered error on this fragment. Please consider addressing the violation
  # if you are modifying this file and it turns out selecting the ID makes sense here.
  # eslint-disable-next-line @graphql-eslint/require-selections
  status: detailedStatus {
    __typename
    group
    label
    icon
    text
  }
  sourceJob {
    __typename
    id
    name
    retried
  }
  project {
    __typename
    id
    name
    fullPath
  }
}

query getPipelineDetails($projectPath: ID!, $iid: ID!) {
  project(fullPath: $projectPath) {
    __typename
    id
    pipeline(iid: $iid) {
      __typename
      id
      iid
      usesNeeds
      userPermissions {
        updatePipeline
      }
      downstream {
        __typename
        nodes {
          # eslint-disable-next-line @graphql-eslint/require-selections -- for detailedStatus.id
          ...LinkedPipelineData
          name
        }
      }
      upstream {
        # eslint-disable-next-line @graphql-eslint/require-selections -- for detailedStatus.id
        ...LinkedPipelineData
      }
      stages {
        __typename
        nodes {
          __typename
          id
          name
          # eslint-disable-next-line @graphql-eslint/require-selections
          status: detailedStatus {
            __typename
            action {
              __typename
              id
              icon
              path
              title
              confirmationMessage
            }
          }
          groups {
            __typename
            nodes {
              __typename
              id
              # eslint-disable-next-line @graphql-eslint/require-selections
              status: detailedStatus {
                __typename
                label
                group
                icon
                text
              }
              name
              size
              jobs {
                __typename
                nodes {
                  __typename
                  id
                  name
                  kind
                  needs {
                    __typename
                    nodes {
                      __typename
                      id
                      name
                    }
                  }
                  previousStageJobsOrNeeds {
                    __typename
                    nodes {
                      ...CiNeeds
                    }
                  }
                  # eslint-disable-next-line @graphql-eslint/require-selections
                  status: detailedStatus {
                    __typename
                    icon
                    tooltip
                    hasDetails
                    detailsPath
                    deploymentDetailsPath
                    group
                    label
                    text
                    action {
                      __typename
                      id
                      buttonTitle
                      confirmationMessage
                      icon
                      path
                      title
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/repository/blob_info.query.graphql =====
query getBlobInfo(
  $projectPath: ID!
  $filePath: [String!]!
  $ref: String!
  $refType: RefType
  $shouldFetchRawText: Boolean!
) {
  project(fullPath: $projectPath) {
    __typename
    id
    repository {
      __typename
      empty
      blobs(paths: $filePath, ref: $ref, refType: $refType) {
        __typename
        nodes {
          __typename
          id
          webPath
          name
          size
          rawSize
          rawTextBlob @include(if: $shouldFetchRawText)
          fileType
          language
          path
          blamePath
          editBlobPath
          gitpodBlobUrl
          ideEditPath
          forkAndEditPath
          ideForkAndEditPath
          codeNavigationPath
          projectBlobPathRoot
          forkAndViewPath
          environmentFormattedExternalUrl
          environmentExternalUrlForRouteMap
          canModifyBlob
          canModifyBlobWithWebIde
          canCurrentUserPushToBranch
          archived
          storedExternally
          externalStorage
          externalStorageUrl
          rawPath
          replacePath
          pipelineEditorPath
          simpleViewer {
            fileType
            tooLarge
            type
            renderError
          }
          richViewer {
            fileType
            tooLarge
            type
            renderError
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/repository/files.query.graphql =====
fragment PageInfo on PageInfo {
  __typename
  hasNextPage
  hasPreviousPage
  startCursor
  endCursor
}

fragment TreeEntry on Entry {
  __typename
  id
  sha
  name
  flatPath
  type
}

query getFiles(
  $projectPath: ID!
  $path: String
  $ref: String!
  $refType: RefType
  $pageSize: Int!
  $nextPageCursor: String
) {
  project(fullPath: $projectPath) {
    id
    __typename
    repository {
      __typename
      tree(path: $path, ref: $ref, refType: $refType) {
        __typename
        trees(first: $pageSize, after: $nextPageCursor) {
          __typename
          edges {
            __typename
            node {
              ...TreeEntry
              webPath
            }
          }
          pageInfo {
            ...PageInfo
          }
        }
        submodules(first: $pageSize, after: $nextPageCursor) {
          __typename
          edges {
            __typename
            node {
              ...TreeEntry
              webUrl
              treeUrl
            }
          }
          pageInfo {
            ...PageInfo
          }
        }
        blobs(first: $pageSize, after: $nextPageCursor) {
          __typename
          edges {
            __typename
            node {
              ...TreeEntry
              mode
              webPath
              lfsOid
            }
          }
          pageInfo {
            ...PageInfo
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/repository/paginated_tree.query.graphql =====
fragment TreeEntry on Entry {
  __typename
  id
  sha
  name
  flatPath
  type
  path
}

query getPaginatedTree(
  $projectPath: ID!
  $path: String
  $ref: String!
  $nextPageCursor: String
  $refType: RefType
) {
  project(fullPath: $projectPath) {
    id
    __typename
    repository {
      __typename
      paginatedTree(path: $path, ref: $ref, refType: $refType, after: $nextPageCursor) {
        __typename
        pageInfo {
          __typename
          endCursor
          startCursor
          hasNextPage
        }
        nodes {
          __typename
          trees {
            __typename
            nodes {
              ...TreeEntry
              webPath
            }
          }
          submodules {
            __typename
            nodes {
              ...TreeEntry
              webUrl
              treeUrl
            }
          }
          blobs {
            __typename
            nodes {
              ...TreeEntry
              mode
              webPath
              lfsOid
            }
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/repository/path_last_commit.query.graphql =====
query pathLastCommit($projectPath: ID!, $path: String, $ref: String!, $refType: RefType) {
  project(fullPath: $projectPath) {
    __typename
    id
    repository {
      __typename
      lastCommit(path: $path, ref: $ref, refType: $refType) {
        __typename
        id
        sha
        title
        titleHtml
        descriptionHtml
        message
        webPath
        committerName
        committerEmail
        committedDate
        authoredDate
        authorName
        authorEmail
        authorGravatar
        author {
          __typename
          id
          name
          avatarUrl
          webPath
        }
        signature {
          __typename
          ... on GpgSignature {
            gpgKeyPrimaryKeyid
            verificationStatus
          }
          ... on X509Signature {
            verificationStatus
            x509Certificate {
              id
              subject
              subjectKeyIdentifier
              x509Issuer {
                id
                subject
                subjectKeyIdentifier
              }
            }
          }
          ... on SshSignature {
            verificationStatus
            keyFingerprintSha256
          }
        }
        pipelines(ref: $ref, first: 1) {
          __typename
          edges {
            __typename
            node {
              __typename
              id
              detailedStatus {
                __typename
                id
                detailsPath
                icon
                text
              }
            }
          }
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/repository/permissions.query.graphql =====
query getPermissions($projectPath: ID!) {
  project(fullPath: $projectPath) {
    id
    __typename
    userPermissions {
      __typename
      pushCode
      forkProject
      createMergeRequestIn
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/snippet/project_permissions.query.graphql =====
query CanCreateProjectSnippet($fullPath: ID!) {
  project(fullPath: $fullPath) {
    __typename
    id
    userPermissions {
      __typename
      createSnippet
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/snippet/snippet_blob_content.query.graphql =====
query SnippetBlobContent($ids: [SnippetID!], $rich: Boolean!, $paths: [String!]) {
  snippets(ids: $ids) {
    __typename
    nodes {
      __typename
      id
      blobs(paths: $paths) {
        __typename
        nodes {
          __typename
          path
          richData @include(if: $rich)
          plainData @skip(if: $rich)
        }
        hasUnretrievableBlobs
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/snippet/snippet.query.graphql =====
query GetSnippetQuery($ids: [SnippetID!]) {
  snippets(ids: $ids) {
    __typename
    nodes {
      __typename
      id
      title
      description
      descriptionHtml
      createdAt
      updatedAt
      visibilityLevel
      webUrl
      httpUrlToRepo
      sshUrlToRepo
      hidden
      imported
      blobs {
        __typename
        hasUnretrievableBlobs
        nodes {
          __typename
          binary
          name
          path
          rawPath
          size
          externalStorage
          renderedAsText
          simpleViewer {
            __typename
            collapsed
            renderError
            tooLarge
            type
            fileType
          }
          richViewer {
            __typename
            collapsed
            renderError
            tooLarge
            type
            fileType
          }
        }
      }
      userPermissions {
        __typename
        adminSnippet
        updateSnippet
      }
      project {
        __typename
        id
        fullPath
        webUrl
        visibility
      }
      author {
        __typename
        id
        avatarUrl
        name
        username
        webUrl
        status {
          __typename
          emoji
          message
        }
      }
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/queries/snippet/user_permissions.query.graphql =====
query CanCreatePersonalSnippet {
  currentUser {
    __typename
    id
    userPermissions {
      __typename
      createSnippet
    }
  }
}


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/abuse_report_labels_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class AbuseReportLabelsResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    authorize :read_label

    type Types::AntiAbuse::AbuseReportLabelType.connection_type, null: true

    argument :search_term, GraphQL::Types::String,
      required: false,
      description: 'Search term to find labels with.'

    def resolve(**args)
      ::Admin::AbuseReportLabelsFinder.new(context[:current_user], args).execute
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/abuse_report_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class AbuseReportResolver < BaseResolver
    description 'Retrieve an abuse report'

    type Types::AbuseReportType, null: true

    argument :id, Types::GlobalIDType[AbuseReport], required: true, description: 'ID of the abuse report.'

    def resolve(id:)
      ::AbuseReport.find_by_id(extract_abuse_report_id(id))
    end

    private

    def extract_abuse_report_id(gid)
      GitlabSchema.parse_gid(gid, expected_type: ::AbuseReport).model_id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/achievements/achievements_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Achievements
    class AchievementsResolver < BaseResolver
      include LooksAhead

      type ::Types::Achievements::AchievementType.connection_type, null: true

      argument :ids, [::Types::GlobalIDType[::Achievements::Achievement]],
        required: false,
        description: 'Filter achievements by IDs.'

      alias_method :namespace, :object

      def resolve_with_lookahead(**args)
        return ::Achievements::Achievement.none if Feature.disabled?(:achievements, namespace)

        params = {}
        params[:ids] = args[:ids].map(&:model_id) if args[:ids].present?

        achievements = ::Achievements::AchievementsFinder.new(namespace, params).execute
        apply_lookahead(achievements)
      end

      private

      def preloads
        {
          user_achievements: [{ user_achievements: [:user, :awarded_by_user, :revoked_by_user] }]
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/achievements/user_achievements_for_user_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Achievements
    # rubocop:disable Graphql/ResolverType -- the type is inherited from the parent class
    class UserAchievementsForUserResolver < UserAchievementsResolver
      argument :include_hidden,
        GraphQL::Types::Boolean,
        required: false,
        default_value: false,
        description: 'Indicates whether or not achievements hidden from the profile should be included in the result.'

      def resolve_with_lookahead(include_hidden:)
        relation = super().order_by_priority_asc

        if include_hidden && current_user == object
          relation
        else
          relation.shown_on_profile
        end
      end
    end
    # rubocop:enable Graphql/ResolverType
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/achievements/user_achievements_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Achievements
    class UserAchievementsResolver < BaseResolver
      include LooksAhead

      type ::Types::Achievements::UserAchievementType.connection_type, null: true

      def resolve_with_lookahead
        user_achievements = object.user_achievements.not_revoked.order_by_id_asc

        apply_lookahead(user_achievements)
      end

      private

      def unconditional_includes
        [
          { achievement: [:namespace] }
        ]
      end

      def preloads
        {
          user: [:user],
          awarded_by_user: [:awarded_by_user],
          revoked_by_user: [:revoked_by_user]
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/admin/analytics/usage_trends/measurements_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Admin
    module Analytics
      module UsageTrends
        class MeasurementsResolver < BaseResolver
          include Gitlab::Graphql::Authorize::AuthorizeResource

          type Types::Admin::Analytics::UsageTrends::MeasurementType.connection_type, null: true

          argument :identifier, Types::Admin::Analytics::UsageTrends::MeasurementIdentifierEnum,
            required: true,
            description: 'Type of measurement or statistics to retrieve.'

          argument :recorded_after, Types::TimeType,
            required: false,
            description: 'Measurement recorded after the date.'

          argument :recorded_before, Types::TimeType,
            required: false,
            description: 'Measurement recorded before the date.'

          def resolve(identifier:, recorded_before: nil, recorded_after: nil)
            authorize!

            ::Analytics::UsageTrends::Measurement
              .recorded_after(recorded_after)
              .recorded_before(recorded_before)
              .with_identifier(identifier)
              .order_by_latest
          end

          private

          def authorize!
            admin? || raise_resource_not_available_error!
          end

          def admin?
            context[:current_user].present? && context[:current_user].admin?
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/alert_management/alert_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AlertManagement
    class AlertResolver < BaseResolver
      include LooksAhead

      argument :iid, GraphQL::Types::String,
        required: false,
        description: 'IID of the alert. For example, "1".'

      argument :statuses, [Types::AlertManagement::StatusEnum],
        as: :status,
        required: false,
        description: 'Alerts with the specified statues. For example, `[TRIGGERED]`.'

      argument :sort, Types::AlertManagement::AlertSortEnum,
        description: 'Sort alerts by the criteria.',
        required: false

      argument :domain, Types::AlertManagement::DomainFilterEnum,
        description: 'Filter query for given domain.',
        required: true,
        default_value: 'operations'

      argument :search, GraphQL::Types::String,
        description: 'Search query for title, description, service, or monitoring_tool.',
        required: false

      argument :assignee_username, GraphQL::Types::String,
        required: false,
        description: 'Username of a user assigned to the issue.'

      type Types::AlertManagement::AlertType, null: true

      def resolve_with_lookahead(**args)
        parent = object.respond_to?(:sync) ? object.sync : object
        return ::AlertManagement::Alert.none if parent.nil?

        raise GraphQL::ExecutionError, error_message if alert_is_disabled?

        apply_lookahead(::AlertManagement::AlertsFinder.new(context[:current_user], parent, args).execute)
      end

      def preloads
        {
          assignees: [:assignees],
          notes: [:ordered_notes, { ordered_notes: [:system_note_metadata, :project, :noteable] }],
          issue: [:issue]
        }
      end

      private

      def alert_is_disabled?
        Feature.enabled?(:hide_incident_management_features, object)
      end

      # This error is raised when the alert feature is disabled via feature flag.
      # Not yet a deprecated field, as the FF is disabled by default (see issue#537182).
      # If the FF is enabled in the future, we may need to consider deprecating this field.
      def error_message
        "Field 'alertManagementAlerts' doesn't exist on type 'Project'."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/alert_management/alert_status_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AlertManagement
    class AlertStatusCountsResolver < BaseResolver
      type Types::AlertManagement::AlertStatusCountsType, null: true

      argument :search, GraphQL::Types::String,
        description: 'Search query for title, description, service, or monitoring_tool.',
        required: false

      argument :assignee_username, GraphQL::Types::String,
        required: false,
        description: 'Username of a user assigned to the issue.'

      def resolve(**args)
        ::Gitlab::AlertManagement::AlertStatusCounts.new(context[:current_user], object, args)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/alert_management/http_integrations_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AlertManagement
    class HttpIntegrationsResolver < BaseResolver
      include ::Gitlab::Graphql::Laziness

      alias_method :project, :object

      argument :id, Types::GlobalIDType[::AlertManagement::HttpIntegration],
        required: false,
        description: 'ID of the integration.'

      argument :types, [Types::AlertManagement::IntegrationTypeEnum],
        as: :type_identifier,
        default_value: [:http],
        required: false,
        description: 'Types of integrations to return. Default is `[HTTP]`.'

      type Types::AlertManagement::HttpIntegrationType.connection_type, null: true

      def resolve(id: nil, **args)
        return [] unless Ability.allowed?(current_user, :admin_operations, project)

        if id
          integrations_by(gid: id, **args)
        else
          http_integrations(args)
        end
      end

      private

      def integrations_by(gid:, type_identifier: [])
        object = GitlabSchema.find_by_gid(gid)

        defer { object }.then do |integration|
          next [] if integration.nil?
          next [] if project != integration.project
          next [] if type_identifier&.any? && type_identifier.exclude?(integration.type_identifier.to_sym)

          [integration]
        end
      end

      def http_integrations(args)
        ::AlertManagement::HttpIntegrationsFinder.new(project, args).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/alert_management/integrations_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AlertManagement
    class IntegrationsResolver < BaseResolver
      include ::Gitlab::Graphql::Laziness

      alias_method :project, :object

      argument :id, ::Types::GlobalIDType,
        required: false,
        description: 'ID of the integration.'

      type Types::AlertManagement::IntegrationType.connection_type, null: true

      def resolve(id: nil)
        return [] unless Ability.allowed?(current_user, :admin_operations, project)

        if id
          integrations_by(gid: id)
        else
          http_integrations
        end
      end

      private

      def integrations_by(gid:)
        object = GitlabSchema.object_from_id(gid, expected_type: [
          ::AlertManagement::HttpIntegration,
          ::Integrations::Prometheus
        ])

        defer { object }.then do |integration|
          next [] unless integration&.project == project

          if integration.is_a?(::Integrations::Prometheus)
            project.alert_management_http_integrations
              .for_endpoint_identifier('legacy-prometheus').to_a
          else
            [integration]
          end
        end
      end

      def http_integrations
        ::AlertManagement::HttpIntegrationsFinder.new(project).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/base_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      class BaseCountResolver < BaseResolver
        type Types::Analytics::CycleAnalytics::MetricType, null: true

        argument :from, Types::TimeType,
          required: true,
          description: 'Timestamp marking the start date and time.'

        argument :to, Types::TimeType,
          required: true,
          description: 'Timestamp marking the end date and time.'

        def ready?(**args)
          start_date = args[:from]
          end_date = args[:to]

          if start_date >= end_date
            raise Gitlab::Graphql::Errors::ArgumentError,
              '`from` argument must be before `to` argument'
          end

          max_days = Gitlab::Analytics::CycleAnalytics::RequestParams::MAX_RANGE_DAYS

          if (end_date.beginning_of_day - start_date.beginning_of_day) > max_days
            raise Gitlab::Graphql::Errors::ArgumentError,
              "Max of #{max_days.inspect} timespan is allowed"
          end

          super
        end

        # :project level: no customization, returning the original resolver
        # :group level: add the project_ids argument
        def self.[](context = :project)
          case context
          when :project
            self
          when :group
            Class.new(self) do
              argument :project_ids, [GraphQL::Types::ID],
                required: false,
                description: 'Project IDs within the group hierarchy.'

              define_method :finder_params do
                { group_id: object.id, include_subgroups: true }
              end
            end
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/base_issue_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      class BaseIssueResolver < BaseCountResolver
        type Types::Analytics::CycleAnalytics::MetricType, null: true

        argument :assignee_usernames, [GraphQL::Types::String],
          required: false,
          description: 'Usernames of users assigned to the issue.'

        argument :author_username, GraphQL::Types::String,
          required: false,
          description: 'Username of the author of the issue.'

        argument :milestone_title, GraphQL::Types::String,
          required: false,
          description: 'Milestone applied to the issue.'

        argument :label_names, [GraphQL::Types::String],
          required: false,
          description: 'Labels applied to the issue.'

        def finder_params
          { project_id: object.project.id }
        end
      end
    end
  end
end

Resolvers::Analytics::CycleAnalytics::BaseIssueResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/base_merge_request_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      class BaseMergeRequestResolver < BaseCountResolver
        type Types::Analytics::CycleAnalytics::MetricType, null: true

        argument :assignee_usernames, [GraphQL::Types::String],
          required: false,
          description: 'Usernames of users assigned to the merge request.'

        argument :author_username, GraphQL::Types::String,
          required: false,
          description: 'Username of the author of the merge request.'

        argument :milestone_title, GraphQL::Types::String,
          required: false,
          description: 'Milestone applied to the merge request.'

        argument :label_names, [GraphQL::Types::String],
          required: false,
          description: 'Labels applied to the merge request.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/deployment_count_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from Resolvers::Analytics::CycleAnalytics::BaseCountResolver
module Resolvers
  module Analytics
    module CycleAnalytics
      class DeploymentCountResolver < BaseCountResolver
        def resolve(**args)
          value = count(args)
          {
            value: value,
            title: n_('Deploy', 'Deploys', value.to_i),
            identifier: 'deploys',
            links: []
          }
        end

        private

        def count(args)
          finder = DeploymentsFinder.new({
            finished_after: args[:from],
            finished_before: args[:to],
            project: object.project,
            status: :success,
            order_by: :finished_at
          })

          finder.execute.count
        end
      end
    end
  end
end
# rubocop:enable Graphql/ResolverType

mod = Resolvers::Analytics::CycleAnalytics::DeploymentCountResolver
mod.prepend_mod_with('Resolvers::Analytics::CycleAnalytics::DeploymentCountResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/issue_count_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from Resolvers::Analytics::CycleAnalytics::BaseIssueResolver
module Resolvers
  module Analytics
    module CycleAnalytics
      class IssueCountResolver < BaseIssueResolver
        def resolve(**args)
          value = IssuesFinder
            .new(current_user, process_params(args))
            .execute
            .count

          {
            value: value,
            title: n_('New issue', 'New issues', value),
            identifier: 'issues',
            links: []
          }
        end

        private

        def process_params(params)
          assignees_value = params.delete(:assignee_usernames)
          params[:assignee_username] = assignees_value if assignees_value.present?
          params[:label_name] = params.delete(:label_names) if params[:label_names]
          params[:created_after] = params.delete(:from)
          params[:created_before] = params.delete(:to)
          params[:projects] = params[:project_ids] if params[:project_ids]

          params.merge(finder_params)
        end
      end
    end
  end
end
# rubocop:enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/stages_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      class StagesResolver < BaseResolver
        type [Types::Analytics::CycleAnalytics::ValueStreams::StageType], null: true

        argument :id, ID, required: false, description: 'Value stream stage id.'

        def resolve(id: nil)
          list_stages(stage_params(id: id).merge(value_stream: object))
        end

        private

        def list_stages(list_service_params)
          ::Analytics::CycleAnalytics::Stages::ListService.new(
            parent: namespace,
            current_user: current_user,
            params: list_service_params
          ).execute[:stages]
        end

        def namespace
          object.project.project_namespace
        end

        def stage_params(id: nil)
          list_params = {}
          list_params[:stage_ids] = [::GitlabSchema.parse_gid(id).model_id] if id
          list_params
        end
      end
    end
  end
end

Resolvers::Analytics::CycleAnalytics::StagesResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/value_streams_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      class ValueStreamsResolver < BaseResolver
        type Types::Analytics::CycleAnalytics::ValueStreamType.connection_type, null: true

        argument :id, ID, required: false, description: 'Value stream id.'

        # ignore id in FOSS
        def resolve(id: nil)
          ::Analytics::CycleAnalytics::ValueStreams::ListService
            .new(**service_params(id: id))
            .execute
            .payload[:value_streams]
        end

        private

        def service_params(*)
          { parent: object.project_namespace, current_user: current_user, params: {} }
        end
      end
    end
  end
end

Resolvers::Analytics::CycleAnalytics::ValueStreamsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/value_streams/stage_items_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      module ValueStreams
        class StageItemsResolver < BaseResolver
          type ::Types::Analytics::CycleAnalytics::ValueStreams::StageItemsType.connection_type, null: true

          argument :sort,
            Types::Analytics::CycleAnalytics::ValueStreams::StageItemsSortEnum,
            description: 'Sort stage items by criteria.',
            required: false

          # Limit page size to the same value of RecordsFetcher to avoid slow queries
          max_page_size Gitlab::Analytics::CycleAnalytics::Aggregated::RecordsFetcher::MAX_RECORDS

          def resolve(sort: {})
            stage = object.stage
            params = object.params.merge(sort)

            # Create a new data collector with additional sort parameters
            data_collector =
              Gitlab::Analytics::CycleAnalytics::DataCollector.new(stage: stage, params: params)

            offset_pagination(data_collector.records_for_graphql)
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/analytics/cycle_analytics/value_streams/stage_metrics_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Analytics
    module CycleAnalytics
      module ValueStreams
        class StageMetricsResolver < BaseResolver
          type ::Types::Analytics::CycleAnalytics::ValueStreams::StageMetricsType, null: true

          argument :timeframe, Types::TimeframeInputType,
            required: true,
            description: 'Aggregation timeframe. Filters the issue or the merge request creation time for FOSS ' \
              'projects, and the end event timestamp for licensed projects or groups.'

          argument :assignee_usernames, [GraphQL::Types::String],
            required: false,
            description: 'Usernames of users assigned to the issue or the merge request.'

          argument :author_username, GraphQL::Types::String,
            required: false,
            description: 'Username of the author of the issue or the merge request.'

          argument :milestone_title, GraphQL::Types::String,
            required: false,
            description: 'Milestone applied to the issue or the merge request.'

          argument :label_names, [GraphQL::Types::String],
            required: false,
            description: 'Labels applied to the issue or the merge request.'

          def resolve(**args)
            Gitlab::Analytics::CycleAnalytics::DataCollector.new(stage: object,
              params: transform_params(args, object).to_data_collector_params)
          end

          private

          def transform_params(args, _stage)
            formatted_args = args.to_hash
            timeframe = args.delete(:timeframe)
            formatted_args[:created_after] = timeframe[:start]
            formatted_args[:created_before] = timeframe[:end]

            if formatted_args[:assignee_usernames].present?
              formatted_args[:assignee_username] =
                formatted_args.delete(:assignee_usernames)
            end

            formatted_args[:label_name] = formatted_args.delete(:label_names) if formatted_args[:label_names].present?

            Gitlab::Analytics::CycleAnalytics::RequestParams.new(
              namespace: object.namespace,
              current_user: current_user,
              **formatted_args.compact
            )
          end
        end
      end
    end
  end
end

Resolvers::Analytics::CycleAnalytics::ValueStreams::StageMetricsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/app_config/gitlab_instance_feature_flags_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AppConfig
    class GitlabInstanceFeatureFlagsResolver < BaseResolver
      # note: Set an arbitrary limit to avoid performance issues
      MAX_FEATURE_FLAG_NAMES = 20

      type [::Types::AppConfig::GitlabInstanceFeatureFlagType], null: false
      requires_argument!

      argument :names, [GraphQL::Types::String],
        required: true,
        description: "Names of the feature flags to lookup (maximum of #{MAX_FEATURE_FLAG_NAMES}).",
        validates: { length: { maximum: MAX_FEATURE_FLAG_NAMES } }

      def resolve(names:)
        return [] if names.empty?

        features = Feature.preload(names) # rubocop: disable CodeReuse/ActiveRecord -- Not an ActiveRecord method

        features
          .filter { |feature| Feature::Definition.has_definition?(feature.name) }
          .map { |feature| { name: feature.name, enabled: Feature.enabled?(feature.name, current_user) } }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/app_config/instance_metadata_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AppConfig
    class InstanceMetadataResolver < BaseResolver
      type Types::AppConfig::InstanceMetadataType, null: false

      def resolve(**_args)
        ::AppConfig::InstanceMetadata.new
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/assigned_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class AssignedMergeRequestsResolver < UserMergeRequestsResolverBase
    type ::Types::MergeRequestType.connection_type, null: true
    accept_author
    accept_reviewer

    def user_role
      :assignee
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/audit_events/audit_event_definitions_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AuditEvents
    class AuditEventDefinitionsResolver < BaseResolver
      type [Types::AuditEvents::DefinitionType], null: false

      def resolve
        Gitlab::Audit::Type::Definition.definitions.values
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/authored_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class AuthoredMergeRequestsResolver < UserMergeRequestsResolverBase
    type ::Types::MergeRequestType.connection_type, null: true
    accept_assignee
    accept_reviewer

    argument :include_assigned, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: "Include merge requests the user is assigned to."

    def user_role
      :author
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/autocomplete_users_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class AutocompleteUsersResolver < BaseResolver
    type [::Types::Users::AutocompletedUserType], null: true

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Query to search users by name, username, or public email.'

    def resolve(search: nil)
      ::Autocomplete::UsersFinder.new(
        current_user: context[:current_user],
        project: project,
        group: group,
        params: {
          search: search
        }
      ).execute
    end

    private

    def project
      object if object.is_a?(Project)
    end

    def group
      object if object.is_a?(Group)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/award_emoji/base_votes_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module AwardEmoji
    class BaseVotesCountResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type GraphQL::Types::Int, null: true

      private

      def authorized_resource?(object)
        Ability.allowed?(current_user, :"read_#{object.to_ability_name}", object)
      end

      def votes_batch_loader
        BatchLoaders::AwardEmojiVotesBatchLoader
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/base_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BaseResolver < GraphQL::Schema::Resolver
    extend ::Gitlab::Utils::Override
    include ::Gitlab::Utils::StrongMemoize
    include Gitlab::Graphql::Authorize::AuthorizeResource

    argument_class ::Types::BaseArgument

    def self.requires_argument!
      @requires_argument = true
    end

    def self.requires_argument?
      !!@requires_argument
    end

    def self.calls_gitaly!
      @calls_gitaly = true
    end

    def self.calls_gitaly?
      !!@calls_gitaly
    end

    # This is a flag to allow us to use `complexity_multiplier` to compute complexity for connection
    # fields(see BaseField#connection_complexity_multiplier) in resolvers that do external connection pagination,
    # thus disabling the default `connection` option.
    def self.calculate_ext_conn_complexity
      false
    end

    def self.singular_type
      return unless type

      unwrapped = type.unwrap

      %i[node_type relay_node_type of_type itself].reduce(nil) do |t, m|
        t || unwrapped.try(m)
      end
    end

    def self.when_single(&block)
      as_single << block

      # Have we been called after defining the single version of this resolver?
      @single.instance_exec(&block) if @single.present?
    end

    def self.as_single
      @as_single ||= []
    end

    def self.single_definition_blocks
      ancestors.flat_map { |klass| klass.try(:as_single) || [] }
    end

    def self.single
      @single ||= begin
        parent = self
        klass = Class.new(self) do
          type parent.singular_type, null: true

          def ready?(**args)
            value = super

            if value.is_a?(Array)
              [value[0], select_result(value[1])]
            else
              value
            end
          end

          def resolve(**args)
            select_result(super)
          end

          def single?
            true
          end

          def select_result(results)
            results&.first
          end

          define_singleton_method :to_s do
            "#{parent}.single"
          end
        end

        single_definition_blocks.each do |definition|
          klass.instance_exec(&definition)
        end

        klass
      end
    end

    def self.last
      parent = self
      @last ||= Class.new(single) do
        type parent.singular_type, null: true

        def select_result(results)
          results&.last
        end

        define_singleton_method :to_s do
          "#{parent}.last"
        end
      end
    end

    def self.complexity
      0
    end

    def self.resolver_complexity(args, child_complexity:)
      complexity = 1
      complexity += 1 if args[:sort]
      complexity += 5 if args[:search]

      complexity
    end

    def self.complexity_multiplier(args)
      # When fetching many items, additional complexity is added to the field
      # depending on how many items is fetched. For each item we add 1% of the
      # original complexity - this means that loading 100 items (our default
      # max_page_size limit) doubles the original complexity.
      #
      # Complexity is not increased when searching by specific ID(s), because
      # complexity difference is minimal in this case.
      [args[:iid], args[:iids]].any? ? 0 : 0.01
    end

    def self.before_connection_authorization(&block)
      @before_connection_authorization_block = block
    end

    # rubocop: disable Style/TrivialAccessors
    def self.before_connection_authorization_block
      @before_connection_authorization_block
    end
    # rubocop: enable Style/TrivialAccessors

    def offset_pagination(relation)
      ::Gitlab::Graphql::Pagination::OffsetPaginatedRelation.new(relation)
    end

    override :object
    def object
      super.tap do |obj|
        # If the field this resolver is used in is wrapped in a presenter, unwrap its subject
        break obj.__subject__ if obj.is_a?(Gitlab::View::Presenter::Base)
      end
    end

    def single?
      false
    end

    def current_user
      context[:current_user]
    end

    # Overridden in sub-classes (see .single, .last)
    def select_result(results)
      results
    end

    def self.authorization
      @authorization ||= ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(try(:required_permissions))
    end

    def self.authorized?(object, context)
      authorization.ok?(object, context[:current_user], scope_validator: context[:scope_validator])
    end

    private

    def current_organization
      context[:current_organization]
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/blame_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BlameResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::Blame::BlameType, null: true
    calls_gitaly!

    argument :from_line, GraphQL::Types::Int,
      required: false,
      default_value: 1,
      description: 'Range starting from the line. Cannot be less than 1 or greater than `to_line`.'
    argument :to_line, GraphQL::Types::Int,
      required: false,
      default_value: 1,
      description: 'Range ending on the line. Cannot be smaller than `from_line` or greater than `from_line` + 100.'

    alias_method :blob, :object

    def ready?(**args)
      validate_line_params!(args)

      super
    end

    def resolve(from_line:, to_line:)
      authorize!

      Gitlab::Blame.new(blob, blob.repository.commit(blob.commit_id),
        range: (from_line..to_line))
    end

    private

    def authorize!
      read_code? || raise_resource_not_available_error!
    end

    def read_code?
      Ability.allowed?(current_user, :read_code, blob.repository.project)
    end

    def validate_line_params!(args)
      raise_greater_than_one unless args[:from_line] >= 1
      raise_greater_than_one unless args[:to_line] >= 1

      return unless args[:to_line] < args[:from_line] || args[:to_line] >= args[:from_line] + 100

      raise Gitlab::Graphql::Errors::ArgumentError,
        '`to_line` must be greater than or equal to `from_line` and smaller than `from_line` + 100'
    end

    def raise_greater_than_one
      raise Gitlab::Graphql::Errors::ArgumentError,
        '`from_line` and `to_line` must be greater than or equal to 1'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/blobs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BlobsResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::Tree::BlobType.connection_type, null: true
    authorize :read_code
    calls_gitaly!

    alias_method :repository, :object

    argument :paths, [GraphQL::Types::String],
      required: true,
      description: 'Array of desired blob paths.'
    argument :ref, GraphQL::Types::String,
      required: false,
      default_value: nil,
      description: 'Commit ref to get the blobs from. Default value is HEAD.'
    argument :ref_type, Types::RefTypeEnum,
      required: false,
      default_value: nil,
      description: 'Type of ref.'

    # We fetch blobs from Gitaly efficiently but it still scales O(N) with the
    # number of paths being fetched, so apply a scaling limit to that.
    def self.resolver_complexity(args, child_complexity:)
      super + (args[:paths] || []).size
    end

    def resolve(paths:, ref:, ref_type:)
      authorize!(repository.container)

      return [] if repository.empty?

      ref ||= repository.root_ref
      validate_ref(ref)

      ref = ExtractsRef::RefExtractor.qualify_ref(ref, ref_type)

      repository.blobs_at(paths.map { |path| [ref, path] }).tap do |blobs|
        blobs.each do |blob|
          blob.ref_type = ref_type
        end
      end
    end

    private

    def validate_ref(ref)
      return if Gitlab::GitRefValidator.validate(ref, skip_head_ref_check: true)

      raise Gitlab::Graphql::Errors::ArgumentError, 'Ref is not valid'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/board_list_issues_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BoardListIssuesResolver < BaseResolver
    prepend ::Issues::LookAheadPreloads
    include BoardItemFilterable

    argument :filters, Types::Boards::BoardIssueInputType,
      required: false,
      description: 'Filters applied when selecting issues in the board list.'

    type Types::IssueType, null: true

    alias_method :list, :object

    def resolve_with_lookahead(**args)
      filters = item_filters(args[:filters])
      mutually_exclusive_milestone_args!(filters)

      filter_params = filters.merge(board_id: list.board.id, id: list.id)
      service = ::Boards::Issues::ListService.new(list.board.resource_parent, context[:current_user], filter_params)

      apply_lookahead(service.execute)
    end

    # https://gitlab.com/gitlab-org/gitlab/-/issues/235681
    def self.complexity_multiplier(args)
      0.005
    end

    private

    def mutually_exclusive_milestone_args!(filters)
      if filters[:milestone_title] && filters[:milestone_wildcard_id]
        raise ::Gitlab::Graphql::Errors::ArgumentError, 'Incompatible arguments: milestoneTitle, milestoneWildcardId.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/board_list_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BoardListResolver < BaseResolver.single
    include Gitlab::Graphql::Authorize::AuthorizeResource
    include BoardItemFilterable

    type Types::BoardListType, null: true
    description 'Find an issue board list.'

    authorize :read_issue_board_list

    argument :id, Types::GlobalIDType[List],
      required: true,
      description: 'Global ID of the list.'

    argument :issue_filters, Types::Boards::BoardIssueInputType,
      required: false,
      description: 'Filters applied when getting issue metadata in the board list.'

    def resolve(id: nil, issue_filters: {})
      Gitlab::Graphql::Lazy.with_value(find_list(id: id)) do |list|
        context.scoped_set!(:issue_filters, item_filters(issue_filters))
        list if authorized_resource?(list)
      end
    end

    private

    def find_list(id:)
      GitlabSchema.object_from_id(id, expected_type: ::List)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/board_lists_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BoardListsResolver < BaseResolver
    include BoardItemFilterable
    include Gitlab::Graphql::Authorize::AuthorizeResource
    include LooksAhead

    type Types::BoardListType, null: true
    authorize :read_issue_board_list
    authorizes_object!

    argument :id, Types::GlobalIDType[List],
      required: false,
      description: 'Find a list by its global ID.'

    argument :issue_filters, Types::Boards::BoardIssueInputType,
      required: false,
      description: 'Filters applied when getting issue metadata in the board list.'

    alias_method :board, :object

    def self.complexity_multiplier(args) # rubocop:disable Lint/UnusedMethodArgument -- Leaving `args` to match the expected schema method definition and avoid method lookup issues in the test environment
      0.005
    end

    def resolve_with_lookahead(id: nil, issue_filters: {})
      lists = board_lists(id)
      context.scoped_set!(:issue_filters, item_filters(issue_filters))

      List.preload_preferences_for_user(lists, current_user) if load_preferences?

      offset_pagination(lists)
    end

    private

    def board_lists(id)
      service = ::Boards::Lists::ListService.new(
        board.resource_parent,
        current_user,
        list_id: extract_list_id(id)
      )

      service.execute(board, create_default_lists: false)
    end

    def load_preferences?
      node_selection&.selects?(:collapsed)
    end

    def extract_list_id(gid)
      return unless gid.present?

      GitlabSchema.parse_gid(gid, expected_type: ::List).model_id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/board_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BoardResolver < BaseResolver.single
    alias_method :parent, :object

    type Types::BoardType, null: true

    argument :id, ::Types::GlobalIDType[::Board],
      required: true,
      description: 'ID of the board.'

    def resolve(id: nil)
      return unless parent

      ::Boards::BoardsFinder.new(parent, context[:current_user], board_id: extract_board_id(id)).execute.first
    rescue ActiveRecord::RecordNotFound
      nil
    end

    private

    def extract_board_id(gid)
      GitlabSchema.parse_gid(gid, expected_type: ::Board).model_id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/boards_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BoardsResolver < BaseResolver
    type Types::BoardType, null: true

    argument :id, ::Types::GlobalIDType[::Board],
      required: false,
      description: 'Find a board by its ID.'

    def resolve(id: nil)
      # The project or group could have been loaded in batch by `BatchLoader`.
      # At this point we need the `id` of the project/group to query for boards, so
      # make sure it's loaded and not `nil` before continuing.
      parent = object.respond_to?(:sync) ? object.sync : object

      return Board.none unless parent

      ::Boards::BoardsFinder.new(parent, context[:current_user], board_id: extract_board_id(id)).execute
    rescue ActiveRecord::RecordNotFound
      Board.none
    end

    private

    def extract_board_id(id)
      return unless id.present?

      id.model_id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/bulk_labels_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class BulkLabelsResolver < BaseResolver
    type Types::LabelType.connection_type, null: true

    def resolve
      bulk_load_labels
    end

    def object
      case super
      when ::WorkItems::Widgets::Base
        super.work_item
      else
        super
      end
    end

    private

    def bulk_load_labels
      BatchLoader::GraphQL.for(object.id).batch(key: object.class.name, cache: false) do |ids, loader, args|
        labels = Label.for_targets(object.class.id_in(ids)).group_by(&:target_id)

        ids.each do |id|
          loader.call(id, labels[id] || [])
        end
      end
    end
  end
end

Resolvers::BulkLabelsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/all_jobs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class AllJobsResolver < BaseResolver
      include LooksAhead

      COMPATIBLE_RUNNER_ERROR_MESSAGE =
        'compatibleRunnerId can only be used when the `statuses` argument is set to "PENDING"'

      type ::Types::Ci::JobInterface.connection_type, null: true

      argument :statuses, [::Types::Ci::JobStatusEnum],
        required: false,
        description: 'Filter jobs by status.'

      argument :runner_types, [::Types::Ci::RunnerTypeEnum],
        required: false,
        experiment: { milestone: '16.4' },
        description: 'Filter jobs by runner type if ' \
          'feature flag `:admin_jobs_filter_runner_type` is enabled.'

      argument :compatible_runner_id, ::Types::GlobalIDType[::Ci::Runner],
        required: false,
        experiment: { milestone: '18.1' },
        description: 'ID of a runner that matches the requirements of the jobs returned ' \
          '(normally used when filtering pending jobs).'

      def ready?(**args)
        if args.key?(:compatible_runner_id) && args[:statuses] != %w[pending]
          raise Gitlab::Graphql::Errors::ArgumentError, COMPATIBLE_RUNNER_ERROR_MESSAGE
        end

        super
      end

      def resolve_with_lookahead(**args)
        jobs = ::Ci::JobsFinder.new(current_user: current_user, **runner_args(args), params: params_data(args)).execute

        apply_lookahead(jobs)
      end

      private

      def params_data(args)
        {
          scope: args[:statuses],
          runner_type: args[:runner_types],
          match_compatible_runner_only: args[:compatible_runner_id].present?
        }
      end

      def runner_args(args)
        return {} unless args.key?(:compatible_runner_id)

        { runner: GitlabSchema.object_from_id(args[:compatible_runner_id], expected_type: ::Ci::Runner).sync }
      end

      def preloads
        {
          previous_stage_jobs_or_needs: [:needs, :pipeline],
          artifacts: [:job_artifacts],
          pipeline: [:user],
          kind: [:metadata, :job_definition],
          retryable: [:metadata, :job_definition],
          project: [{ project: [:route, { namespace: [:route] }] }],
          commit_path: [:pipeline, { project: { namespace: [:route] } }],
          ref_path: [{ project: [:route, { namespace: [:route] }] }],
          browse_artifacts_path: [{ project: { namespace: [:route] } }],
          play_path: [{ project: { namespace: [:route] } }],
          web_path: [{ project: { namespace: [:route] } }],
          tags: [:tags],
          trace: [{ project: [:namespace] }, :job_artifacts_trace],
          source: [:build_source]
        }
      end

      def nested_preloads
        super.merge({
          trace: {
            html_summary: [:trace_chunks]
          }
        })
      end

      # Overridden in EE
      def unconditional_includes
        []
      end
    end
  end
end

Resolvers::Ci::AllJobsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/catalog/resource_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    module Catalog
      class ResourceResolver < BaseResolver
        include Gitlab::Graphql::Authorize::AuthorizeResource

        type ::Types::Ci::Catalog::ResourceType, null: true

        argument :id, ::Types::GlobalIDType[::Ci::Catalog::Resource],
          required: false,
          description: 'CI/CD Catalog resource global ID.'

        argument :full_path, GraphQL::Types::ID,
          required: false,
          description: 'CI/CD Catalog resource full path.'

        def ready?(**args)
          unless args[:id].present? ^ args[:full_path].present?
            raise Gitlab::Graphql::Errors::ArgumentError,
              "Exactly one of 'id' or 'full_path' arguments is required."
          end

          super
        end

        def resolve(id: nil, full_path: nil)
          catalog_resource = if full_path.present?
                               ::Ci::Catalog::Listing.new(current_user).find_resource(full_path: full_path)
                             else
                               ::Ci::Catalog::Listing.new(current_user).find_resource(id: id.model_id)
                             end

          raise_resource_not_available_error! unless catalog_resource

          catalog_resource
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/catalog/resources_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    module Catalog
      class ResourcesResolver < BaseResolver
        include LooksAhead

        type ::Types::Ci::Catalog::ResourceType.connection_type, null: true

        argument :scope, ::Types::Ci::Catalog::ResourceScopeEnum,
          required: false,
          default_value: :all,
          description: 'Scope of the returned catalog resources.'

        argument :search, GraphQL::Types::String,
          required: false,
          description: 'Search term to filter the catalog resources by name or description.'

        argument :sort, ::Types::Ci::Catalog::ResourceSortEnum,
          required: false,
          description: 'Sort catalog resources by given criteria.'

        argument :verification_level, ::Types::Ci::Catalog::Resources::VerificationLevelEnum,
          required: false,
          description: 'Filter catalog resources by verification level.'

        argument :topics, [GraphQL::Types::String],
          required: false,
          description: 'Filter catalog resources by project topic names.'

        def resolve_with_lookahead(scope:, search: nil, sort: nil, verification_level: nil, topics: nil)
          apply_lookahead(
            ::Ci::Catalog::Listing
              .new(context[:current_user])
              .resources(
                sort: sort,
                search: search,
                scope: scope,
                verification_level: verification_level,
                topics: topics
              )
          )
        end

        private

        def preloads
          {
            full_path: { project: [:route, { namespace: :route }] },
            web_path: { project: { namespace: :route } },
            readme_html: { project: :route }
          }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/catalog/resources/versions_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    module Catalog
      module Resources
        class VersionsResolver < BaseResolver
          type Types::Ci::Catalog::Resources::VersionType.connection_type, null: true

          argument :name, GraphQL::Types::String,
            required: false,
            description: 'Name of the version.'

          alias_method :catalog_resource, :object

          def resolve(name: nil)
            if name
              ::Ci::Catalog::Resources::Version.for_catalog_resources(catalog_resource).by_name(name)
            else
              fetch_catalog_resources_versions
            end
          end

          private

          def fetch_catalog_resources_versions
            BatchLoader::GraphQL.for(catalog_resource).batch(default_value: []) do |catalog_resources, loader|
              versions = ::Ci::Catalog::Resources::Version.versions_for_catalog_resources(catalog_resources)

              versions.group_by(&:catalog_resource).each do |catalog_resource, resource_versions|
                loader.call(catalog_resource, resource_versions)
              end
            end
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/config_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class ConfigResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include ResolvesProject

      type Types::Ci::LegacyConfig::ConfigType, null: true
      description <<~MD
        Linted and processed contents of a CI config.
        Should not be requested more than once per request.
      MD

      authorize :create_pipeline

      argument :project_path, GraphQL::Types::ID,
        required: true,
        description: 'Project of the CI config.'

      argument :sha, GraphQL::Types::String,
        required: false,
        description: "Sha for the pipeline."

      argument :content, GraphQL::Types::String,
        required: true,
        description: "Contents of `.gitlab-ci.yml`."

      argument :dry_run, GraphQL::Types::Boolean,
        required: false,
        description: 'Run pipeline creation simulation, or only do static check.'

      argument :skip_verify_project_sha, GraphQL::Types::Boolean,
        required: false,
        experiment: { milestone: '16.5' },
        description: "If the provided `sha` is found in the project's repository but is not " \
          "associated with a Git reference (a detached commit), the verification fails and a " \
          "validation error is returned. Otherwise, verification passes, even if the `sha` is " \
          "invalid. Set to `true` to skip this verification process."

      def resolve(project_path:, content:, sha: nil, dry_run: false, skip_verify_project_sha: false)
        project = authorized_find!(project_path: project_path)

        result = ::Gitlab::Ci::Lint
          .new(project: project, current_user: context[:current_user], sha: sha,
            verify_project_sha: !skip_verify_project_sha)
          .legacy_validate(content, dry_run: dry_run)

        response(result)
      rescue GRPC::InvalidArgument => e
        Gitlab::ErrorTracking.track_and_raise_exception(e, sha: sha)
      end

      private

      def response(result)
        {
          status: result.status,
          errors: result.errors,
          warnings: result.warnings,
          stages: make_stages(result),
          merged_yaml: result.merged_yaml,
          includes: result.includes
        }
      end

      def make_jobs(config_jobs)
        config_jobs.map do |job|
          {
            name: job[:name],
            stage: job[:stage],
            group_name: CommitStatus.new(name: job[:name]).group_name,
            needs: job[:needs] || [],
            allow_failure: job[:allow_failure],
            before_script: job[:before_script],
            script: job[:script],
            after_script: job[:after_script],
            only: job[:only],
            except: job[:except],
            when: job[:when],
            tags: job[:tag_list],
            environment: job[:environment]
          }
        end
      end

      def make_groups(job_data)
        jobs = make_jobs(job_data)

        jobs_by_group = jobs.group_by { |job| job[:group_name] }
        jobs_by_group.map do |name, jobs|
          { jobs: jobs, name: name, stage: jobs.first[:stage], size: jobs.size }
        end
      end

      def make_stages(result)
        return [] unless result.valid?

        make_groups(result.jobs)
          .group_by { |group| group[:stage] }
          .map { |name, groups| { name: name, groups: groups } }
      end

      def find_object(project_path:)
        resolve_project(full_path: project_path)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/group_runners_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class GroupRunnersResolver < RunnersResolver
      type Types::Ci::RunnerType.connection_type, null: true

      argument :membership, ::Types::Ci::RunnerMembershipFilterEnum,
        required: false,
        default_value: :descendants,
        description: 'Control which runners to include in the results.'

      protected

      def runners_finder_params(params)
        super.merge(membership: params[:membership])
      end

      def parent_param
        raise 'Expected group missing' unless parent.is_a?(Group)

        { group: parent }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/inherited_variables_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class InheritedVariablesResolver < BaseResolver
      type Types::Ci::ProjectVariableType.connection_type, null: true

      argument :sort, Types::Ci::GroupVariablesSortEnum,
        required: false, default_value: :created_desc,
        description: 'Sort variables by the criteria.'

      def resolve(sort:)
        ::Ci::GroupVariablesFinder.new(object, sort).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/jobs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class JobsResolver < BaseResolver
      alias_method :pipeline, :object

      type ::Types::Ci::JobType.connection_type, null: true

      argument :job_kind, ::Types::Ci::JobKindEnum,
        required: false,
        description: 'Filter jobs by kind.'

      argument :retried, ::GraphQL::Types::Boolean,
        required: false,
        description: 'Filter jobs by retry-status.'

      argument :security_report_types, [Types::Security::ReportTypeEnum],
        required: false,
        description: 'Filter jobs by the type of security report they produce.'

      argument :statuses, [::Types::Ci::JobStatusEnum],
        required: false,
        description: 'Filter jobs by status.'

      argument :when_executed, [::GraphQL::Types::String],
        required: false,
        description: 'Filter jobs by when they are executed.'

      def resolve(
        job_kind: nil,
        retried: nil,
        security_report_types: [],
        statuses: nil,
        when_executed: nil)
        jobs = init_collection(security_report_types)
        jobs = jobs.latest if retried == false
        jobs = jobs.retried if retried
        jobs = jobs.with_status(statuses) if statuses.present?
        jobs = jobs.with_type(job_kind) if job_kind
        jobs = jobs.with_when_executed(when_executed) if when_executed.present?

        jobs
      end

      def init_collection(security_report_types)
        if security_report_types.present?
          ::Security::SecurityJobsFinder.new(
            pipeline: pipeline,
            job_types: security_report_types
          ).execute
        else
          pipeline.statuses_order_id_desc
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/job_token_auth_logs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class JobTokenAuthLogsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include LooksAhead

      authorize :admin_project
      type ::Types::Ci::JobTokenAuthLogType, null: true

      extras [:lookahead]

      def resolve_with_lookahead(**_args)
        authorize!(object)

        authorizations = ::Ci::JobToken::Authorization
          .for_project(object)
          .with_existing_origin_projects

        apply_lookahead(authorizations)
      end

      private

      def preloads
        {
          origin_project: [:origin_project]
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/job_token_scope_allowlist_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class JobTokenScopeAllowlistResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :admin_project

      type ::Types::Ci::JobTokenScope::AllowlistType, null: true

      alias_method :source_project, :object

      def resolve(**_args)
        authorize!(source_project)

        groups_allowlist = ::Ci::JobToken::GroupScopeLink.with_source(source_project)
        projects_allowlist = ::Ci::JobToken::ProjectScopeLink.with_source(source_project)

        {
          groups_allowlist: groups_allowlist,
          projects_allowlist: projects_allowlist
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/job_token_scope_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    # TODO: remove in 18.0, after https://gitlab.com/gitlab-org/govern/authorization/team-tasks/-/issues/87 is resolved
    class JobTokenScopeResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :admin_project
      description 'Container for resources that can be accessed by a CI job token from the current project.'
      type ::Types::Ci::JobTokenScopeType, null: true

      def resolve
        authorize!(object)

        ::Ci::JobToken::Scope.new(object)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/pipeline_analytics_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class PipelineAnalyticsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Ci::AnalyticsType, null: true

      authorizes_object!
      authorize :read_ci_cd_analytics
      extras [:lookahead]

      alias_method :container, :object

      argument :source, Types::Ci::PipelineSourcesEnum,
        required: false,
        description: 'Source of the pipeline.'

      argument :ref, GraphQL::Types::String,
        required: false,
        description: 'Branch that triggered the pipeline.'

      argument :from_time, Types::TimeType,
        required: false,
        description:
          'Start of the requested time (in UTC). Defaults to the pipelines started in the past week.'

      argument :to_time, Types::TimeType,
        required: false,
        description:
          'End of the requested time (in UTC). Defaults to the pipelines started before the current date.'

      def resolve(lookahead:, source: nil, ref: nil, from_time: nil, to_time: nil)
        period = lookahead.selection(:time_series)&.arguments&.fetch(:period)
        base_service_args = {
          current_user: context[:current_user], container: container,
          source: source, ref: ref,
          from_time: from_time, to_time: to_time
        }

        legacy_fields(lookahead).then do |result|
          result.merge(
            call_service(base_service_args, lookahead, :aggregate, ::Ci::CollectAggregatePipelineAnalyticsService),
            call_service(
              base_service_args.merge(time_series_period: period), lookahead, :time_series,
              ::Ci::CollectTimeSeriesPipelineAnalyticsService
            )
          )
        end
      end

      private

      def call_service(base_service_args, lookahead, field, service)
        return {} unless any_field_selected?(lookahead, field)

        field_lookahead = lookahead&.selection(field)
        response = service.new(
          **base_service_args,
          status_groups: selected_status_groups(field_lookahead),
          duration_percentiles: selected_duration_percentiles(field_lookahead)
        ).execute

        raise_resource_not_available_error! response.message if response.error?

        { field => response.payload[field] }
      end

      def legacy_fields(lookahead)
        return {} if container.is_a?(Group)

        # NOTE: The fields below will eventually be deprecated once we move to using the new `aggregate`
        # and `time_series` fields (see https://gitlab.com/gitlab-org/gitlab/-/issues/444468/#proposed-api-layout)
        weekly_stats = Gitlab::Ci::Charts::WeekChart.new(container, selected_period_statuses(lookahead, :week))
        monthly_stats = Gitlab::Ci::Charts::MonthChart.new(container, selected_period_statuses(lookahead, :month))
        yearly_stats = Gitlab::Ci::Charts::YearChart.new(container, selected_period_statuses(lookahead, :year))

        result = {}
        if any_field_selected?(lookahead, :week_pipelines_labels, :week_pipelines_totals, :week_pipelines_successful)
          result.merge!(
            week_pipelines_labels: weekly_stats.labels,
            week_pipelines_totals: weekly_stats.totals(status: :all),
            week_pipelines_successful: weekly_stats.totals(status: :success))
        end

        if any_field_selected?(lookahead, :month_pipelines_labels, :month_pipelines_totals, :month_pipelines_successful)
          result.merge!(
            month_pipelines_labels: monthly_stats.labels,
            month_pipelines_totals: monthly_stats.totals(status: :all),
            month_pipelines_successful: monthly_stats.totals(status: :success))
        end

        if any_field_selected?(lookahead, :year_pipelines_labels, :year_pipelines_totals, :year_pipelines_successful)
          result.merge!(
            year_pipelines_labels: yearly_stats.labels,
            year_pipelines_totals: yearly_stats.totals(status: :all),
            year_pipelines_successful: yearly_stats.totals(status: :success))
        end

        if any_field_selected?(lookahead, :pipeline_times_labels, :pipeline_times_values)
          pipeline_times = Gitlab::Ci::Charts::PipelineTime.new(container, [])
          result.merge!(
            pipeline_times_labels: pipeline_times.labels,
            pipeline_times_values: pipeline_times.pipeline_times)
        end

        result
      end

      def any_field_selected?(lookahead, *fields)
        fields.any? { |field| lookahead&.selects?(field) }
      end

      def selected_status_groups(aggregate_lookahead)
        return [] unless aggregate_lookahead&.selects?(:count)

        selection = []
        selection << :any if aggregate_lookahead.selects?(:count, arguments: { status: :any })
        selection + ::Ci::CollectPipelineAnalyticsServiceBase::STATUS_GROUPS.filter do |status|
          aggregate_lookahead.selects?(:count, arguments: { status: status })
        end
      end

      def selected_period_statuses(lookahead, period)
        return [] unless lookahead

        selected = ::Ci::CollectPipelineAnalyticsServiceBase::STATUS_GROUPS.filter do |status|
          lookahead.selection(:"#{period}_pipelines").selects?(:totals, arguments: { status: status })
        end
        selected << :success if lookahead.selects?(:"#{period}_pipelines_successful")

        selected.sort.uniq
      end

      def selected_duration_percentiles(aggregate_lookahead)
        return [] unless aggregate_lookahead

        ::Ci::CollectPipelineAnalyticsServiceBase::ALLOWED_PERCENTILES.filter do |percentile|
          aggregate_lookahead.selection(:duration_statistics).selects?("p#{percentile}")
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/pipeline_job_artifacts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class PipelineJobArtifactsResolver < BaseResolver
      type [Types::Ci::JobArtifactType], null: false

      alias_method :pipeline, :object

      def resolve
        find_job_artifacts
      end

      private

      def find_job_artifacts
        BatchLoader::GraphQL.for(pipeline).batch do |pipelines, loader|
          ActiveRecord::Associations::Preloader.new(records: pipelines, associations: :job_artifacts).call

          pipelines.each { |pl| loader.call(pl, pl.job_artifacts) }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/pipeline_stages_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class PipelineStagesResolver < BaseResolver
      include LooksAhead

      type Types::Ci::StageType.connection_type, null: true
      extras [:lookahead]

      alias_method :pipeline, :object

      def resolve_with_lookahead
        apply_lookahead(pipeline.stages)
      end

      def preloads
        {
          jobs: { latest_statuses: [:needs] }
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/pipeline_triggers_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class PipelineTriggersResolver < BaseResolver
      include LooksAhead
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :admin_build
      type Types::Ci::PipelineTriggerType.connection_type, null: false

      def resolve_with_lookahead
        triggers = ::Ci::TriggersFinder.new(current_user, object).execute
        apply_lookahead(triggers)
      end

      private

      def unconditional_includes
        [:pipelines]
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/project_pipeline_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class ProjectPipelineCountsResolver < BaseResolver
      type Types::Ci::PipelineCountsType, null: true

      argument :ref,
        GraphQL::Types::String,
        required: false,
        description: "Filter pipelines by the ref they are run for."

      argument :sha,
        GraphQL::Types::String,
        required: false,
        description: "Filter pipelines by the SHA of the commit they are run for."

      argument :source,
        GraphQL::Types::String,
        required: false,
        description: "Filter pipelines by their source."

      def resolve(**args)
        ::Gitlab::PipelineScopeCounts.new(context[:current_user], object, args)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/project_pipeline_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class ProjectPipelineResolver < BaseResolver
      include LooksAhead

      calls_gitaly!

      type ::Types::Ci::PipelineType, null: true

      alias_method :project, :object

      argument :id, Types::GlobalIDType[::Ci::Pipeline],
        required: false,
        description: 'Global ID of the Pipeline. For example, "gid://gitlab/Ci::Pipeline/314".',
        prepare: ->(pipeline_id, _ctx) { pipeline_id.model_id }

      argument :iid, GraphQL::Types::ID, # rubocop:disable Graphql/IDType -- Legacy argument using ID type kept for backwards compatibility
        required: false,
        description: 'IID of the Pipeline. For example, "1".'

      argument :sha, GraphQL::Types::String,
        required: false,
        description: 'SHA of the Pipeline. For example, "dyd0f15ay83993f5ab66k927w28673882x99100b".'

      validates mutually_exclusive: [:id, :iid, :sha]

      def self.resolver_complexity(args, child_complexity:)
        complexity = super
        complexity - 10 if args.present?
      end

      def resolve(id: nil, iid: nil, sha: nil, **args)
        self.lookahead = args.delete(:lookahead)

        if id
          BatchLoader::GraphQL.for(id).batch(key: project) do |ids, loader|
            finder = ::Ci::PipelinesFinder.new(project, current_user, ids: ids)

            apply_lookahead(finder.execute).each { |pipeline| loader.call(pipeline.id.to_s, pipeline) }
          end
        elsif iid
          BatchLoader::GraphQL.for(iid).batch(key: project) do |iids, loader|
            # This is a temporary workaround for some customers until
            # https://gitlab.com/gitlab-org/gitlab/-/issues/545167 is addressed
            args = { iids: iids }
            args[:sort] = :asc if Feature.enabled?(:single_pipeline_for_resolver, project)

            finder = ::Ci::PipelinesFinder.new(project, current_user, args)

            apply_lookahead(finder.execute).each { |pipeline| loader.call(pipeline.iid.to_s, pipeline) }
          end
        elsif sha
          BatchLoader::GraphQL.for(sha).batch(key: project) do |shas, loader|
            finder = ::Ci::PipelinesFinder.new(project, current_user, sha: shas)

            apply_lookahead(finder.execute).each { |pipeline| loader.call(pipeline.sha.to_s, pipeline) }
          end
        else
          project.last_pipeline
        end
      end

      def unconditional_includes
        [
          { statuses: [:needs] }
        ]
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/project_pipeline_schedules_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class ProjectPipelineSchedulesResolver < BaseResolver
      alias_method :project, :object

      type ::Types::Ci::PipelineScheduleType.connection_type, null: true

      argument :status, ::Types::Ci::PipelineScheduleStatusEnum,
        required: false,
        description: 'Filter pipeline schedules by active status.'

      argument :ids, [GraphQL::Types::ID],
        required: false,
        default_value: nil,
        description: 'Filter pipeline schedules by IDs.'

      argument :sort, ::Types::Ci::PipelineScheduleSortEnum,
        required: false, default_value: :id_desc,
        description: 'List pipeline schedules by sort order. Default is `id_desc`.'

      def resolve(status: nil, ids: nil, sort: :id_desc)
        ::Ci::PipelineSchedulesFinder.new(project, sort: sort).execute(scope: status, ids: ids)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/project_pipelines_resolver.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/ResolverType -- The GraphQL type here gets defined in
# https://gitlab.com/gitlab-org/gitlab/blob/master/app/graphql/resolvers/concerns/resolves_pipelines.rb#L7

module Resolvers
  module Ci
    class ProjectPipelinesResolver < BaseResolver
      include LooksAhead
      include ResolvesPipelines

      alias_method :project, :object

      def resolve_with_lookahead(**args)
        apply_lookahead(resolve_pipelines(project, args))
      end

      private

      def preloads
        {
          jobs: { statuses_order_id_desc: [:needs] },
          upstream: [:triggered_by_pipeline],
          downstream: [:triggered_pipelines]
        }
      end
    end
  end
end
# rubocop: enable Graphql/ResolverType

Resolvers::Ci::ProjectPipelinesResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/project_runners_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class ProjectRunnersResolver < RunnersResolver
      type Types::Ci::RunnerType.connection_type, null: true

      def parent_param
        raise 'Expected project missing' unless parent.is_a?(Project)

        { project: parent }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_groups_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerGroupsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include ResolvesGroups

      type ::Types::Namespaces::GroupInterface.connection_type, null: true

      authorize :read_runner
      authorizes_object!

      alias_method :runner, :object

      def resolve_with_lookahead(**args)
        return unless runner.group_type?

        BatchLoader::GraphQL.for(runner.id).batch(key: :runner_namespaces) do |runner_ids, loader|
          plucked_runner_and_namespace_ids =
            ::Ci::RunnerNamespace
              .for_runner(runner_ids)
              .select(:runner_id, :namespace_id)
              .pluck(:runner_id, :namespace_id) # rubocop: disable CodeReuse/ActiveRecord)

          namespace_ids = plucked_runner_and_namespace_ids.collect(&:last).uniq
          groups = apply_lookahead(::Group.id_in(namespace_ids))
          Preloaders::GroupPolicyPreloader.new(groups, current_user).execute
          groups_by_id = groups.index_by(&:id)

          runner_group_ids_by_runner_id =
            plucked_runner_and_namespace_ids
              .group_by { |runner_id, _namespace_id| runner_id }
              .transform_values { |values| values.filter_map { |_runner_id, namespace_id| groups_by_id[namespace_id] } }

          runner_ids.each do |runner_id|
            runner_namespaces = runner_group_ids_by_runner_id[runner_id] || []

            loader.call(runner_id, runner_namespaces)
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_job_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerJobCountResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type GraphQL::Types::Int, null: true

      authorize :read_runner
      authorizes_object!

      argument :statuses, [::Types::Ci::JobStatusEnum],
        required: false,
        description: 'Filter jobs by status.'

      alias_method :runner, :object

      def resolve(statuses: nil)
        BatchLoader::GraphQL.for(runner.id).batch(key: [:job_count, statuses]) do |runner_ids, loader, _args|
          counts_by_runner = calculate_job_count_per_runner(runner_ids, statuses)

          runner_ids.each do |runner_id|
            loader.call(runner_id, counts_by_runner[runner_id]&.count || 0)
          end
        end
      end

      private

      def calculate_job_count_per_runner(runner_ids, statuses)
        # rubocop: disable CodeReuse/ActiveRecord
        builds_tbl = ::Ci::Build.arel_table
        runners_tbl = ::Ci::Runner.arel_table
        lateral_query = ::Ci::Build.select(1).where(builds_tbl['runner_id'].eq(runners_tbl['id']))
        lateral_query = lateral_query.where(status: statuses) if statuses
        # We limit to 1 above the JOB_COUNT_LIMIT to indicate that more items exist after JOB_COUNT_LIMIT
        lateral_query = lateral_query.limit(::Types::Ci::RunnerType::JOB_COUNT_LIMIT + 1)
        ::Ci::Runner.joins("JOIN LATERAL (#{lateral_query.to_sql}) builds_with_limit ON true")
          .id_in(runner_ids)
          .select(:id, Arel.star.count.as('count'))
          .group(:id)
          .index_by(&:id)
        # rubocop: enable CodeReuse/ActiveRecord
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_jobs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerJobsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include LooksAhead

      type ::Types::Ci::JobInterface.connection_type, null: true
      authorize :read_builds
      authorizes_object!
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      argument :statuses, [::Types::Ci::JobStatusEnum],
        required: false,
        description: 'Filter jobs by status.'

      alias_method :runner, :object

      def resolve_with_lookahead(statuses: nil)
        context[:job_field_authorization] = :read_build # Instruct JobType to perform field-level authorization

        jobs = ::Ci::JobsFinder.new(current_user: current_user, runner: runner, params: { scope: statuses }).execute

        apply_lookahead(jobs)
      end

      private

      def preloads
        {
          previous_stage_jobs_or_needs: [:needs, :pipeline],
          artifacts: [:job_artifacts],
          pipeline: [:user],
          project: [{ project: [:route, { namespace: [:route] }, :project_feature] }],
          detailed_status: [
            :metadata,
            :job_definition,
            { pipeline: [:merge_request] },
            { project: [:route, { namespace: :route }] }
          ],
          commit_path: [:pipeline, { project: { namespace: [:route] } }],
          ref_path: [{ project: [:route, { namespace: [:route] }] }],
          browse_artifacts_path: [{ project: { namespace: [:route] } }],
          play_path: [{ project: { namespace: [:route] } }],
          web_path: [{ project: { namespace: [:route] } }],
          short_sha: [:pipeline],
          tags: [:tags],
          trace: [{ project: [:namespace] }, :job_artifacts_trace]
        }
      end

      def nested_preloads
        super.merge({
          trace: {
            html_summary: [:trace_chunks]
          }
        })
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_managers_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerManagersResolver < BaseResolver
      type Types::Ci::RunnerManagerType.connection_type, null: true

      argument :system_id, ::GraphQL::Types::String,
        required: false,
        description: 'Filter runner managers by system ID.'

      argument :status, ::Types::Ci::RunnerStatusEnum,
        required: false,
        description: 'Filter runner managers by status.'

      def resolve(**args)
        BatchLoader::GraphQL.for(object.id).batch(key: args[:system_id]) do |runner_ids, loader|
          runner_managers =
            ::Ci::RunnerManagersFinder
              .new(runner: runner_ids, params: args.slice(:system_id, :status))
              .execute
          ::Preloaders::RunnerManagerPolicyPreloader.new(runner_managers, current_user).execute

          runner_managers_by_runner_id = runner_managers.group_by(&:runner_id)

          runner_ids.each do |runner_id|
            runner_managers = Array.wrap(runner_managers_by_runner_id[runner_id])
            loader.call(runner_id, runner_managers)
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_owner_project_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerOwnerProjectResolver < BaseResolver
      include LooksAhead

      type ::Types::Projects::ProjectInterface, null: true

      alias_method :runner, :object

      def resolve_with_lookahead(**_args)
        resolve_owner
      end

      private

      def node_selection(selection = lookahead)
        # There are no nodes or edges selections in RunnerOwnerProjectResolver, but rather a project directly
        selection
      end

      def unconditional_includes
        [:project_feature]
      end

      def preloads
        {
          full_path: [:route, { namespace: [:route] }],
          web_url: [:route, { namespace: [:route] }]
        }
      end

      def resolve_owner
        return unless runner.project_type?

        BatchLoader::GraphQL.for(runner.id).batch do |runner_ids, loader|
          # rubocop:disable CodeReuse/ActiveRecord -- this query is too specific to generalize in model
          runner_and_projects_with_row_number =
            ::Ci::RunnerProject
              .where(runner_id: runner_ids)
              .select('id, runner_id, project_id, ROW_NUMBER() OVER (PARTITION BY runner_id ORDER BY id ASC)')
          runner_and_owner_projects =
            ::Ci::RunnerProject
              .select(:id, :runner_id, :project_id)
              .from("(#{runner_and_projects_with_row_number.to_sql}) temp WHERE row_number = 1")
          owner_project_id_by_runner_id =
            runner_and_owner_projects
              .group_by(&:runner_id)
              .transform_values { |runner_projects| runner_projects.first.project_id }
          project_ids = owner_project_id_by_runner_id.values.uniq

          projects = apply_lookahead(Project.id_in(project_ids))
          Preloaders::ProjectPolicyPreloader.new(projects, current_user).execute
          projects_by_id = projects.index_by(&:id)

          runner_ids.each do |runner_id|
            owner_project_id = owner_project_id_by_runner_id[runner_id]
            loader.call(runner_id, projects_by_id[owner_project_id])
          end
          # rubocop: enable CodeReuse/ActiveRecord
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_platforms_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerPlatformsResolver < BaseResolver
      type Types::Ci::RunnerPlatformType.connection_type, null: true
      description 'Supported runner platforms.'

      def resolve(**args)
        runner_instructions.map do |platform, data|
          {
            name: platform, human_readable_name: data[:human_readable_name],
            architectures: parse_architectures(data[:download_locations])
          }
        end
      end

      private

      def runner_instructions
        Gitlab::Ci::RunnerInstructions::OS.merge(Gitlab::Ci::RunnerInstructions::OTHER_ENVIRONMENTS)
      end

      def parse_architectures(download_locations)
        download_locations&.map do |architecture, download_location|
          { name: architecture, download_location: download_location }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerProjectsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include LooksAhead
      include ProjectSearchArguments

      type Types::ProjectType.connection_type, null: true
      authorize :read_runner
      authorizes_object!

      alias_method :runner, :object

      def resolve_with_lookahead(**args)
        return unless runner.project_type?

        # rubocop:disable CodeReuse/ActiveRecord
        BatchLoader::GraphQL.for(runner.id).batch do |runner_ids, loader|
          plucked_runner_and_project_ids = ::Ci::RunnerProject
                                             .select(:runner_id, :project_id)
                                             .where(runner_id: runner_ids)
                                             .pluck(:runner_id, :project_id)

          unique_project_ids = plucked_runner_and_project_ids.collect { |_runner_id, project_id| project_id }.uniq
          projects = ProjectsFinder
                       .new(current_user: current_user,
                         params: project_finder_params(args),
                         project_ids_relation: unique_project_ids)
                       .execute
          projects = apply_lookahead(projects)
          Preloaders::ProjectPolicyPreloader.new(projects, current_user).execute
          sorted_project_ids = projects.map(&:id)
          projects_by_id = projects.index_by(&:id)

          # In plucked_runner_and_project_ids, first() represents the runner ID, and second() the project ID,
          # so let's group the project IDs by runner ID
          project_ids_by_runner_id =
            plucked_runner_and_project_ids
              .group_by(&:first)
              .transform_values { |runner_id_and_project_id| runner_id_and_project_id.map(&:second) }
          # Reorder the project IDs according to the order in sorted_project_ids
          sorted_project_ids_by_runner_id =
            project_ids_by_runner_id.transform_values { |project_ids| sorted_project_ids.intersection(project_ids) }

          runner_ids.each do |runner_id|
            runner_project_ids = sorted_project_ids_by_runner_id[runner_id] || []
            runner_projects = runner_project_ids.map { |id| projects_by_id[id] }

            loader.call(runner_id, runner_projects)
          end
        end
        # rubocop:enable CodeReuse/ActiveRecord
      end

      private

      def unconditional_includes
        [:project_feature]
      end

      def preloads
        super.merge({
          full_path: [:route, { namespace: [:route] }],
          web_url: [:route, { namespace: [:route] }]
        })
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerResolver < BaseResolver
      type Types::Ci::RunnerType, null: true
      description 'Runner information.'

      argument :id,
        type: ::Types::GlobalIDType[::Ci::Runner],
        required: true,
        description: 'Runner ID.'

      def resolve(id:)
        GitlabSchema.object_from_id(id, expected_type: ::Ci::Runner)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runner_setup_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnerSetupResolver < BaseResolver
      ACCESS_DENIED = 'User is not authorized to register a runner for the specified resource!'

      type Types::Ci::RunnerSetupType, null: true
      description 'Runner setup instructions.'

      argument :platform,
        type: GraphQL::Types::String,
        required: true,
        description: 'Platform to generate the instructions for.'

      argument :architecture,
        type: GraphQL::Types::String,
        required: true,
        description: 'Architecture to generate the instructions for.'

      argument :project_id,
        type: ::Types::GlobalIDType[::Project],
        required: false,
        deprecated: { reason: 'No longer used', milestone: '13.11' },
        description: 'Project to register the runner for.'

      argument :group_id,
        type: ::Types::GlobalIDType[::Group],
        required: false,
        deprecated: { reason: 'No longer used', milestone: '13.11' },
        description: 'Group to register the runner for.'

      def resolve(platform:, architecture:, **args)
        instructions = Gitlab::Ci::RunnerInstructions.new(
          os: platform,
          arch: architecture
        )

        {
          install_instructions: instructions.install_script || other_install_instructions(platform),
          register_instructions: instructions.register_command
        }
      ensure
        raise_resource_not_available_error! ACCESS_DENIED if access_denied?(instructions)
      end

      private

      def access_denied?(instructions)
        instructions.errors.include?('Gitlab::Access::AccessDeniedError')
      end

      def other_install_instructions(platform)
        Gitlab::Ci::RunnerInstructions::OTHER_ENVIRONMENTS[platform.to_sym][:installation_instructions_url]
      end

      def target_param(args)
        project_param(args[:project_id]) || group_param(args[:group_id]) || {}
      end

      def project_param(project_id)
        return unless project_id

        { project: find_object(project_id) }
      end

      def group_param(group_id)
        return unless group_id

        { group: find_object(group_id) }
      end

      def find_object(gid)
        GlobalID::Locator.locate(gid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/runners_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class RunnersResolver < BaseResolver
      include LooksAhead
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Ci::RunnerType.connection_type, null: true

      argument :active, ::GraphQL::Types::Boolean,
        required: false,
        description: 'Filter runners by `active` (true) or `paused` (false) status.',
        deprecated: { reason: :renamed, replacement: 'paused', milestone: '14.8' }

      argument :paused, ::GraphQL::Types::Boolean,
        required: false,
        description: 'Filter runners by `paused` (true) or `active` (false) status.'

      argument :status, ::Types::Ci::RunnerStatusEnum,
        required: false,
        description: 'Filter runners by status.'

      argument :type, ::Types::Ci::RunnerTypeEnum,
        required: false,
        description: 'Filter runners by type.'

      argument :tag_list, [GraphQL::Types::String],
        required: false,
        description: 'Filter by tags associated with the runner (comma-separated or array).'

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Filter by full token or partial text in description field.'

      argument :sort, ::Types::Ci::RunnerSortEnum,
        required: false,
        description: 'Sort order of results.'

      argument :upgrade_status, ::Types::Ci::RunnerUpgradeStatusEnum,
        required: false,
        description: 'Filter by upgrade status.'

      argument :creator_id, ::Types::GlobalIDType[::User].as('UserID'),
        required: false,
        description: 'Filter runners by creator ID.'

      argument :creator_username, GraphQL::Types::String,
        required: false,
        description: 'Filter runners by creator username.'

      argument :version_prefix, GraphQL::Types::String,
        required: false,
        description: "Filter runners by version. Runners that contain runner managers with the version at " \
          "the start of the search term are returned. For example, the search term '14.' returns " \
          "runner managers with versions '14.11.1' and '14.2.3'."

      argument :owner_full_path, GraphQL::Types::String,
        required: false,
        description: 'Filter runners by owning project or group.',
        experiment: { milestone: '17.8' }

      def resolve_with_lookahead(**args)
        apply_lookahead(
          ::Ci::RunnersFinder
            .new(current_user: current_user, params: runners_finder_params(args))
            .execute)
      rescue Gitlab::Access::AccessDeniedError
        handle_access_denied_error!
      end

      protected

      def handle_access_denied_error!
        raise_resource_not_available_error!
      end

      def runners_finder_params(params)
        # Give preference to paused argument over the deprecated 'active' argument
        paused = params.fetch(:paused, params[:active] ? !params[:active] : nil)

        {
          active: paused.nil? ? nil : !paused,
          status_status: params[:status]&.to_s,
          type_type: params[:type],
          tag_name: params[:tag_list],
          upgrade_status: params[:upgrade_status],
          search: params[:search],
          sort: params[:sort]&.to_s,
          creator_id:
            params[:creator_id] ? ::GitlabSchema.parse_gid(params[:creator_id], expected_type: ::User).model_id : nil,
          creator_username: params[:creator_username],
          version_prefix: params[:version_prefix],
          owner_full_path: params[:owner_full_path],
          preload: {} # we'll handle preloading ourselves
        }.compact
         .merge(parent_param)
      end

      def parent_param
        return {} unless parent

        raise "Unexpected parent type: #{parent.class}"
      end

      private

      def parent
        object.respond_to?(:sync) ? object.sync : object
      end

      def preloads
        super.merge({
          created_by: [:creator],
          tag_list: [:tags]
        })
      end
    end
  end
end

Resolvers::Ci::RunnersResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/template_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class TemplateResolver < BaseResolver
      type Types::Ci::TemplateType, null: true

      argument :name,
        GraphQL::Types::String,
        required: true,
        description: 'Name of the CI/CD template to search for. ' \
          'Template must be formatted as `Name.gitlab-ci.yml`.'

      alias_method :project, :object

      def resolve(name: nil)
        ::TemplateFinder.new(:gitlab_ci_ymls, project, name: name).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/test_report_summary_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class TestReportSummaryResolver < BaseResolver
      type ::Types::Ci::TestReportSummaryType, null: true

      alias_method :pipeline, :object

      def resolve(**args)
        TestReportSummarySerializer
          .new(project: pipeline.project, current_user: @current_user)
          .represent(pipeline.test_report_summary)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/test_suite_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class TestSuiteResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type ::Types::Ci::TestSuiteType, null: true
      authorize :read_build
      authorizes_object!

      alias_method :pipeline, :object

      argument :build_ids, [GraphQL::Types::ID],
        required: true,
        description: 'IDs of the builds used to run the test suite.'

      def resolve(build_ids:)
        builds = pipeline.latest_builds.id_in(build_ids).presence
        return unless builds

        TestSuiteSerializer
          .new(project: pipeline.project, current_user: @current_user)
          .represent(load_test_suite_data(builds), details: true)
      end

      private

      def load_test_suite_data(builds)
        suite = builds.sum(Gitlab::Ci::Reports::TestSuite.new) do |build|
          test_report = build.collect_test_reports!(Gitlab::Ci::Reports::TestReport.new)
          test_report.get_suite(build.test_suite_name)
        end

        Gitlab::Ci::Reports::TestFailureHistory.new(suite.failed.values, pipeline.project).load!

        suite
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/user_runners_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class UserRunnersResolver < RunnersResolver
      type Types::Ci::RunnerType.connection_type, null: true

      argument :assignable_to_project_path, GraphQL::Types::ID, # rubocop:disable Graphql/IDType -- This is a project_path, and not a generic id.
        required: false,
        description: 'Path of a project. When set, returns runners that can be assigned to a project, ' \
          'are not locked, and not already assigned to the project.'

      protected

      def runners_finder_params(params)
        project = Project.find_by_full_path(params[:assignable_to_project_path])

        super.merge(assignable_to_project: project)
      end

      def parent_param
        raise_resource_not_available_error! unless parent.is_a?(User)

        { user: parent }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ci/variables_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ci
    class VariablesResolver < BaseResolver
      type Types::Ci::InstanceVariableType.connection_type, null: true

      argument :sort, ::Types::Ci::VariableSortEnum,
        required: false,
        description: 'Sort order of results.'

      def resolve(**args)
        if parent.is_a?(Group) || parent.is_a?(Project)
          parent.variables.order_by(args[:sort])
        elsif current_user&.can_admin_all_resources?
          ::Ci::InstanceVariable.order_by(args[:sort])
        end
      end

      private

      def parent
        object.respond_to?(:sync) ? object.sync : object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/clusters/agent_activity_events_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Clusters
    class AgentActivityEventsResolver < BaseResolver
      type Types::Clusters::AgentActivityEventType, null: true

      alias_method :agent, :object

      delegate :project, to: :agent

      def resolve(**args)
        return ::Clusters::Agents::ActivityEvent.none unless can_view_activity_events?

        agent.activity_events
      end

      private

      def can_view_activity_events?
        current_user.can?(:admin_cluster, project)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/clusters/agents/authorizations/ci_access_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Clusters
    module Agents
      module Authorizations
        class CiAccessResolver < BaseResolver
          type Types::Clusters::Agents::Authorizations::CiAccessType, null: true

          alias_method :project, :object

          def resolve(*)
            ::Clusters::Agents::Authorizations::CiAccess::Finder.new(project).execute
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/clusters/agents/authorizations/user_access_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Clusters
    module Agents
      module Authorizations
        class UserAccessResolver < BaseResolver
          type Types::Clusters::Agents::Authorizations::UserAccessType, null: true

          alias_method :project, :object

          def resolve(*)
            ::Clusters::Agents::Authorizations::UserAccess::Finder.new(current_user, project: project).execute
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/clusters/agents_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Clusters
    class AgentsResolver < BaseResolver
      include LooksAhead

      type Types::Clusters::AgentType.connection_type, null: true

      extras [:lookahead]

      when_single do
        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the cluster agent.'
      end

      def resolve_with_lookahead(**args)
        apply_lookahead(
          ::Clusters::AgentsFinder
            .new(object, current_user, params: args)
            .execute
        )
      end

      private

      def preloads
        {
          activity_events: { activity_events: [{ user: [:user_detail, :user_preference] }, { agent_token: :agent }] },
          tokens: :active_agent_tokens
        }
      end
    end
  end
end

Resolvers::Clusters::AgentsResolver.prepend_mod_with('Resolvers::Clusters::AgentsResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/clusters/agent_tokens_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Clusters
    class AgentTokensResolver < BaseResolver
      type Types::Clusters::AgentTokenType.connection_type, null: true

      alias_method :agent, :object

      delegate :project, to: :agent

      def resolve(**_args)
        ::Clusters::AgentTokensFinder.new(agent, current_user, status: :active).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/codequality_reports_comparer_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class CodequalityReportsComparerResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type ::Types::Security::CodequalityReportsComparerType, null: true

    authorize :read_build

    def resolve
      authorize!(object.diff_head_pipeline)

      object.compare_codequality_reports
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/commit_pipelines_resolver.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/ResolverType

module Resolvers
  class CommitPipelinesResolver < BaseResolver
    # The GraphQL type here gets defined in this include
    include ::ResolvesPipelines

    alias_method :commit, :object

    def resolve(**args)
      resolve_pipelines(commit.project, args.merge!({ sha: commit.sha }))
    end
  end
end
# rubocop: enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/board_item_filterable.rb =====
# frozen_string_literal: true

module BoardItemFilterable
  extend ActiveSupport::Concern

  private

  def item_filters(args)
    filters = args.to_h

    set_filter_values(filters)

    set_filter_values(filters[:not]) if filters[:not]

    if filters[:or]
      rewrite_param_name(filters[:or], :author_usernames, :author_username)
      rewrite_param_name(filters[:or], :assignee_usernames, :assignee_username)
      rewrite_param_name(filters[:or], :label_names, :label_name)
    end

    filters
  end

  def set_filter_values(filters)
    filter_by_assignee(filters)
  end

  def filter_by_assignee(filters)
    if filters[:assignee_username] && filters[:assignee_wildcard_id]
      raise ::Gitlab::Graphql::Errors::ArgumentError, 'Incompatible arguments: assigneeUsername, assigneeWildcardId.'
    end

    filters[:assignee_id] = filters.delete(:assignee_wildcard_id) if filters[:assignee_wildcard_id]
  end

  def rewrite_param_name(filters, old_name, new_name)
    filters[new_name] = filters.delete(old_name) if filters[old_name].present?
  end
end

::BoardItemFilterable.prepend_mod_with('Resolvers::BoardItemFilterable')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/caching_array_resolver.rb =====
# frozen_string_literal: true

# Concern that will eliminate N+1 queries for size-constrained
# collections of items.
#
# **note**: The resolver will never load more items than
# `@field.max_page_size` if defined, falling back to
# `context.schema.default_max_page_size`.
#
# provided that:
#
# - the query can be uniquely determined by the object and the arguments
# - the model class includes FromUnion
# - the model class defines a scalar primary key
#
# This comes at the cost of returning arrays, not relations, so we don't get
# any keyset pagination goodness. Consequently, this is only suitable for small-ish
# result sets, as the full result set will be loaded into memory.
#
# To enforce this, the resolver limits the size of result sets to
# `@field.max_page_size || context.schema.default_max_page_size`.
#
# **important**: If the cardinality of your collection is likely to be greater than 100,
# then you will want to pass `max_page_size:` as part of the field definition
# or (ideally) set `max_page_size` in the resolver.
#
# How to implement:
# --------------------
#
# Each including class operates on two generic parameters, A and R:
#  - A is any Object that can be used as a Hash key. Instances of A
#    are returned by `query_input` and then passed to `query_for`.
#  - R is any subclass of ApplicationRecord that includes FromUnion.
#    R must have a single scalar primary_key
#
# Classes must implement:
# - #model_class -> Class[R]. (Must respond to  :primary_key, and :from_union)
# - #query_input(**kwargs) -> A (Must be hashable)
# - #query_for(A) -> ActiveRecord::Relation[R]
#
# Note the relationship between query_input and query_for, one of which
# consumes the input of the other
# (i.e. `resolve(**args).sync == query_for(query_input(**args)).to_a`).
#
# Classes may implement:
# - max_union_size Integer (the maximum number of queries to run in any one union)
# - preload -> Preloads|NilClass (a set of preloads to apply to each query)
# - #item_found(A, R) (return value is ignored)
# - allowed?(R) -> Boolean (if this method returns false, the value is not resolved)
module CachingArrayResolver
  MAX_UNION_SIZE = 50

  def resolve(**args)
    key = query_input(**args)

    BatchLoader::GraphQL.for(key).batch(**batch) do |keys, loader|
      if keys.size == 1
        # We can avoid the union entirely.
        k = keys.first
        limit(query_for(k)).each { |item| found(loader, k, item) }
      else
        queries = keys.map { |key| query_for(key) }

        queries.in_groups_of(max_union_size, false).each do |group|
          by_id = model_class
            .select(all_fields, :union_member_idx)
            .from_union(tag(group), remove_duplicates: false)
            .preload(preload) # rubocop: disable CodeReuse/ActiveRecord
            .group_by { |r| r[primary_key] }

          by_id.values.each do |item_group|
            item = item_group.first
            item_group.map(&:union_member_idx).each do |i|
              found(loader, keys[i], item)
            end
          end
        end
      end
    end
  end

  # Override to apply filters on a per-item basis
  def allowed?(item)
    true
  end

  # Override to specify preloads for each query
  def preload
    nil
  end

  # Override this to intercept the items once they are found
  def item_found(query_input, item); end

  def max_union_size
    MAX_UNION_SIZE
  end

  private

  def primary_key
    @primary_key ||= (model_class.primary_key || raise("No primary key for #{model_class}"))
  end

  def batch
    { key: self.class, default_value: [] }
  end

  def found(loader, key, value)
    return unless allowed?(value)

    loader.call(key) do |vs|
      item_found(key, value)
      vs << value
    end
  end

  # Tag each row returned from each query with a the index of which query in
  # the union it comes from. This lets us map the results back to the cache key.
  def tag(queries)
    queries.each_with_index.map do |q, i|
      limit(q.select(all_fields, member_idx(i)))
    end
  end

  def limit(query)
    query.limit(query_limit)
  end

  def all_fields
    model_class.arel_table[Arel.star]
  end

  # rubocop: disable Graphql/Descriptions -- false positive
  def query_limit
    field&.max_page_size.presence || context.schema.default_max_page_size
  end
  # rubocop: enable Graphql/Descriptions

  def member_idx(idx)
    ::Arel::Nodes::SqlLiteral.new(idx.to_s).as('union_member_idx')
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/group_issuable_resolver.rb =====
# frozen_string_literal: true

module GroupIssuableResolver
  extend ActiveSupport::Concern

  included do
    argument :include_subgroups, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: "Include #{issuable_collection_name} belonging to subgroups"

    argument :include_archived, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: "Return #{issuable_collection_name} from archived projects"
  end

  def resolve(**args)
    args[:non_archived] = !args.delete(:include_archived)

    super
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/issues/look_ahead_preloads.rb =====
# frozen_string_literal: true

module Issues
  module LookAheadPreloads
    extend ActiveSupport::Concern

    prepended do
      include ::LooksAhead
    end

    private

    def unconditional_includes
      [
        {
          project: [:project_feature, :group]
        },
        :author,
        :work_item_type
      ]
    end

    def preloads
      {
        reference: { namespace: [{ parent: :route }, :route] },
        alert_management_alert: [:alert_management_alert],
        assignees: [:assignees],
        participants: Issue.participant_includes,
        timelogs: [:timelogs],
        customer_relations_contacts: { customer_relations_contacts: [:group] },
        escalation_status: [:incident_management_issuable_escalation_status],
        type: :work_item_type
      }
    end
  end
end

Issues::LookAheadPreloads.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/issues/sort_arguments.rb =====
# frozen_string_literal: true

module Issues
  module SortArguments
    extend ActiveSupport::Concern
    include ::WorkItems::NonStableCursorSortOptions

    included do
      argument :sort, Types::IssueSortEnum,
        description: 'Sort issues by the criteria.',
        required: false,
        default_value: :created_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/looks_ahead.rb =====
# frozen_string_literal: true

module LooksAhead
  extend ActiveSupport::Concern

  included do
    extras [:lookahead]
    attr_accessor :lookahead
  end

  def resolve(**args)
    self.lookahead = args.delete(:lookahead)

    resolve_with_lookahead(**args)
  end

  def apply_lookahead(query)
    all_preloads = (unconditional_includes + filtered_preloads).uniq

    return query if all_preloads.empty?

    query.preload(*all_preloads) # rubocop: disable CodeReuse/ActiveRecord
  end

  private

  def unconditional_includes
    []
  end

  def preloads
    {}
  end

  def nested_preloads
    {}
  end

  def filtered_preloads
    nodes = node_selection

    return [] unless nodes&.selected?

    selected_fields = nodes.selections.map(&:name)
    root_level_preloads = preloads_from_node_selection(selected_fields, preloads)

    root_level_preloads + nested_filtered_preloads(nodes, selected_fields)
  end

  def nested_filtered_preloads(nodes, selected_root_fields)
    return [] if nested_preloads.empty?

    nested_preloads.each_with_object([]) do |(root_field, fields), result|
      next unless selected_root_fields.include?(root_field)

      selected_fields = nodes.selection(root_field).selections.map(&:name)

      result << preloads_from_node_selection(selected_fields, fields)
    end.flatten
  end

  def preloads_from_node_selection(selected_fields, fields)
    fields.each_with_object([]) do |(field, requirements), result|
      result << requirements if selected_fields.include?(field)
    end.flatten
  end

  def node_selection(selection = lookahead)
    return selection unless selection&.selected?
    return selection if selection.field.type.list?
    return selection.selection(:edges).selection(:node) if selection.selects?(:edges)

    # Will return a NullSelection object if :nodes is not a selection. This
    # is better than returning nil as we can continue chaining selections on
    # without raising errors.
    selection.selection(:nodes)
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/merge_requests/look_ahead_preloads.rb =====
# frozen_string_literal: true

module MergeRequests
  module LookAheadPreloads
    extend ActiveSupport::Concern

    prepended do
      include ::LooksAhead
    end

    private

    def unconditional_includes
      [:target_project, :author]
    end

    def preloads
      {
        assignees: [:assignees],
        award_emoji: { award_emoji: [:awardable] },
        reviewers: [:reviewers],
        participants: MergeRequest.participant_includes,
        author: [:author],
        merged_at: [:metrics],
        closed_at: [:metrics],
        commit_count: [:metrics],
        diff_stats_summary: [:metrics],
        approved_by: [:approved_by_users],
        merge_after: [:merge_schedule],
        mergeable: [:merge_schedule],
        detailed_merge_status: [:merge_schedule],
        mergeability_checks: [:merge_schedule, :unresolved_notes, { target_project: [:lfs_file_locks] }],
        milestone: [:milestone, { milestone: [:project, :group] }],
        security_auto_fix: [:author],
        head_pipeline: [:merge_request_diff, { head_pipeline: [:merge_request, :project] }],
        timelogs: [:timelogs],
        pipelines: [:merge_request_diffs], # used by `recent_diff_head_shas` to load pipelines
        committers: [merge_request_diff: [:merge_request_diff_commits]],
        suggested_reviewers: [:predictions],
        diff_stats: [latest_merge_request_diff: [:merge_request_diff_commits]],
        source_branch_exists: [:source_project, { source_project: [:route] }],
        squash_read_only: { target_project: :project_setting },
        web_url: { target_project: [:route, { namespace: [:route] }] }
      }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/project_search_arguments.rb =====
# frozen_string_literal: true

module ProjectSearchArguments
  extend ActiveSupport::Concern

  included do
    argument :membership, GraphQL::Types::Boolean,
      required: false,
      description: 'Return only projects that the current user is a member of.'

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query, which can be for the project name, a path, or a description.'

    argument :search_namespaces, GraphQL::Types::Boolean,
      required: false,
      description: 'Include namespace in project search.'

    argument :topics, type: [GraphQL::Types::String],
      required: false,
      description: 'Filter projects by topics.'

    argument :personal, GraphQL::Types::Boolean,
      required: false,
      description: 'Return only personal projects.'

    argument :sort, GraphQL::Types::String,
      required: false,
      default_value: nil,
      description: "Sort order of results. Format: `<field_name>_<sort_direction>`, " \
        "for example: `id_desc` or `name_asc`. Defaults to `id_desc`, or `similarity` if search used."

    argument :namespace_path, GraphQL::Types::ID,
      required: false,
      description: "Filter projects by their namespace's full path (group or user)."
  end

  private

  def project_finder_params(params)
    {
      non_public: params[:membership],
      search: params[:search],
      search_namespaces: params[:search_namespaces],
      sort: params[:sort],
      topic: params[:topics],
      personal: params[:personal],
      namespace_path: params[:namespace_path]
    }.compact
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/projects/look_ahead_preloads.rb =====
# frozen_string_literal: true

module Projects
  module LookAheadPreloads
    extend ActiveSupport::Concern

    prepended do
      include ::LooksAhead
    end

    private

    def preloads
      {
        full_path: [:route],
        topics: [:topics],
        import_status: [:import_state],
        service_desk_address: [:project_feature, :service_desk_setting],
        jira_import_status: [:jira_imports],
        container_repositories: [:container_repositories],
        container_repositories_count: [:container_repositories],
        web_url: { namespace: [:route] },
        is_catalog_resource: [:catalog_resource],
        open_merge_requests_count: [:project_feature],
        organization_edit_path: [:organization]
      }
    end
  end
end

Projects::LookAheadPreloads.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/resolves_groups.rb =====
# frozen_string_literal: true

# Mixin for all resolver classes for type `Types::GroupType.connection_type`.
module ResolvesGroups
  extend ActiveSupport::Concern
  include LooksAhead

  PRELOADS = {
    archived: [:namespace_settings_with_ancestors_inherited_settings],
    container_repositories_count: [:container_repositories],
    description: [:namespace_details],
    description_html: [:namespace_details],
    custom_emoji: [:custom_emoji],
    full_path: [:route],
    path: [:route],
    web_url: [:route],
    dependency_proxy_blob_count: [:dependency_proxy_blobs],
    dependency_proxy_blobs: [:dependency_proxy_blobs],
    dependency_proxy_image_count: [:dependency_proxy_manifests],
    dependency_proxy_image_ttl_policy: [:dependency_proxy_image_ttl_policy],
    dependency_proxy_setting: [:dependency_proxy_setting],
    marked_for_deletion: [:deletion_schedule],
    marked_for_deletion_on: [:deletion_schedule],
    is_self_deletion_scheduled: [:deletion_schedule]
  }.freeze

  def resolve_with_lookahead(*args, **kwargs)
    apply_lookahead(
      resolve_groups(
        *args,
        **kwargs,
        with_statistics: lookahead.selection(:nodes).selects?(:project_statistics)
      )
    )
  end

  private

  # The resolver should implement this method.
  def resolve_groups(**args)
    raise NotImplementedError
  end

  def preloads
    PRELOADS
  end
end

ResolvesGroups.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/resolves_ids.rb =====
# frozen_string_literal: true

module ResolvesIds
  extend ActiveSupport::Concern

  def resolve_ids(ids)
    Array.wrap(ids).map do |id|
      next unless id.present?

      id.model_id
    end.compact
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/resolves_merge_requests.rb =====
# frozen_string_literal: true

# Mixin for resolving merge requests. All arguments must be in forms
# that `MergeRequestsFinder` can handle, so you may need to use aliasing.
module ResolvesMergeRequests
  extend ActiveSupport::Concern
  include ::Gitlab::Utils::StrongMemoize
  prepend ::MergeRequests::LookAheadPreloads

  NON_STABLE_CURSOR_SORTS = %i[priority_asc priority_desc
    popularity_asc popularity_desc
    label_priority_asc label_priority_desc
    milestone_due_asc milestone_due_desc].freeze

  included do
    type Types::MergeRequestType, null: true
  end

  def resolve_with_lookahead(**args)
    if args[:group_id]
      args[:group_id] = ::GitlabSchema.parse_gid(args[:group_id], expected_type: ::Group).model_id
      args[:include_subgroups] = true
    end

    validate_blob_path!(args)

    rewrite_param_name(args, :reviewer_wildcard_id, :reviewer_id)
    rewrite_param_name(args, :assignee_wildcard_id, :assignee_id)

    mr_finder = MergeRequestsFinder.new(current_user, prepare_finder_params(args.compact))
    finder = Gitlab::Graphql::Loaders::IssuableLoader.new(mr_parent, mr_finder)

    merge_requests = select_result(finder.batching_find_all { |query| apply_lookahead(query) })

    if non_stable_cursor_sort?(args[:sort])
      # Certain complex sorts are not supported by the stable cursor pagination yet.
      # In these cases, we use offset pagination, so we return the correct connection.
      offset_pagination(merge_requests)
    else
      merge_requests
    end
  end

  def ready?(**args)
    return early_return if no_results_possible?(args)

    super
  end

  def early_return
    [false, single? ? nil : MergeRequest.none]
  end

  private

  def prepare_finder_params(args)
    args
  end

  def mr_parent
    project
  end

  def rewrite_param_name(params, old_name, new_name)
    params[new_name] = params.delete(old_name) if params && params[old_name].present?
  end

  def validate_blob_path!(args)
    return if args[:blob_path].blank?

    required_fields = {
      target_branch: 'targetBranches',
      state: 'state',
      created_after: 'createdAfter'
    }

    required_fields.each do |key, field_name|
      if args[key].blank?
        raise Gitlab::Graphql::Errors::ArgumentError, "#{field_name} field must be specified to filter by blobPath"
      end
    end

    # It's limited for performance reasons
    created_after = args[:created_after].to_datetime
    return if created_after.after?(30.days.ago)

    raise Gitlab::Graphql::Errors::ArgumentError,
      'createdAfter must be within the last 30 days to filter by blobPath'
  end

  def non_stable_cursor_sort?(sort)
    NON_STABLE_CURSOR_SORTS.include?(sort)
  end

  def resource_parent
    # The project could have been loaded in batch by `BatchLoader`.
    # At this point we need the `id` of the project to query for issues, so
    # make sure it's loaded and not `nil` before continuing.
    object.respond_to?(:sync) ? object.sync : object
  end
  strong_memoize_attr :resource_parent
end

ResolvesMergeRequests.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/resolves_pipelines.rb =====
# frozen_string_literal: true

module ResolvesPipelines
  extend ActiveSupport::Concern

  included do
    type Types::Ci::PipelineType.connection_type, null: false
    argument :status,
      Types::Ci::PipelineStatusEnum,
      required: false,
      description: "Filter pipelines by their status."
    argument :scope, ::Types::Ci::PipelineScopeEnum,
      required: false,
      description: 'Filter pipelines by scope.'
    argument :ref,
      GraphQL::Types::String,
      required: false,
      description: "Filter pipelines by the ref they are run for."
    argument :sha,
      GraphQL::Types::String,
      required: false,
      description: "Filter pipelines by the sha of the commit they are run for."
    argument :source,
      GraphQL::Types::String,
      required: false,
      description: "Filter pipelines by their source."

    argument :updated_after, Types::TimeType,
      required: false,
      description: 'Pipelines updated after the date.'
    argument :updated_before, Types::TimeType,
      required: false,
      description: 'Pipelines updated before the date.'

    argument :username,
      GraphQL::Types::String,
      required: false,
      description: "Filter pipelines by the user that triggered the pipeline."
  end

  class_methods do
    def resolver_complexity(args, child_complexity:)
      complexity = super
      complexity += 2 if args[:sha]
      complexity += 2 if args[:ref]

      complexity
    end
  end

  def resolve_pipelines(project, params = {})
    pipelines = Ci::PipelinesFinder.new(project, context[:current_user], params).execute

    if %w[branches tags].include?(params[:scope])
      # `branches` and `tags` scopes are ordered in a complex way that is not supported by the keyset pagination.
      # We offset pagination here so we return the correct connection.
      offset_pagination(pipelines)
    else
      pipelines
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/resolves_project.rb =====
# frozen_string_literal: true

module ResolvesProject
  # Accepts EITHER one of
  #  - full_path: String (see Project#full_path)
  #  - project_id: GlobalID. Arguments should be typed as: `::Types::GlobalIDType[Project]`
  def resolve_project(full_path: nil, project_id: nil)
    unless full_path.present? ^ project_id.present?
      raise ::Gitlab::Graphql::Errors::ArgumentError, 'Incompatible arguments: projectId, projectPath.'
    end

    if full_path.present?
      ::Gitlab::Graphql::Loaders::FullPathModelLoader.new(Project, full_path).find
    else
      ::GitlabSchema.object_from_id(project_id, expected_type: Project)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/resolves_snippets.rb =====
# frozen_string_literal: true

module ResolvesSnippets
  extend ActiveSupport::Concern
  include ResolvesIds

  included do
    type Types::SnippetType.connection_type, null: true

    argument :ids, [::Types::GlobalIDType[::Snippet]],
      required: false,
      description: 'Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`.'

    argument :visibility, Types::Snippets::VisibilityScopesEnum,
      required: false,
      description: 'Visibility of the snippet.'
  end

  def resolve(**args)
    resolve_snippets(args)
  end

  private

  def resolve_snippets(args)
    SnippetsFinder.new(context[:current_user], snippet_finder_params(args)).execute
  end

  def snippet_finder_params(args)
    {
      ids: resolve_ids(args[:ids]),
      scope: args[:visibility]
    }.merge(options_by_type(args[:type]))
  end

  def options_by_type(type)
    case type
    when 'personal'
      { only_personal: true }
    when 'project'
      { only_project: true }
    else
      {}
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/search_arguments.rb =====
# frozen_string_literal: true

module SearchArguments
  extend ActiveSupport::Concern
  include Gitlab::Graphql::Authorize::AuthorizeResource

  included do
    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query for title or description.'
    argument :in, [Types::IssuableSearchableFieldEnum],
      required: false,
      description: <<~DESC
               Specify the fields to perform the search in.
               Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
      DESC
  end

  def ready?(**args)
    validate_search_in_params!(args)
    validate_search_rate_limit!(args)

    super
  end

  private

  def validate_search_in_params!(args)
    return unless args[:in].present? && args[:search].blank?

    raise Gitlab::Graphql::Errors::ArgumentError,
      '`search` should be present when including the `in` argument'
  end

  def validate_search_rate_limit!(args)
    return if args[:search].blank? || context[:request].nil?

    if current_user.present?
      rate_limiter_key = :search_rate_limit
      rate_limiter_scope = [current_user]
    else
      rate_limiter_key = :search_rate_limit_unauthenticated
      rate_limiter_scope = [context[:request].ip]
    end

    if ::Gitlab::ApplicationRateLimiter.throttled_request?(
      context[:request],
      current_user,
      rate_limiter_key,
      scope: rate_limiter_scope
    )
      error_msg = <<~ERR.squish
        This endpoint has been requested with the search argument too many times. Try again later.
      ERR

      raise_resource_not_available_error! error_msg
    end
  end

  def prepare_finder_params(args)
    prepare_search_params(args)
  end

  def prepare_search_params(args)
    return args unless args[:search].present?

    args[:in] = args[:in].join(',') if args[:in].present?
    set_search_optimization_param(args)

    args
  end

  def set_search_optimization_param(args)
    return args unless respond_to?(:resource_parent, true) && resource_parent.present?

    parent_type = resource_parent.is_a?(Project) ? :project : :group
    args[:"attempt_#{parent_type}_search_optimizations"] = true

    args
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/time_frame_arguments.rb =====
# frozen_string_literal: true

module TimeFrameArguments
  extend ActiveSupport::Concern

  include TimeFrameHelpers

  included do
    argument :timeframe, Types::TimeframeInputType,
      required: false,
      description: 'List items overlapping the given timeframe.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/time_frame_helpers.rb =====
# frozen_string_literal: true

module TimeFrameHelpers
  extend ActiveSupport::Concern

  TIMEFRAME_LIMIT_YEARS = 3.5

  def transform_timeframe_parameters(args)
    return {} unless args[:timeframe]

    args[:timeframe].to_h.transform_keys { |k| :"#{k}_date" }
  end

  def validate_timeframe_limit!(timeframe)
    return unless timeframe && timeframe[:start] && timeframe[:end]

    start_date = timeframe[:start]
    end_date = timeframe[:end]

    start_date = start_date.is_a?(String) ? Date.parse(start_date) : start_date
    end_date = end_date.is_a?(String) ? Date.parse(end_date) : end_date

    years_difference = (end_date - start_date).to_f / 365.25

    return unless years_difference > TIMEFRAME_LIMIT_YEARS

    raise Gitlab::Graphql::Errors::ArgumentError,
      format(_('Timeframe cannot exceed %{limit} years for work item queries'), limit: TIMEFRAME_LIMIT_YEARS)
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/work_items/iteration_argument_helpers.rb =====
# frozen_string_literal: true

module WorkItems
  module IterationArgumentHelpers
    # Overridden in EE
  end
end

WorkItems::IterationArgumentHelpers.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/work_items/look_ahead_preloads.rb =====
# frozen_string_literal: true

module WorkItems
  module LookAheadPreloads
    extend ActiveSupport::Concern

    prepended do
      include ::LooksAhead
    end

    private

    def preloads
      {
        work_item_type: :work_item_type,
        web_url: { namespace: :route, project: [:project_namespace, {
          namespace: [:route, :namespace_settings_with_ancestors_inherited_settings]
        }] },
        widgets: { work_item_type: :enabled_widget_definitions },
        archived: :project
      }
    end

    def nested_preloads
      {
        widgets: widget_preloads,
        user_permissions: { update_work_item: :assignees },
        project: { jira_import_status: { project: :jira_imports } },
        author: {
          location: { author: :user_detail },
          gitpod_enabled: { author: :user_preference }
        }
      }
    end

    def widget_preloads
      {
        last_edited_by: :last_edited_by,
        assignees: :assignees_by_name_and_id,
        participants: WorkItem.participant_includes,
        parent: :work_item_parent,
        children: { work_item_children_by_relative_position: [:author, { project: :project_feature }] },
        milestone: { milestone: [:project, :group] },
        subscribed: [:assignees, :award_emoji, { notes: [:author, :award_emoji] }],
        award_emoji: { award_emoji: :awardable },
        due_date: :dates_source,
        start_date: :dates_source,
        closing_merge_requests: { merge_requests_closing_issues: { merge_request: [:target_project, :author] } }
      }
    end

    def unconditional_includes
      [
        {
          project: [:project_feature, :group]
        },
        :author,
        :work_item_type,
        *super
      ]
    end
  end
end

WorkItems::LookAheadPreloads.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/work_items/non_stable_cursor_sort_options.rb =====
# frozen_string_literal: true

module WorkItems
  module NonStableCursorSortOptions
    extend ActiveSupport::Concern

    NON_STABLE_CURSOR_SORTS = %i[priority_asc priority_desc
      popularity_asc popularity_desc
      label_priority_asc label_priority_desc
      milestone_due_asc milestone_due_desc
      escalation_status_asc escalation_status_desc].freeze

    private

    def non_stable_cursor_sort?(sort)
      NON_STABLE_CURSOR_SORTS.include?(sort)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/concerns/work_items/shared_filter_arguments.rb =====
# frozen_string_literal: true

module WorkItems
  module SharedFilterArguments
    extend ActiveSupport::Concern
    extend Gitlab::Utils::Override

    included do
      argument :author_username,
        GraphQL::Types::String,
        required: false,
        description: 'Filter work items by author username.'
      argument :confidential,
        GraphQL::Types::Boolean,
        required: false,
        description: 'Filter for confidential work items. If `false`, excludes confidential work items. ' \
          'If `true`, returns only confidential work items.'
      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Usernames of users assigned to the work item.'
      argument :assignee_wildcard_id, ::Types::AssigneeWildcardIdEnum,
        required: false,
        description: 'Filter by assignee wildcard. Incompatible with `assigneeUsernames`.'
      argument :label_name, [GraphQL::Types::String],
        required: false,
        description: 'Labels applied to the work item.'
      argument :milestone_title, [GraphQL::Types::String],
        required: false,
        description: 'Milestone applied to the work item.'
      argument :milestone_wildcard_id, ::Types::MilestoneWildcardIdEnum,
        required: false,
        description: 'Filter by milestone ID wildcard. Incompatible with `milestoneTitle`.'
      argument :my_reaction_emoji, GraphQL::Types::String,
        required: false,
        description: 'Filter by reaction emoji applied by the current user. ' \
          'Wildcard values `NONE` and `ANY` are supported.'
      argument :iids,
        [GraphQL::Types::String],
        required: false,
        description: 'List of IIDs of work items. For example, `["1", "2"]`.'
      argument :state,
        ::Types::IssuableStateEnum,
        required: false,
        description: 'Current state of the work item.',
        prepare: ->(state, _ctx) {
          return state unless state == 'locked'

          raise Gitlab::Graphql::Errors::ArgumentError, ::Types::IssuableStateEnum::INVALID_LOCKED_MESSAGE
        }
      argument :types,
        [::Types::IssueTypeEnum],
        as: :issue_types,
        description: 'Filter work items by the given work item types.',
        required: false

      argument :created_before, ::Types::TimeType,
        required: false,
        description: 'Work items created before the timestamp.'
      argument :created_after, ::Types::TimeType,
        required: false,
        description: 'Work items created after the timestamp.'

      argument :updated_before, ::Types::TimeType,
        required: false,
        description: 'Work items updated before the timestamp.'
      argument :updated_after, ::Types::TimeType,
        required: false,
        description: 'Work items updated after the timestamp.'

      argument :due_before, ::Types::TimeType,
        required: false,
        description: 'Work items due before the timestamp.'
      argument :due_after, ::Types::TimeType,
        required: false,
        description: 'Work items due after the timestamp.'

      argument :closed_before, ::Types::TimeType,
        required: false,
        description: 'Work items closed before the date.'
      argument :closed_after, ::Types::TimeType,
        required: false,
        description: 'Work items closed after the date.'

      argument :subscribed, ::Types::Issuables::SubscriptionStatusEnum,
        description: 'Work items the current user is subscribed to.',
        required: false

      argument :not, ::Types::WorkItems::NegatedWorkItemFilterInputType,
        description: 'Negated work item arguments.',
        required: false,
        prepare: ->(value, _ctx) {
          value.to_h
        }
      argument :or, ::Types::WorkItems::UnionedWorkItemFilterInputType,
        description: 'List of arguments with inclusive `OR`.',
        required: false,
        prepare: ->(value, _ctx) {
          value.to_h
        }

      argument :hierarchy_filters, ::Types::WorkItems::HierarchyFilterInputType,
        description: 'Filtering options related to the work item hierarchy.',
        required: false,
        experiment: { milestone: '18.3' }

      argument :parent_ids, [::Types::GlobalIDType[::WorkItem]],
        description: 'Filter work items by global IDs of their parent items (maximum is 100 items).',
        required: false,
        prepare: ->(global_ids, _ctx) { GitlabSchema.parse_gids(global_ids, expected_type: ::WorkItem).map(&:model_id) }

      argument :include_descendant_work_items, GraphQL::Types::Boolean,
        description: 'Whether to include work items of descendant parents when filtering by parent_ids.',
        required: false,
        experiment: { milestone: '18.3' }

      argument :release_tag, [GraphQL::Types::String],
        required: false,
        description: "Release tag associated with the work item's milestone. Ignored when parent is a group."
      argument :release_tag_wildcard_id, ::Types::ReleaseTagWildcardIdEnum,
        required: false,
        description: 'Filter by release tag wildcard.'
      argument :crm_contact_id, GraphQL::Types::String,
        required: false,
        description: 'Filter by ID of CRM contact.'
      argument :crm_organization_id, GraphQL::Types::String,
        required: false,
        description: 'Filter by ID of CRM contact organization.'

      validates mutually_exclusive: [:assignee_usernames, :assignee_wildcard_id]
      validates mutually_exclusive: [:milestone_title, :milestone_wildcard_id]
      validates mutually_exclusive: [:release_tag, :release_tag_wildcard_id]

      validates mutually_exclusive: [:hierarchy_filters, :parent_ids]
      validates mutually_exclusive: [:hierarchy_filters, :include_descendant_work_items]
    end

    MAX_IDS_LIMIT = 100

    def resolve(**args)
      validate_field_limits(args, :parent_ids, :release_tag)
      validate_field_limits(args[:hierarchy_filters], :parent_ids) if args[:hierarchy_filters].present?
      validate_field_limits(args[:not], :parent_ids, :release_tag) if args[:not].present?

      super
    end

    private

    override :prepare_finder_params
    def prepare_finder_params(args)
      params = super

      rewrite_param_name(params, :assignee_usernames, :assignee_username)
      rewrite_param_name(params[:or], :assignee_usernames, :assignee_username)
      rewrite_param_name(params[:not], :assignee_usernames, :assignee_username)
      rewrite_param_name(params, :assignee_wildcard_id, :assignee_id)

      rewrite_param_name(params[:or], :author_usernames, :author_username)
      rewrite_param_name(params[:or], :label_names, :label_name)

      # Must be called before we rewrite the parent_ids param below
      unpack_parent_filtering_args!(params)

      rewrite_param_name(params, :parent_ids, :work_item_parent_ids)
      rewrite_param_name(params[:not], :parent_ids, :work_item_parent_ids)

      rewrite_param_name(params, :release_tag_wildcard_id, :release_tag)

      params
    end

    def rewrite_param_name(params, old_name, new_name)
      params[new_name] = params.delete(old_name) if params && params[old_name].present?
    end

    def validate_field_limits(params, *fields)
      return unless params

      fields.each do |field|
        if Array(params[field]).size > MAX_IDS_LIMIT
          raise GraphQL::ExecutionError,
            "You can only provide up to #{MAX_IDS_LIMIT} #{field.to_s.camelize(:lower)} at once."
        end
      end
    end

    def unpack_parent_filtering_args!(params)
      return unless params&.dig(:hierarchy_filters)

      wi_hierarchy_filtering = params.delete(:hierarchy_filters).to_h

      params.merge!(
        wi_hierarchy_filtering.slice(:parent_ids, :include_descendant_work_items, :parent_wildcard_id).compact
      )
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/container_repositories_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ContainerRepositoriesResolver < BaseResolver
    include ::Mutations::PackageEventable

    type Types::ContainerRegistry::ContainerRepositoryType, null: true

    argument :name, GraphQL::Types::String,
      required: false,
      description: 'Filter the container repositories by their name.'

    argument :sort, Types::ContainerRegistry::ContainerRepositorySortEnum,
      description: 'Sort container repositories by the criteria.',
      required: false,
      default_value: :created_desc

    def resolve(name: nil, sort: nil)
      ContainerRepositoriesFinder.new(user: current_user, subject: object, params: { name: name, sort: sort })
                                 .execute
                                 .tap { track_event(:list_repositories, :container) }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/container_repository_tags_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ContainerRepositoryTagsResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::ContainerRegistry::ContainerRepositoryTagType.connection_type, null: true

    argument :sort, Types::ContainerRegistry::ContainerRepositoryTagsSortEnum,
      description: 'Sort tags by these criteria.',
      required: false,
      default_value: nil

    argument :name, GraphQL::Types::String,
      description: 'Search by tag name.',
      required: false,
      default_value: nil

    argument :referrers, GraphQL::Types::Boolean,
      description: 'Include tag referrers.',
      required: false,
      default_value: nil

    argument :referrer_type, GraphQL::Types::String,
      description: 'Comma-separated list of artifact types used to filter referrers. Applies only when `referrers` is set to `true`.',
      required: false,
      default_value: nil

    alias_method :container_repository, :object

    def resolve(sort:, **filters)
      if container_repository.gitlab_api_client.supports_gitlab_api?
        page_size = [filters[:first], filters[:last]].map(&:to_i).max

        result = container_repository.tags_page(
          before: filters[:before],
          last: filters[:after],
          sort: map_sort_field(sort),
          name: filters[:name],
          page_size: page_size,
          referrers: filters[:referrers],
          referrer_type: filters[:referrer_type]
        )

        Gitlab::Graphql::ExternallyPaginatedArray.new(
          parse_pagination_cursor(result, :previous),
          parse_pagination_cursor(result, :next),
          *result[:tags]
        )
      else
        result = tags

        if filters[:name]
          result = tags.filter do |tag|
            tag.name.include?(filters[:name])
          end
        end

        result = sort_tags(result, sort) if sort
        result
      end
    end

    private

    def parse_pagination_cursor(result, direction)
      pagination_uri = result.dig(:pagination, direction, :uri)

      return unless pagination_uri

      query_params =  CGI.parse(pagination_uri.query)
      key = direction == :previous ? 'before' : 'last'

      query_params[key]&.first
    end

    def map_sort_field(sort_value)
      return if sort_value.blank?

      sort = sort_value.to_s.gsub(/_(desc|asc)$/, '')
      sort = "-#{sort}" if sort_value.end_with?('_desc')

      sort
    end

    def sort_tags(to_be_sorted, sort)
      raise StandardError unless Types::ContainerRegistry::ContainerRepositoryTagsSortEnum.enum.include?(sort)

      sort_value, _, direction = sort.to_s.rpartition('_')

      sorted = to_be_sorted.sort_by(&sort_value.to_sym)
      return sorted.reverse if direction == 'desc'

      sorted
    end

    def tags
      container_repository.tags
    rescue Faraday::Error
      raise_resource_not_available_error! "Can't connect to the container registry. If this error persists, please review the troubleshooting documentation."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/crm/contacts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Crm
    class ContactsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include ResolvesIds

      authorize :read_crm_contact

      type Types::CustomerRelations::ContactType, null: true

      argument :sort, Types::CustomerRelations::ContactSortEnum,
        description: 'Criteria to sort contacts by.',
        required: false,
        default_value: { field: 'last_name', direction: :asc }

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search term to find contacts with.'

      argument :state, Types::CustomerRelations::ContactStateEnum,
        required: false,
        description: 'State of the contacts to search for.'

      argument :ids, [::Types::GlobalIDType[CustomerRelations::Contact]],
        required: false,
        description: 'Filter contacts by IDs.'

      def resolve(**args)
        args[:ids] = resolve_ids(args.delete(:ids))
        args.delete(:state) if args[:state] == :all

        contacts = ::Crm::ContactsFinder.new(current_user, { group: group }.merge(args)).execute
        if needs_offset?(args)
          offset_pagination(contacts)
        else
          contacts
        end
      end

      def group
        object.respond_to?(:sync) ? object.sync : object
      end

      private

      def needs_offset?(args)
        args.key?(:sort) && args[:sort][:field] == 'organization'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/crm/contact_state_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Crm
    class ContactStateCountsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :read_crm_contact

      type Types::CustomerRelations::ContactStateCountsType, null: true

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search term to find contacts with.'

      argument :state, Types::CustomerRelations::ContactStateEnum,
        required: false,
        description: 'State of the contacts to search for.'

      def resolve(**args)
        CustomerRelations::ContactStateCounts.new(context[:current_user], object, args)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/crm/organizations_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Crm
    class OrganizationsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include ResolvesIds

      authorize :read_crm_organization

      type Types::CustomerRelations::OrganizationType, null: true

      argument :sort, Types::CustomerRelations::OrganizationSortEnum,
        description: 'Criteria to sort organizations by.',
        required: false,
        default_value: { field: 'name', direction: :asc }

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search term used to find organizations with.'

      argument :state, Types::CustomerRelations::OrganizationStateEnum,
        required: false,
        description: 'State of the organization to search for.'

      argument :ids, [Types::GlobalIDType[CustomerRelations::Organization]],
        required: false,
        description: 'Filter organizations by IDs.'

      def resolve(**args)
        args[:ids] = resolve_ids(args.delete(:ids))
        args.delete(:state) if args[:state] == :all

        ::Crm::OrganizationsFinder.new(current_user, { group: group }.merge(args)).execute
      end

      def group
        object.respond_to?(:sync) ? object.sync : object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/crm/organization_state_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Crm
    class OrganizationStateCountsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :read_crm_organization
      authorizes_object!

      type Types::CustomerRelations::OrganizationStateCountsType, null: true

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search term to find organizations with.'

      argument :state, Types::CustomerRelations::OrganizationStateEnum,
        required: false,
        description: 'State of the organizations to search for.'

      def resolve(**args)
        ::Crm::OrganizationsFinder.counts_by_state(context[:current_user], args.merge({ group: object }))
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/custom_emoji_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class CustomEmojiResolver < BaseResolver
    include LooksAhead
    include Gitlab::Graphql::Authorize::AuthorizeResource

    authorizes_object!

    authorize :read_custom_emoji

    argument :include_ancestor_groups,
      GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Includes custom emoji from parent groups.'

    type Types::CustomEmojiType, null: true

    def resolve_with_lookahead(**args)
      apply_lookahead(::Groups::CustomEmojiFinder.new(object, args).execute)
    end

    private

    def unconditional_includes
      [:group]
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/data_transfer/data_transfer_arguments.rb =====
# frozen_string_literal: true

module Resolvers
  module DataTransfer
    module DataTransferArguments
      extend ActiveSupport::Concern

      included do
        argument :from, Types::DateType,
          description:
            'Retain egress data for one year. Data for the current month will increase dynamically as egress occurs.',
          required: false
        argument :to, Types::DateType,
          description: 'End date for the data.',
          required: false
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/data_transfer/group_data_transfer_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DataTransfer
    class GroupDataTransferResolver < BaseResolver
      include DataTransferArguments
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorizes_object!
      authorize :read_usage_quotas

      type Types::DataTransfer::GroupDataTransferType, null: false

      alias_method :group, :object

      def resolve(**args)
        return { egress_nodes: [] } unless Feature.enabled?(:data_transfer_monitoring, group)

        results = ::DataTransfer::GroupDataTransferFinder.new(
          group: group,
          from: args[:from],
          to: args[:to],
          user: current_user
        ).execute.map(&:attributes)

        { egress_nodes: results.to_a }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/data_transfer/project_data_transfer_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DataTransfer
    class ProjectDataTransferResolver < BaseResolver
      include DataTransferArguments
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorizes_object!
      authorize :read_usage_quotas

      type Types::DataTransfer::ProjectDataTransferType, null: false

      alias_method :project, :object

      def resolve(**args)
        return { egress_nodes: [] } unless Feature.enabled?(:data_transfer_monitoring, project.group)

        results = ::DataTransfer::ProjectDataTransferFinder.new(
          project: project,
          from: args[:from],
          to: args[:to],
          user: current_user
        ).execute

        { egress_nodes: results }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/deployment_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class DeploymentResolver < BaseResolver
    argument :iid, # rubocop:disable Graphql/IDType -- Legacy argument using ID type kept for backwards compatibility
      GraphQL::Types::ID,
      required: true,
      description: 'Project-level internal ID of the Deployment.'

    type Types::DeploymentType, null: true

    alias_method :project, :object

    def resolve(iid:)
      return unless project.present? && project.is_a?(::Project)

      Deployment.for_iid(project, iid)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/deployments_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class DeploymentsResolver < BaseResolver
    argument :statuses, [Types::DeploymentStatusEnum],
      description: 'Statuses of the deployments.',
      required: false,
      as: :status

    argument :order_by, Types::DeploymentsOrderByInputType,
      description: 'Order by a specified field.',
      required: false

    type Types::DeploymentType, null: true

    alias_method :environment, :object

    def resolve(**args)
      return unless environment.present? && environment.is_a?(::Environment)

      args = transform_args_for_finder(**args)

      # GraphQL BatchLoader shouldn't be used here because pagination query will be inefficient
      # that fetches thousands of rows before limiting and offsetting.
      DeploymentsFinder.new(environment: environment.id, **args).execute
    end

    private

    def transform_args_for_finder(**args)
      if (order_by = args.delete(:order_by))
        order_by = order_by.to_h.map { |k, v| { order_by: k.to_s, sort: v } }.first
        args.merge!(order_by)
      end

      args
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/design_at_version_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    class DesignAtVersionResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::DesignManagement::DesignAtVersionType, null: false

      authorize :read_design

      argument :id, ::Types::GlobalIDType[::DesignManagement::DesignAtVersion],
        required: true,
        description: 'Global ID of the design at the version.'

      def resolve(id:)
        authorized_find!(id: id)
      end

      def find_object(id:)
        dav = GitlabSchema.find_by_gid(id)
        return unless consistent?(dav)

        dav
      end

      def self.single
        self
      end

      private

      # If this resolver is mounted on something that has an issue
      # (such as design collection for instance), then we should check
      # that the DesignAtVersion as found by its ID does in fact belong
      # to this issue.
      def consistent?(dav)
        issue.nil? || (dav.present? && dav.design&.issue_id == issue.id)
      end

      def issue
        object&.issue
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/design_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    class DesignResolver < BaseResolver
      type ::Types::DesignManagement::DesignType, null: true

      requires_argument!

      argument :id, ::Types::GlobalIDType[::DesignManagement::Design],
        required: false,
        description: 'Find a design by its ID.'

      argument :filename, GraphQL::Types::String,
        required: false,
        description: 'Find a design by its filename.'

      def resolve(filename: nil, id: nil)
        params = parse_args(filename, id)

        build_finder(params).execute.first
      end

      def self.single
        self
      end

      private

      def issue
        object.issue
      end

      def build_finder(params)
        ::DesignManagement::DesignsFinder.new(issue, current_user, params)
      end

      def error(msg)
        raise ::Gitlab::Graphql::Errors::ArgumentError, msg
      end

      def parse_args(filename, id)
        provided = [filename, id].map(&:present?)

        if provided.none?
          error('one of id or filename must be passed')
        elsif provided.all?
          error('only one of id or filename may be passed')
        elsif filename.present?
          { filenames: [filename] }
        else
          { ids: [parse_gid(id)] }
        end
      end

      def parse_gid(gid)
        gid.model_id
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/designs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    class DesignsResolver < BaseResolver
      DesignID = ::Types::GlobalIDType[::DesignManagement::Design]
      VersionID = ::Types::GlobalIDType[::DesignManagement::Version]

      type ::Types::DesignManagement::DesignType.connection_type, null: true

      argument :at_version, VersionID,
        required: false,
        description: 'Filters designs to only those that existed at the version. ' \
          'If argument is omitted or nil then all designs will reflect the latest version'
      argument :filenames, [GraphQL::Types::String],
        required: false,
        description: 'Filters designs by their filename.'
      argument :ids, [DesignID],
        required: false,
        description: 'Filters designs by their ID.'

      def self.single
        ::Resolvers::DesignManagement::DesignResolver
      end

      def resolve(ids: nil, filenames: nil, at_version: nil)
        context.scoped_set!(:at_version_argument, at_version) if at_version

        ::Gitlab::Graphql::Lazy.with_value(version(at_version)) do |visible_at|
          ::DesignManagement::DesignsFinder.new(
            issue,
            current_user,
            ids: design_ids(ids),
            filenames: filenames,
            visible_at_version: visible_at
          ).execute
        end
      end

      private

      def version(at_version)
        return unless at_version

        GitlabSchema.find_by_gid(at_version)
      end

      def design_ids(gids)
        return if gids.nil?

        gids.map(&:model_id)
      end

      def issue
        object.issue
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/version/design_at_version_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    module Version
      # Resolver for a DesignAtVersion object given an implicit version context
      class DesignAtVersionResolver < BaseResolver
        DesignAtVersionID = ::Types::GlobalIDType[::DesignManagement::DesignAtVersion]
        DesignID = ::Types::GlobalIDType[::DesignManagement::Design]

        include Gitlab::Graphql::Authorize::AuthorizeResource

        type Types::DesignManagement::DesignAtVersionType, null: true

        requires_argument!

        authorize :read_design

        argument :design_id, DesignID,
          required: false,
          description: 'ID of a specific design.'
        argument :filename, GraphQL::Types::String,
          required: false,
          description: 'Filename of a specific design.'
        argument :id, DesignAtVersionID,
          required: false,
          as: :design_at_version_id,
          description: 'ID of the DesignAtVersion.'

        def self.single
          self
        end

        def resolve(design_id: nil, filename: nil, design_at_version_id: nil)
          validate_arguments(design_id, filename, design_at_version_id)

          return unless Ability.allowed?(current_user, :read_design, issue)
          return specific_design_at_version(design_at_version_id) if design_at_version_id

          find(design_id, filename).map { |d| make(d) }.first
        end

        private

        def validate_arguments(design_id, filename, design_at_version_id)
          args = { filename: filename, id: design_at_version_id, design_id: design_id }
          passed = args.compact.keys

          return if passed.size == 1

          msg = "Exactly one of #{args.keys.join(', ')} expected, got #{passed}"

          raise Gitlab::Graphql::Errors::ArgumentError, msg
        end

        def specific_design_at_version(id)
          dav = GitlabSchema.find_by_gid(id)
          return unless consistent?(dav)

          dav
        end

        # Test that the DAV found by ID actually belongs on this version, and
        # that it is visible at this version.
        def consistent?(dav)
          return false unless dav.present?

          dav.design.issue_id == issue.id &&
            dav.version.id == version.id &&
            dav.design.visible_in?(version)
        end

        def find(gid, filename)
          ids = [gid.model_id] if gid
          filenames = [filename] if filename

          ::DesignManagement::DesignsFinder
            .new(issue, current_user, ids: ids, filenames: filenames, visible_at_version: version)
            .execute
        end

        def issue
          version.issue
        end

        def version
          object
        end

        def make(design)
          ::DesignManagement::DesignAtVersion.new(design: design, version: version)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/version/designs_at_version_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    module Version
      # Resolver for DesignAtVersion objects given an implicit version context
      class DesignsAtVersionResolver < BaseResolver
        include Gitlab::Graphql::Authorize::AuthorizeResource

        type Types::DesignManagement::DesignAtVersionType, null: true

        authorize :read_design

        DesignID = ::Types::GlobalIDType[::DesignManagement::Design]

        argument :filenames,
          [GraphQL::Types::String],
          required: false,
          description: 'Filters designs by their filename.'
        argument :ids, [DesignID],
          required: false,
          description: 'Filters designs by their ID.'

        def self.single
          ::Resolvers::DesignManagement::Version::DesignAtVersionResolver
        end

        def resolve(ids: nil, filenames: nil)
          find(ids, filenames).execute.map { |d| make(d) }
        end

        private

        def find(ids, filenames)
          ::DesignManagement::DesignsFinder.new(issue, current_user,
            ids: design_ids(ids),
            filenames: filenames,
            visible_at_version: version)
        end

        def design_ids(gids)
          return if gids.nil?

          gids.map(&:model_id)
        end

        def issue
          version.issue
        end

        def version
          object
        end

        def make(design)
          ::DesignManagement::DesignAtVersion.new(design: design, version: version)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/version_in_collection_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    class VersionInCollectionResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::DesignManagement::VersionType, null: true

      requires_argument!

      authorize :read_design

      alias_method :collection, :object

      VersionID = ::Types::GlobalIDType[::DesignManagement::Version]

      argument :id, VersionID,
        as: :version_id,
        required: false,
        description: 'Global ID of the version.'
      argument :sha, GraphQL::Types::String,
        required: false,
        description: "SHA256 of a specific version."

      def resolve(version_id: nil, sha: nil)
        check_args(version_id, sha)

        ::DesignManagement::VersionsFinder
          .new(collection, current_user, sha: sha, version_id: version_id&.model_id)
          .execute
          .first
      end

      def self.single
        self
      end

      private

      def check_args(id, sha)
        return if id.present? || sha.present?

        raise ::Gitlab::Graphql::Errors::ArgumentError, 'one of id or sha is required'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/version_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    class VersionResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::DesignManagement::VersionType, null: true

      authorize :read_design

      argument :id, ::Types::GlobalIDType[::DesignManagement::Version],
        required: true,
        description: 'Global ID of the version.'

      def resolve(id:)
        authorized_find!(id: id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/design_management/versions_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module DesignManagement
    class VersionsResolver < BaseResolver
      type Types::DesignManagement::VersionType.connection_type, null: false

      alias_method :design_or_collection, :object

      VersionID = ::Types::GlobalIDType[::DesignManagement::Version]

      argument :earlier_or_equal_to_sha, GraphQL::Types::String,
        as: :sha,
        required: false,
        description: 'SHA256 of the most recent acceptable version.'

      argument :earlier_or_equal_to_id, VersionID,
        as: :id,
        required: false,
        description: 'Global ID of the most recent acceptable version.'

      # This resolver has a custom singular resolver
      def self.single
        ::Resolvers::DesignManagement::VersionInCollectionResolver
      end

      def resolve(id: nil, sha: nil)
        version = cutoff(id, sha)

        raise_resource_not_available_error! 'cutoff not found' unless version.present?

        if version == :unconstrained
          find
        else
          find(earlier_or_equal_to: version)
        end
      end

      private

      # Find the most recent version that the client will accept
      def cutoff(id, sha)
        if sha.present? || id.present?
          specific_version(id, sha)
        else
          :unconstrained
        end
      end

      def specific_version(gid, sha)
        find(sha: sha, version_id: gid&.model_id).first
      end

      def find(**params)
        ::DesignManagement::VersionsFinder
          .new(design_or_collection, current_user, params)
          .execute
          .with_author
      end

      def by_id(gid)
        ::Gitlab::Graphql::Lazy.force(GitlabSchema.find_by_gid(gid))
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/down_votes_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class DownVotesCountResolver < Resolvers::AwardEmoji::BaseVotesCountResolver
    type GraphQL::Types::Int, null: true

    def resolve
      authorize!(object)
      votes_batch_loader.load_downvotes(object)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/echo_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class EchoResolver < BaseResolver
    type ::GraphQL::Types::String, null: false
    description 'Testing endpoint to validate the API with'

    argument :text,
      type: GraphQL::Types::String,
      required: true,
      description: 'Text to echo back.'

    def resolve(text:)
      username = current_user&.username

      "#{username.inspect} says: #{text}"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/environments/last_deployment_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Environments
    class LastDeploymentResolver < BaseResolver
      argument :status,
        Types::DeploymentStatusEnum,
        required: true,
        description: 'Status of the Deployment.'

      type Types::DeploymentType, null: true

      def resolve(status:)
        return unless object.present? && object.is_a?(::Environment)

        validate!(status)

        find_last_deployment(status)
      end

      private

      def find_last_deployment(status)
        BatchLoader::GraphQL.for(object).batch(key: status) do |environments, loader, args|
          association_name = :"last_#{args[:key]}_deployment"

          Preloaders::Environments::DeploymentPreloader.new(environments)
            .execute_with_union(association_name, {})

          environments.each do |environment|
            loader.call(environment, environment.public_send(association_name)) # rubocop:disable GitlabSecurity/PublicSend
          end
        end
      end

      def validate!(status)
        unless Deployment::FINISHED_STATUSES.include?(status.to_sym) ||
            Deployment::UPCOMING_STATUSES.include?(status.to_sym)
          raise Gitlab::Graphql::Errors::ArgumentError, "\"#{status}\" status is not supported."
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/environments/nested_environments_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Environments
    class NestedEnvironmentsResolver < EnvironmentsResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::NestedEnvironmentType, null: true

      authorizes_object!
      authorize :read_environment

      def resolve(**args)
        offset_pagination(super.nested)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/environments_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class EnvironmentsResolver < BaseResolver
    argument :name, GraphQL::Types::String,
      required: false,
      description: 'Name of the environment.'

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query for environment name.'

    argument :states, [GraphQL::Types::String],
      required: false,
      description: 'States of environments that should be included in result.'

    argument :type, GraphQL::Types::String,
      required: false,
      description: 'Search query for environment type.'

    type Types::EnvironmentType, null: true

    alias_method :project, :object

    def resolve(**args)
      return unless project.present?

      ::Environments::EnvironmentsFinder.new(project, context[:current_user], args).execute
    rescue ::Environments::EnvironmentsFinder::InvalidStatesError => e
      raise Gitlab::Graphql::Errors::ArgumentError, e.message
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/error_tracking/sentry_detailed_error_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module ErrorTracking
    class SentryDetailedErrorResolver < BaseResolver
      type Types::ErrorTracking::SentryDetailedErrorType, null: true

      argument :id, ::Types::GlobalIDType[::Gitlab::ErrorTracking::DetailedError],
        required: true,
        description: 'ID of the Sentry issue.'

      def resolve(id:)
        # Get data from Sentry
        response = ::ErrorTracking::IssueDetailsService.new(
          project,
          current_user,
          { issue_id: id.model_id, tracking_event: :error_tracking_view_details }
        ).execute
        issue = response[:issue]
        issue.gitlab_project = project if issue

        issue
      end

      private

      def project
        return object.gitlab_project if object.respond_to?(:gitlab_project)

        object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/error_tracking/sentry_error_collection_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module ErrorTracking
    class SentryErrorCollectionResolver < BaseResolver
      type Types::ErrorTracking::SentryErrorCollectionType, null: true

      def resolve(**args)
        project = object

        service = ::ErrorTracking::ListIssuesService.new(
          project,
          context[:current_user]
        )

        Gitlab::ErrorTracking::ErrorCollection.new(
          external_url: service.external_url,
          project: project
        )
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/error_tracking/sentry_errors_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module ErrorTracking
    class SentryErrorsResolver < BaseResolver
      type Types::ErrorTracking::SentryErrorType.connection_type, null: true

      argument :search_term, ::GraphQL::Types::String,
        description: 'Search query for the Sentry error details.',
        required: false

      # TODO: convert to Enum
      argument :sort, ::GraphQL::Types::String,
        description: 'Attribute to sort on. Options are frequency, first_seen, last_seen. last_seen is default.',
        required: false

      delegate :project, to: :object

      def resolve(**args)
        args[:cursor] = args.delete(:after)

        result = ::ErrorTracking::ListIssuesService.new(project, current_user, args).execute

        next_cursor = result.dig(:pagination, 'next', 'cursor')
        previous_cursor = result.dig(:pagination, 'previous', 'cursor')
        issues = result[:issues]

        # ReactiveCache is still fetching data
        return if issues.nil?

        Gitlab::Graphql::ExternallyPaginatedArray.new(previous_cursor, next_cursor, *issues)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/error_tracking/sentry_error_stack_trace_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module ErrorTracking
    class SentryErrorStackTraceResolver < BaseResolver
      type Types::ErrorTracking::SentryErrorStackTraceType, null: true

      argument :id, ::Types::GlobalIDType[::Gitlab::ErrorTracking::DetailedError],
        required: true,
        description: 'ID of the Sentry issue.'

      def resolve(id:)
        # Get data from Sentry
        response = ::ErrorTracking::IssueLatestEventService.new(
          project,
          current_user,
          { issue_id: id.model_id }
        ).execute

        event = response[:latest_event]
        event.gitlab_project = project if event

        event
      end

      private

      def project
        return object.gitlab_project if object.respond_to?(:gitlab_project)

        object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/feature_flag_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class FeatureFlagResolver < BaseResolver
    type GraphQL::Types::Boolean, null: false

    argument :name, GraphQL::Types::String,
      required: true,
      description: 'Name of the feature flag.'

    def resolve(name:)
      return false unless current_user.present?

      Feature.enabled?(name.to_sym, current_user)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/full_path_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module FullPathResolver
    extend ActiveSupport::Concern

    included do
      argument :full_path, GraphQL::Types::ID,
        required: true,
        description: "Full path of the #{target_type}. For example, `gitlab-org/gitlab-foss`."
    end

    def model_by_full_path(model, full_path)
      ::Gitlab::Graphql::Loaders::FullPathModelLoader.new(model, full_path).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_environment_scopes_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupEnvironmentScopesResolver < BaseResolver
    type Types::Ci::GroupEnvironmentScopeType.connection_type, null: true

    alias_method :group, :object

    argument :name, GraphQL::Types::String,
      required: false,
      description: 'Name of the environment scope.'

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query for environment scope name.'

    def resolve(**args)
      return unless group.present?

      ::Groups::EnvironmentScopesFinder.new(group: group, params: args).execute
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_issues_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from Issues::BaseParentResolver
module Resolvers
  class GroupIssuesResolver < Issues::BaseParentResolver
    def self.issuable_collection_name
      'issues'
    end

    include GroupIssuableResolver

    before_connection_authorization do |nodes, _|
      projects = nodes.filter_map(&:project)
      ActiveRecord::Associations::Preloader.new(records: projects, associations: project_associations).call
    end

    def self.project_associations
      [:namespace]
    end

    def ready?(**args)
      if args.dig(:not, :release_tag).present?
        raise ::Gitlab::Graphql::Errors::ArgumentError, 'releaseTag filter is not allowed when parent is a group.'
      end

      super
    end
  end
end
# rubocop:enable Graphql/ResolverType

Resolvers::GroupIssuesResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_labels_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupLabelsResolver < LabelsResolver
    type Types::LabelType.connection_type, null: true

    argument :include_descendant_groups, GraphQL::Types::Boolean,
      required: false,
      description: 'Include labels from descendant groups.',
      default_value: false

    argument :only_group_labels, GraphQL::Types::Boolean,
      required: false,
      description: 'Include only group level labels.',
      default_value: false

    before_connection_authorization do |nodes, current_user|
      Preloaders::LabelsPreloader.new(nodes, current_user).preload_all
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_members/notification_email_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module GroupMembers
    class NotificationEmailResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type GraphQL::Types::String, null: true

      def resolve
        authorize!

        BatchLoader::GraphQL.for(object.user_id).batch do |user_ids, loader|
          User.find(user_ids).each do |user|
            loader.call(user.id, user.notification_email_for(object.group))
          end
        end
      end

      def authorize!
        raise_resource_not_available_error! unless user_is_admin?
      end

      def user_is_admin?
        context[:current_user].present? && context[:current_user].can_admin_all_resources?
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_members_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupMembersResolver < MembersResolver
    type Types::GroupMemberType.connection_type, null: true

    authorize :read_group_member

    argument :relations, [Types::GroupMemberRelationEnum],
      description: 'Filter members by the given member relations.',
      required: false,
      default_value: GroupMembersFinder::DEFAULT_RELATIONS

    argument :access_levels, [Types::AccessLevelEnum],
      description: 'Filter members by the given access levels.',
      required: false

    argument :enterprise, GraphQL::Types::Boolean,
      description: 'Filter members by enterprise users.',
      required: false

    private

    def finder_class
      GroupMembersFinder
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupMergeRequestsResolver < MergeRequestsResolver
    def self.issuable_collection_name
      'merge requests'
    end

    include GroupIssuableResolver

    alias_method :group, :object

    type Types::MergeRequestType.connection_type, null: true

    accept_assignee
    accept_reviewer
    accept_author

    def project
      nil
    end

    def mr_parent
      group
    end

    def no_results_possible?(args)
      group.nil? || some_argument_is_empty?(args)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_milestones_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupMilestonesResolver < MilestonesResolver
    include ::API::Concerns::Milestones::GroupProjectParams

    argument :include_ancestors, GraphQL::Types::Boolean,
      required: false,
      description: 'Include milestones from all parent groups.'
    argument :include_descendants, GraphQL::Types::Boolean,
      required: false,
      description: 'Include milestones from all subgroups and subprojects.'

    type Types::MilestoneType.connection_type, null: true

    private

    def parent_id_parameters(args)
      group_finder_params(parent, args)
    end

    def preloads
      super.merge({ subgroup_milestone: :group })
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_packages_resolver.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/ResolverType

module Resolvers
  class GroupPackagesResolver < PackagesBaseResolver
    # The GraphQL type is defined in the extended class

    extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

    argument :sort, Types::Packages::PackageGroupSortEnum,
      description: 'Sort packages by the criteria.',
      required: false,
      default_value: :created_desc

    GROUP_SORT_TO_PARAMS_MAP = SORT_TO_PARAMS_MAP.merge({
      project_path_desc: { order_by: 'project_path', sort: 'desc' },
      project_path_asc: { order_by: 'project_path', sort: 'asc' }
    }).freeze

    def resolve(sort:, **filters)
      return unless packages_available?

      params = filters.merge(GROUP_SORT_TO_PARAMS_MAP.fetch(sort))
      params[:preload_pipelines] = false

      ::Packages::GroupPackagesFinder.new(current_user, object, params).execute
    end
  end
end
# rubocop: enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_releases_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupReleasesResolver < BaseResolver
    type Types::ReleaseType.connection_type, null: true

    argument :sort, Types::GroupReleaseSortEnum,
      required: false, default_value: :released_at_desc,
      description: 'Sort group releases by given criteria.'

    alias_method :group, :object

    # GroupReleasesFinder only supports sorting by `released_at`
    SORT_TO_PARAMS_MAP = {
      released_at_desc: { sort: 'desc' },
      released_at_asc: { sort: 'asc' }
    }.freeze

    def resolve(sort:)
      releases = Releases::GroupReleasesFinder.new(
        group,
        current_user,
        SORT_TO_PARAMS_MAP[sort]
      ).execute
      # fix ordering problem with GroupReleasesFinder and keyset pagination
      # See more on https://gitlab.com/gitlab-org/gitlab/-/issues/378160
      offset_pagination(releases)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/group_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupResolver < BaseResolver
    def self.target_type
      'group'
    end

    include FullPathResolver

    type Types::GroupType, null: true

    def resolve(full_path:)
      model_by_full_path(Group, full_path)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/groups_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class GroupsResolver < BaseResolver
    include ResolvesGroups
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::GroupType.connection_type, null: true

    argument :ids, [GraphQL::Types::ID],
      required: false,
      description: 'Filter groups by IDs.',
      prepare: ->(global_ids, _ctx) { GitlabSchema.parse_gids(global_ids, expected_type: ::Group).map(&:model_id) }

    argument :top_level_only, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Only include top-level groups.'

    argument :owned_only, GraphQL::Types::Boolean,
      as: :owned,
      required: false,
      default_value: false,
      description: 'Only include groups where the current user has an owner role.'

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query for group name or group full path.'

    argument :sort, GraphQL::Types::String,
      required: false,
      description: "Sort order of results. Format: `<field_name>_<sort_direction>`, " \
        "for example: `id_desc` or `name_asc`",
      default_value: 'name_asc'

    argument :parent_path, GraphQL::Types::ID,
      required: false,
      description: 'Full path of the parent group.'

    argument :all_available, GraphQL::Types::Boolean,
      required: false,
      default_value: true,
      replace_null_with_default: true,
      description: <<~DESC
        When `true`, returns all accessible groups. When `false`, returns only groups where the user is a member.
        Unauthenticated requests always return all public groups. The `owned_only` argument takes precedence.
      DESC

    argument :marked_for_deletion_on, ::Types::DateType,
      required: false,
      description: 'Date when the group was marked for deletion.'

    argument :active, GraphQL::Types::Boolean,
      required: false,
      default_value: nil,
      description: 'When `nil` (default value), returns all groups. ' \
        'When `true`, returns only groups that are not pending deletion. ' \
        'When `false`, only returns groups that are pending deletion.'

    private

    def resolve_groups(parent_path: nil, **args)
      args[:parent] = find_authorized_parent!(parent_path) if parent_path
      args[:organization] = Current.organization.id

      GroupsFinder
        .new(context[:current_user], args)
        .execute
    end

    def find_authorized_parent!(path)
      group = Group.find_by_full_path(path)

      unless Ability.allowed?(current_user, :read_group, group)
        raise_resource_not_available_error! format(_('Could not find parent group with path %{path}'), path: path)
      end

      group
    end
  end
end

Resolvers::GroupsResolver.prepend_mod_with('Resolvers::GroupsResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/import/source_users_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Import
    class SourceUsersResolver < BaseResolver
      include ::LooksAhead
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorizes_object!
      authorize :admin_namespace

      type Types::Import::SourceUserType.connection_type, null: true

      argument :statuses, [::Types::Import::SourceUserStatusEnum],
        required: false,
        description: 'Filter mapping of users on source instance to users on destination instance by status.'

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Query to search mappings by name or username of users on source instance.'

      argument :sort, Types::Import::SourceUserSortEnum,
        description: 'Sort mapping of users on source instance to users on destination instance by the criteria.',
        required: false,
        default_value: :source_name_asc

      alias_method :namespace, :object

      def resolve_with_lookahead(**args)
        apply_lookahead(::Import::SourceUsersFinder.new(namespace, context[:current_user], args).execute)
      end

      private

      def preloads
        {
          reassign_to_user: [:reassign_to_user],
          placeholder_user: [:placeholder_user],
          reassigned_by_user: [:reassigned_by_user]
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/incident_management/timeline_events_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module IncidentManagement
    class TimelineEventsResolver < BaseResolver
      include LooksAhead

      alias_method :project, :object

      type ::Types::IncidentManagement::TimelineEventType.connection_type, null: true

      argument :incident_id,
        ::Types::GlobalIDType[::Issue],
        required: true,
        description: 'ID of the incident.'

      when_single do
        argument :id,
          ::Types::GlobalIDType[::IncidentManagement::TimelineEvent],
          required: true,
          description: 'ID of the timeline event.',
          prepare: ->(id, ctx) { id.model_id }
      end

      def resolve_with_lookahead(**args)
        incident = args[:incident_id].find
        raise GraphQL::ExecutionError, error_message if alert_is_disabled?(incident&.project)

        apply_lookahead(::IncidentManagement::TimelineEventsFinder.new(current_user, incident, args).execute)
      end

      def preloads
        {
          timeline_event_tags: [:timeline_event_tags]
        }
      end

      private

      def alert_is_disabled?(project)
        Feature.enabled?(:hide_incident_management_features, project)
      end

      def error_message
        "Field 'incidentManagementTimelineEvents' doesn't exist on type 'Project'."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/incident_management/timeline_event_tags_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module IncidentManagement
    class TimelineEventTagsResolver < BaseResolver
      include LooksAhead

      type ::Types::IncidentManagement::TimelineEventTagType.connection_type, null: true

      def resolve(**args)
        apply_lookahead(::IncidentManagement::TimelineEventTagsFinder.new(current_user, object, args).execute)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/integrations/exclusions_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Integrations
    class ExclusionsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Integrations::ExclusionType.connection_type, null: true

      argument :integration_name, Types::Integrations::IntegrationTypeEnum,
        required: true,
        description: 'Type of integration.'

      def resolve(integration_name:)
        authorize!
        Integration.integration_name_to_model(integration_name).with_custom_settings.by_active_flag(false)
      end

      def authorize!
        raise_resource_not_available_error! unless context[:current_user]&.can_admin_all_resources?
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/issues/base_parent_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Issues
    class BaseParentResolver < Issues::BaseResolver
      prepend ::Issues::LookAheadPreloads
      include ::Issues::SortArguments

      argument :state, Types::IssuableStateEnum,
        required: false,
        description: 'Current state of the issue.',
        prepare: ->(state, _ctx) {
          return state unless state == 'locked'

          raise Gitlab::Graphql::Errors::ArgumentError, Types::IssuableStateEnum::INVALID_LOCKED_MESSAGE
        }

      type Types::IssueType.connection_type, null: true

      def resolve_with_lookahead(**args)
        return Issue.none if resource_parent.nil?

        finder = IssuesFinder.new(current_user, prepare_finder_params(args))

        issues = Gitlab::Graphql::Loaders::IssuableLoader.new(resource_parent, finder).batching_find_all do |q|
          apply_lookahead(q)
        end

        if non_stable_cursor_sort?(args[:sort])
          # Certain complex sorts are not supported by the stable cursor pagination yet.
          # In these cases, we use offset pagination, so we return the correct connection.
          offset_pagination(issues)
        else
          issues
        end
      end

      private

      def resource_parent
        # The project could have been loaded in batch by `BatchLoader`.
        # At this point we need the `id` of the project to query for issues, so
        # make sure it's loaded and not `nil` before continuing.
        strong_memoize(:resource_parent) do
          object.respond_to?(:sync) ? object.sync : object
        end
      end
    end
  end
end

Resolvers::Issues::BaseParentResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/issues/base_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Issues
    # rubocop:disable Graphql/ResolverType
    class BaseResolver < Resolvers::BaseResolver
      include SearchArguments

      argument :assignee_id, GraphQL::Types::String,
        required: false,
        description: 'ID of a user assigned to the issues. Wildcard values "NONE" and "ANY" are supported.'
      argument :assignee_username, GraphQL::Types::String,
        required: false,
        description: 'Username of a user assigned to the issue.',
        deprecated: { reason: 'Use `assigneeUsernames`', milestone: '13.11' }
      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Usernames of users assigned to the issue.'
      argument :assignee_wildcard_id, ::Types::AssigneeWildcardIdEnum,
        required: false,
        description: 'Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames.'
      argument :author_username, GraphQL::Types::String,
        required: false,
        description: 'Username of the author of the issue.'
      argument :closed_after, Types::TimeType,
        required: false,
        description: 'Issues closed after the date.'
      argument :closed_before, Types::TimeType,
        required: false,
        description: 'Issues closed before the date.'
      argument :confidential,
        GraphQL::Types::Boolean,
        required: false,
        description: 'Filter for confidential issues. If "false", excludes confidential issues. ' \
          'If "true", returns only confidential issues.'
      argument :created_after, Types::TimeType,
        required: false,
        description: 'Issues created after the date.'
      argument :created_before, Types::TimeType,
        required: false,
        description: 'Issues created before the date.'
      argument :crm_contact_id, GraphQL::Types::String,
        required: false,
        description: 'ID of a contact assigned to the issues.'
      argument :crm_organization_id, GraphQL::Types::String,
        required: false,
        description: 'ID of an organization assigned to the issues.'
      argument :due_after, Types::TimeType,
        required: false,
        description: 'Return issues due on or after the given time.'
      argument :due_before, Types::TimeType,
        required: false,
        description: 'Return issues due on or before the given time.'
      argument :iid, GraphQL::Types::String,
        required: false,
        description: 'IID of the issue. For example, "1".'
      argument :iids, [GraphQL::Types::String],
        required: false,
        description: 'List of IIDs of issues. For example, `["1", "2"]`.'
      argument :label_name, [GraphQL::Types::String, { null: true }],
        required: false,
        description: 'Labels applied to the issue.'
      argument :milestone_title, [GraphQL::Types::String, { null: true }],
        required: false,
        description: 'Milestone applied to the issue.'
      argument :milestone_wildcard_id, ::Types::MilestoneWildcardIdEnum,
        required: false,
        description: 'Filter issues by milestone ID wildcard.'
      argument :my_reaction_emoji, GraphQL::Types::String,
        required: false,
        description: 'Filter by reaction emoji applied by the current user. ' \
          'Wildcard values "NONE" and "ANY" are supported.'
      argument :not, Types::Issues::NegatedIssueFilterInputType,
        description: 'Negated arguments.',
        required: false
      argument :or, Types::Issues::UnionedIssueFilterInputType,
        description: 'List of arguments with inclusive OR.',
        required: false
      argument :subscribed, Types::Issuables::SubscriptionStatusEnum,
        description: 'Issues the current user is subscribed to.',
        required: false
      argument :types, [Types::IssueTypeEnum],
        as: :issue_types,
        description: 'Filter issues by the given issue types.',
        required: false
      argument :updated_after, Types::TimeType,
        required: false,
        description: 'Issues updated after the date.'
      argument :updated_before, Types::TimeType,
        required: false,
        description: 'Issues updated before the date.'

      validates mutually_exclusive: [:assignee_usernames, :assignee_username, :assignee_wildcard_id]
      validates mutually_exclusive: [:milestone_title, :milestone_wildcard_id]
      validates mutually_exclusive: [:release_tag, :release_tag_wildcard_id]

      class << self
        def resolver_complexity(args, child_complexity:)
          complexity = super
          complexity += 2 if args[:labelName]

          complexity
        end

        def accept_release_tag
          argument :release_tag, [GraphQL::Types::String],
            required: false,
            description: "Release tag associated with the issue's milestone."
          argument :release_tag_wildcard_id, Types::ReleaseTagWildcardIdEnum,
            required: false,
            description: 'Filter issues by release tag ID wildcard.'
        end
      end

      def ready?(**args)
        args[:not] = args[:not].to_h if args[:not]
        args[:or] = args[:or].to_h if args[:or]

        super
      end

      private

      def prepare_finder_params(args)
        params = super(args)
        params[:not] = params[:not].to_h if params[:not]
        params[:or] = params[:or].to_h if params[:or]
        params[:iids] ||= [params.delete(:iid)].compact if params[:iid]

        rewrite_param_name(params[:or], :author_usernames, :author_username)
        rewrite_param_name(params[:or], :label_names, :label_name)
        prepare_assignee_username_params(params)
        prepare_release_tag_params(params)

        params
      end

      def prepare_release_tag_params(args)
        release_tag_wildcard = args.delete(:release_tag_wildcard_id)
        return if release_tag_wildcard.blank?

        args[:release_tag] ||= release_tag_wildcard
      end

      def prepare_assignee_username_params(args)
        rewrite_param_name(args, :assignee_usernames, :assignee_username)
        rewrite_param_name(args[:or], :assignee_usernames, :assignee_username)
        rewrite_param_name(args[:not], :assignee_usernames, :assignee_username)
        rewrite_param_name(args, :assignee_wildcard_id, :assignee_id)
      end

      def rewrite_param_name(params, old_name, new_name)
        params[new_name] = params.delete(old_name) if params && params[old_name].present?
      end
    end
    # rubocop:enable Graphql/ResolverType
  end
end

Resolvers::Issues::BaseResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/issues_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class IssuesResolver < Issues::BaseResolver
    extend ::Gitlab::Utils::Override
    prepend ::Issues::LookAheadPreloads
    include ::Issues::SortArguments

    NON_FILTER_ARGUMENTS = %i[sort lookahead include_archived].freeze

    argument :include_archived, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Whether to include issues from archived projects. Defaults to `false`.'
    argument :state, Types::IssuableStateEnum,
      required: false,
      description: 'Current state of the issue.',
      prepare: ->(state, _ctx) {
        return state unless state == 'locked'

        raise Gitlab::Graphql::Errors::ArgumentError, Types::IssuableStateEnum::INVALID_LOCKED_MESSAGE
      }

    type Types::IssueType.connection_type, null: true

    before_connection_authorization do |nodes, current_user|
      ::Preloaders::IssuablesPreloader.new(nodes, current_user, project_associations).preload_all
    end

    def self.project_associations
      [:namespace]
    end

    def ready?(**args)
      unless filter_provided?(args)
        raise Gitlab::Graphql::Errors::ArgumentError, _('You must provide at least one filter argument for this query')
      end

      super
    end

    def resolve_with_lookahead(**args)
      issues = apply_lookahead(
        IssuesFinder.new(current_user, prepare_finder_params(args)).execute
      )

      if non_stable_cursor_sort?(args[:sort])
        # Certain complex sorts are not supported by the stable cursor pagination yet.
        # In these cases, we use offset pagination, so we return the correct connection.
        offset_pagination(issues)
      else
        issues
      end
    end

    private

    override :prepare_finder_params
    def prepare_finder_params(args)
      super.tap do |prepared|
        prepared[:non_archived] = !prepared.delete(:include_archived)
      end
    end

    def filter_provided?(args)
      args.except(*NON_FILTER_ARGUMENTS).values.any?(&:present?)
    end
  end
end

Resolvers::IssuesResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/issue_status_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class IssueStatusCountsResolver < Issues::BaseResolver
    type Types::IssueStatusCountsType, null: true

    accept_release_tag

    def resolve(**args)
      return Issue.none if resource_parent.nil?

      finder = IssuesFinder.new(current_user, prepare_finder_params(args))
      finder.parent_param = resource_parent

      Gitlab::IssuablesCountForState.new(finder, resource_parent)
    end

    private

    def resource_parent
      # The project could have been loaded in batch by `BatchLoader`.
      # At this point we need the `id` of the project to query for issues, so
      # make sure it's loaded and not `nil` before continuing.
      strong_memoize(:resource_parent) do
        object.respond_to?(:sync) ? object.sync : object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/kas/agent_configurations_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Kas
    class AgentConfigurationsResolver < BaseResolver
      type Types::Kas::AgentConfigurationType.connection_type, null: true

      # Calls Gitaly via KAS
      calls_gitaly!

      alias_method :project, :object

      def resolve
        return [] unless can_read_agent_configuration?

        kas_client.list_agent_config_files(project: project)
      rescue GRPC::BadStatus, Gitlab::Kas::Client::ConfigurationError => e
        raise_resource_not_available_error! e.class.name
      end

      private

      def can_read_agent_configuration?
        current_user.can?(:read_cluster_agent, project)
      end

      def kas_client
        @kas_client ||= Gitlab::Kas::Client.new
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/kas/agent_connections_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Kas
    class AgentConnectionsResolver < BaseResolver
      type Types::Kas::AgentConnectionType, null: true

      alias_method :agent, :object

      delegate :project, to: :agent

      def resolve
        return [] unless can_read_connected_agents?

        BatchLoader::GraphQL.for(agent.id).batch(default_value: []) do |agent_ids, loader|
          agents = get_connected_agents(agent_ids).group_by(&:agent_id)

          agents.each do |agent_id, connections|
            loader.call(agent_id, connections)
          end
        end
      end

      private

      def can_read_connected_agents?
        current_user.can?(:admin_cluster, project)
      end

      def get_connected_agents(agent_ids)
        kas_client.get_connected_agentks_by_agent_ids(agent_ids: agent_ids)
      rescue GRPC::BadStatus, Gitlab::Kas::Client::ConfigurationError => e
        raise_resource_not_available_error! e.class.name
      end

      def kas_client
        @kas_client ||= Gitlab::Kas::Client.new
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/labels_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class LabelsResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    authorize :read_label

    type Types::LabelType.connection_type, null: true

    argument :title, GraphQL::Types::String,
      required: false,
      description: 'Exact match on title. Cannot be used with `searchTerm`. ' \
        '`searchIn` will be ignored if `title` argument is provided.'

    argument :search_term, GraphQL::Types::String,
      required: false,
      description: 'Search term to find labels with.'

    argument :search_in, [Types::Issuables::Labels::SearchFieldListEnum],
      default_value: [:title, :description],
      description: 'Specify which fields to search in. Ignored if using `title`.'

    argument :include_ancestor_groups, GraphQL::Types::Boolean,
      required: false,
      description: 'Include labels from ancestor groups.',
      default_value: false

    argument :archived, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Filters archived labels. Defaults to false.'

    before_connection_authorization do |nodes, current_user|
      Preloaders::LabelsPreloader.new(nodes, current_user).preload_all
    end

    validates mutually_exclusive: [:search_term, :title]

    def resolve(**args)
      return Label.none if parent.nil?

      authorize!(parent)

      # LabelsFinder uses `search` param, so we transform `search_term` into `search`
      args[:search] = args.delete(:search_term)

      # If `title` is used, remove `search_in`
      args.delete(:search_in) if args[:title]

      # Optimization:
      # Rely on the LabelsPreloader rather than the default parent record preloading in the
      # finder because LabelsPreloader preloads more associations which are required for the
      # permission check.
      LabelsFinder.new(current_user, parent_param.merge(args)).execute
    end

    private

    def parent
      object.respond_to?(:sync) ? object.sync : object
    end

    def parent_param
      key = case parent
            when Group then :group
            when Project then :project
            else raise "Unexpected parent type: #{parent.class}"
            end

      { "#{key}": parent }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/last_commit_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class LastCommitResolver < BaseResolver
    type Types::Repositories::CommitType, null: true

    calls_gitaly!

    argument :path, GraphQL::Types::String,
      required: false,
      description: 'Path to get the last commit for. Default value is the root of the repository.'

    argument :ref, GraphQL::Types::String,
      required: false,
      description: 'Commit ref to get the last commit for. Default value is HEAD.'

    argument :ref_type, Types::RefTypeEnum,
      required: false,
      description: 'Type of ref.'

    # "container" will either be a Repository or a Tree, depending on which version of the
    # path_last_commit.query.graphql query triggered this resolver.
    alias_method :container, :object

    def resolve(**args)
      repo = container.is_a?(Tree) ? container.repository : container

      ref = args[:ref]
      ref = container.sha if container.respond_to?(:sha)

      path = args[:path]
      path = container.path if container.respond_to?(:path)

      ref_type = args[:ref_type]
      ref_type = container.ref_type if container.respond_to?(:ref_type)

      # Set the default here instead of in the argument definition. This allows us
      # to extract the path correctly from "args" or "container".
      path = '' if path.nil?

      # Ensure merge commits can be returned by sending nil to Gitaly instead of '/'
      path = path == '/' ? nil : path
      commit = Gitlab::Git::Commit.last_for_path(repo,
        ExtractsRef::RefExtractor.qualify_ref(ref, ref_type), path, literal_pathspec: true)

      ::Commit.new(commit, repo.project) if commit
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/members_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class MembersResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource
    include LooksAhead

    type Types::MemberInterface.connection_type, null: true

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query.'

    argument :sort, ::Types::MemberSortEnum,
      required: false,
      description: 'sort query.'

    def resolve_with_lookahead(**args)
      authorize!(object)

      relations = args.delete(:relations)

      apply_lookahead(finder_class.new(object, current_user, params: args).execute(include_relations: relations))
    end

    private

    def preloads
      {
        user: [:user, :source]
      }
    end

    def finder_class
      # override in subclass
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_request_pipelines_resolver.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/ResolverType

module Resolvers
  class MergeRequestPipelinesResolver < BaseResolver
    # The GraphQL type here gets defined in this include
    include ::ResolvesPipelines
    include ::CachingArrayResolver

    alias_method :merge_request, :object

    # Return at most 500 pipelines for each MR.
    # Merge requests generally have many fewer pipelines than this.
    max_page_size 500

    def resolve(**args)
      return unless project

      super
    end

    def query_for(input)
      mr, args = input
      resolve_pipelines(mr.source_project, args).merge(mr.all_pipelines)
    end

    def model_class
      ::Ci::Pipeline
    end

    def query_input(**args)
      [merge_request, args]
    end

    def project
      merge_request.source_project
    end
  end
end
# rubocop: enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_request_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class MergeRequestResolver < BaseResolver.single
    include ResolvesMergeRequests

    alias_method :project, :object

    type ::Types::MergeRequestType, null: true

    argument :iid, GraphQL::Types::String,
      required: true,
      as: :iids,
      description: 'IID of the merge request, for example `1`.'

    def no_results_possible?(args)
      project.nil?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_requests/assignee_or_reviewer_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module MergeRequests
    class AssigneeOrReviewerMergeRequestsResolver < UserMergeRequestsResolverBase
      type ::Types::MergeRequestType.connection_type, null: true

      argument :assigned_review_states, [::Types::MergeRequestReviewStateEnum],
        required: false,
        description: 'Reviewer states for merge requests the current user is assigned to.'

      argument :reviewer_review_states, [::Types::MergeRequestReviewStateEnum],
        required: false,
        description: 'Reviewer states for the merge requests the current user is a reviewer of.'

      def resolve(**args)
        return unless current_user.merge_request_dashboard_enabled?

        super(**args)
      end

      def user_role
        :assigned_user
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_requests_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class MergeRequestsCountResolver < BaseResolver
    type GraphQL::Types::Int, null: true

    def resolve
      BatchLoader::GraphQL.for(object.id).batch do |ids, loader, args|
        counts = MergeRequestsClosingIssues.count_for_collection(ids, context[:current_user]).to_h

        ids.each do |id|
          loader.call(id, counts[id] || 0)
        end
      end
    end

    # We call this resolver from `IssueType` where object is an `Issue` instance, and we also call this resolver
    # from `Widgets::DevelopmentType`, in which case the object is a connection type, so
    # we need to get its respective work item.
    def object
      case super
      when ::GraphQL::Pagination::Connection
        super.try(:parent)&.work_item
      else
        super
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_requests/issue_related_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module MergeRequests
    class IssueRelatedResolver < BaseResolver
      prepend ::MergeRequests::LookAheadPreloads

      type Types::MergeRequestType.connection_type, null: true

      def resolve_with_lookahead
        scoped_merge_requests = MergeRequest.id_in(
          ::Issues::ReferencedMergeRequestsService.new(container: resource.resource_parent, current_user: current_user)
            .referenced_merge_requests(resource)
            .map(&:id)
        )

        apply_lookahead(scoped_merge_requests)
      end

      private

      def resource
        object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class MergeRequestsResolver < BaseResolver
    include ResolvesMergeRequests
    include SearchArguments
    extend ::Gitlab::Graphql::NegatableArguments

    type ::Types::MergeRequestType.connection_type, null: true

    alias_method :project, :object

    def self.accept_assignee
      argument :assignee_username, GraphQL::Types::String,
        required: false,
        description: 'Username of the assignee.'
      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Usernames of users assigned to the merge request.'
      argument :assignee_wildcard_id, ::Types::AssigneeWildcardIdEnum,
        required: false,
        description: 'Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername.'
    end

    def self.accept_author
      argument :author_username, GraphQL::Types::String,
        required: false,
        description: 'Username of the author.'
    end

    def self.accept_reviewer
      argument :reviewer_username, GraphQL::Types::String,
        required: false,
        description: 'Username of the reviewer.'
      argument :reviewer_wildcard_id, ::Types::ReviewerWildcardIdEnum,
        required: false,
        description: 'Filter by reviewer presence. Incompatible with reviewerUsername.'
    end

    argument :approved_by, [GraphQL::Types::String],
      required: false,
      as: :approved_by_usernames,
      description: 'Usernames of the approvers.'

    argument :release_tag, GraphQL::Types::String,
      required: false,
      description: 'Filter by release tag.'

    argument :iids, [GraphQL::Types::String],
      required: false,
      description: 'Array of IIDs of merge requests, for example `[1, 2]`.'
    argument :merged_by, GraphQL::Types::String,
      required: false,
      as: :merge_user_username,
      description: 'Username of the merger.'
    argument :my_reaction_emoji, GraphQL::Types::String,
      required: false,
      description: 'Filter by your reaction emoji.'
    argument :or, Types::MergeRequests::UnionedMergeRequestFilterInputType,
      description: 'List of arguments with inclusive OR.',
      required: false

    argument :source_branches, [GraphQL::Types::String],
      required: false,
      as: :source_branch,
      description: <<~DESC
               Array of source branch names.
               All resolved merge requests will have one of these branches as their source.
      DESC

    argument :target_branches, [GraphQL::Types::String],
      required: false,
      as: :target_branch,
      description: <<~DESC
               Array of target branch names.
               All resolved merge requests will have one of these branches as their target.
      DESC

    argument :state, ::Types::MergeRequestStateEnum,
      required: false,
      description: 'Merge request state. If provided, all resolved merge requests will have the state.'

    argument :draft, GraphQL::Types::Boolean,
      required: false,
      description: 'Limit result to draft merge requests.'

    argument :blob_path, GraphQL::Types::String,
      required: false,
      experiment: { milestone: '17.7' },
      description: <<~DESC
               Path of the blob changed in merge request.
               Requires state, targetBranches, and createdAfter arguments.
      DESC

    argument :created_after, Types::TimeType,
      required: false,
      description: 'Merge requests created after the timestamp.'
    argument :created_before, Types::TimeType,
      required: false,
      description: 'Merge requests created before the timestamp.'
    argument :deployed_after, Types::TimeType,
      required: false,
      description: 'Merge requests deployed after the timestamp.'
    argument :deployed_before, Types::TimeType,
      required: false,
      description: 'Merge requests deployed before the timestamp.'
    argument :deployment_id, GraphQL::Types::String,
      required: false,
      description: 'ID of the deployment.'
    argument :environment_name, GraphQL::Types::String,
      as: :environment,
      required: false,
      description: 'Environment merge requests have been deployed to.'
    argument :updated_after, Types::TimeType,
      required: false,
      description: 'Merge requests updated after the timestamp.'
    argument :updated_before, Types::TimeType,
      required: false,
      description: 'Merge requests updated before the timestamp.'

    argument :ignored_reviewer_username, GraphQL::Types::String,
      required: false,
      description: 'Username of the reviewer to ignore when searching by reviewer state.',
      experiment: { milestone: '18.0' }
    argument :label_name, [GraphQL::Types::String, { null: true }],
      required: false,
      description: 'Labels applied to the merge request.'
    argument :labels, [GraphQL::Types::String],
      required: false,
      as: :label_name,
      description: 'Array of label names. All resolved merge requests will have all of these labels.',
      deprecated: { reason: 'Use `labelName`', milestone: '17.1' }
    argument :merged_after, Types::TimeType,
      required: false,
      description: 'Merge requests merged after the date.'
    argument :merged_before, Types::TimeType,
      required: false,
      description: 'Merge requests merged before the date.'
    argument :milestone_title, GraphQL::Types::String,
      required: false,
      description: 'Title of the milestone. Incompatible with milestoneWildcardId.'
    argument :milestone_wildcard_id, ::Types::MilestoneWildcardIdEnum,
      required: false,
      description: 'Filter issues by milestone ID wildcard. Incompatible with milestoneTitle.'
    argument :review_state, ::Types::MergeRequestReviewStateEnum,
      required: false,
      description: 'Reviewer state of the merge request.',
      experiment: { milestone: '17.0' }
    argument :review_states, [::Types::MergeRequestReviewStateEnum],
      required: false,
      description: 'Reviewer states of the merge request.',
      experiment: { milestone: '17.0' }
    argument :sort, Types::MergeRequestSortEnum,
      description: 'Sort merge requests by the criteria.',
      required: false,
      default_value: :created_desc
    argument :subscribed, Types::Issuables::SubscriptionStatusEnum,
      description: 'Merge requests the current user is subscribed to.',
      required: false

    negated do
      argument :approved_by, [GraphQL::Types::String],
        required: false,
        as: :approved_by_usernames,
        description: 'Filters merge requests to exclude any that are approved by usernames in the given array.'
      argument :assignee_usernames, [GraphQL::Types::String],
        as: :assignee_username,
        required: false,
        description: 'Filters merge requests to exclude any that are assigned to the usernames in the given array.'
      argument :author_username, GraphQL::Types::String,
        required: false,
        description: 'Filters merge requests to exclude any that are authored by the given user.'
      argument :label_name, [GraphQL::Types::String],
        required: false,
        description: 'Filters merge requests to exclude any that have the labels provided in the given array.'
      argument :labels, [GraphQL::Types::String],
        as: :label_name,
        required: false,
        description: 'Filters merge requests to exclude any that have the labels provided in the given array.',
        deprecated: { reason: 'Use `labelName`', milestone: '17.7' }
      argument :milestone_title, GraphQL::Types::String,
        required: false,
        description: 'Filters merge requests to those not in the given milestone.'
      argument :my_reaction_emoji, GraphQL::Types::String,
        required: false,
        description: 'Filters merge requests to those without the given reaction from the authenticated user.'
      argument :only_reviewer, GraphQL::Types::Boolean,
        required: false,
        description: 'Filters out merge requests to those that do not have the reviewer as the only assigned reviewer.',
        experiment: { milestone: '17.11' }
      argument :release_tag, GraphQL::Types::String,
        required: false,
        description: 'Filters merge requests to those without the given release tag.'
      argument :review_states, [::Types::MergeRequestReviewStateEnum],
        required: false,
        description: 'Filters merge requests to those where a reviewer does not have the provided state.',
        experiment: { milestone: '17.9' }
      argument :reviewer_username, GraphQL::Types::String,
        required: false,
        description: 'Filters merge requests to those not reviewed by the given user.'
      argument :source_branches, [GraphQL::Types::String],
        required: false,
        as: :source_branch,
        description: 'Filters merge requests to exclude the source branch names provided in the given array.'
      argument :target_branches, [GraphQL::Types::String],
        required: false,
        as: :target_branch,
        description: 'Filters merge requests to exclude the target branch names provided in the given array.'
    end

    validates mutually_exclusive: [:assignee_usernames, :assignee_username, :assignee_wildcard_id]
    validates mutually_exclusive: [:reviewer_username, :reviewer_wildcard_id]
    validates mutually_exclusive: [:milestone_title, :milestone_wildcard_id]

    def self.single
      ::Resolvers::MergeRequestResolver
    end

    def no_results_possible?(args)
      project.nil? || some_argument_is_empty?(args)
    end

    def some_argument_is_empty?(args)
      args.values.any? { |v| v.is_a?(Array) && v.empty? }
    end

    private

    def prepare_finder_params(args)
      params = super
      params[:not] = params[:not].to_h if params[:not]
      params[:or] = params[:or].to_h if params[:or]

      prepare_assignee_username_params(params)

      params
    end

    def prepare_assignee_username_params(args)
      rewrite_param_name(args, :assignee_usernames, :assignee_username)
      rewrite_param_name(args[:or], :assignee_usernames, :assignee_username)
      rewrite_param_name(args[:not], :assignee_usernames, :assignee_username)
    end

    def rewrite_param_name(params, old_name, new_name)
      params[new_name] = params.delete(old_name) if params && params[old_name].present?
    end
  end
end

Resolvers::MergeRequestsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/merge_requests/work_item_related_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module MergeRequests
    class WorkItemRelatedResolver < IssueRelatedResolver # rubocop:disable Graphql/ResolverType -- Parent class defines the type
      extend ::Gitlab::Utils::Override

      override :resolve_with_lookahead
      def resolve_with_lookahead
        return ::MergeRequest.none if resource.group_level?

        super
      end

      private

      override :resource
      def resource
        object.work_item
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/milestones_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class MilestonesResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource
    include TimeFrameArguments
    include LooksAhead

    # authorize before resolution
    authorize :read_milestone
    authorizes_object!

    argument :ids, [GraphQL::Types::ID],
      required: false,
      description: 'Array of global milestone IDs, e.g., `"gid://gitlab/Milestone/1"`.'

    argument :state, Types::MilestoneStateEnum,
      required: false,
      description: 'Filter milestones by state.'

    argument :title, GraphQL::Types::String,
      required: false,
      description: 'Title of the milestone.'

    argument :search_title, GraphQL::Types::String,
      required: false,
      description: 'Search string for the title.'

    argument :containing_date, Types::TimeType,
      required: false,
      description: 'Date the milestone contains.'

    argument :sort, Types::MilestoneSortEnum,
      description: 'Sort milestones by the criteria.',
      required: false,
      default_value: :due_date_asc

    type Types::MilestoneType.connection_type, null: true

    NON_STABLE_CURSOR_SORTS = %i[expired_last_due_date_asc expired_last_due_date_desc].freeze

    def resolve_with_lookahead(**args)
      milestones = apply_lookahead(MilestonesFinder.new(milestones_finder_params(args)).execute)

      if non_stable_cursor_sort?(args[:sort])
        offset_pagination(milestones)
      else
        milestones
      end
    end

    private

    def preloads
      {
        releases: :releases
      }
    end

    def milestones_finder_params(args)
      {
        ids: parse_gids(args[:ids]),
        state: args[:state] || 'all',
        title: args[:title],
        search_title: args[:search_title],
        sort: args[:sort],
        containing_date: args[:containing_date]
      }.merge!(transform_timeframe_parameters(args)).merge!(parent_id_parameters(args))
    end

    def parent
      object
    end

    def parent_id_parameters(args)
      raise NotImplementedError
    end

    def parse_gids(gids)
      gids&.map { |gid| GitlabSchema.parse_gid(gid, expected_type: Milestone).model_id }
    end

    def non_stable_cursor_sort?(sort)
      NON_STABLE_CURSOR_SORTS.include?(sort)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ml/experiment_detail_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ml
    class ExperimentDetailResolver < Resolvers::BaseResolver
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      type ::Types::Ml::ExperimentType, null: true

      argument :id, ::Types::GlobalIDType[::Ml::Experiment],
        required: true,
        description: 'ID of the experiment.'

      def resolve(id:)
        Gitlab::Graphql::Lazy.with_value(find_object(id: id)) do |experiment|
          experiment if Ability.allowed?(current_user, :read_model_experiments, experiment&.project)
        end
      end

      private

      def find_object(id:)
        GitlabSchema.find_by_gid(id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ml/find_experiments_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ml
    class FindExperimentsResolver < Resolvers::BaseResolver
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      type Types::Ml::ExperimentType.connection_type, null: true

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Search for names that include the string.'

      argument :order_by, ::Types::Ml::ModelsOrderByEnum,
        required: false,
        description: 'Ordering column. Default is created_at.'

      argument :sort, ::Types::SortDirectionEnum,
        required: false,
        description: 'Ordering direction. Default is desc.'

      def resolve(**args)
        return unless Ability.allowed?(current_user, :read_model_experiments, object)

        find_params = {
          name: args[:name],
          order_by: args[:order_by].to_s,
          sort: args[:sort].to_s,
          with_candidate_count: true
        }

        ::Projects::Ml::ExperimentFinder.new(object, find_params).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ml/find_models_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ml
    class FindModelsResolver < Resolvers::BaseResolver
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      type ::Types::Ml::ModelType.connection_type, null: true

      argument :name, GraphQL::Types::String,
        required: false,
        description: 'Search for names that include the string.'

      argument :order_by, ::Types::Ml::ModelsOrderByEnum,
        required: false,
        description: 'Ordering column. Default is created_at.'

      argument :sort, ::Types::SortDirectionEnum,
        required: false,
        description: 'Ordering column. Default is desc.'

      def resolve(**args)
        return unless Ability.allowed?(current_user, :read_model_registry, object)

        find_params = {
          name: args[:name],
          order_by: args[:order_by].to_s,
          sort: args[:sort].to_s
        }

        ::Projects::Ml::ModelFinder.new(object, find_params).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ml/find_model_version_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ml
    class FindModelVersionResolver < Resolvers::BaseResolver
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      type ::Types::Ml::ModelType, null: true

      argument :model_version_id, ::Types::GlobalIDType[::Ml::ModelVersion],
        required: false,
        description: 'Id of the version to be fetched.'

      def resolve(model_version_id:)
        Gitlab::Graphql::Lazy.with_value(find_object(id: model_version_id)) do |model_version|
          model_version if Ability.allowed?(current_user, :read_model_registry, model_version&.project) &&
            model_version.model_id == object.id
        end
      end

      def find_object(id:)
        GitlabSchema.find_by_gid(id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ml/find_model_versions_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ml
    class FindModelVersionsResolver < Resolvers::BaseResolver
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      type ::Types::Ml::ModelType.connection_type, null: true

      argument :version, GraphQL::Types::String,
        required: false,
        description: 'Search for versions where the name includes the string.'

      argument :order_by, ::Types::Ml::ModelVersionsOrderByEnum,
        required: false,
        description: 'Ordering column. Default is created_at.'

      argument :sort, ::Types::SortDirectionEnum,
        required: false,
        description: 'Ordering column. Default is desc.'

      def resolve(**args)
        return unless Ability.allowed?(current_user, :read_model_registry, object.project)

        find_params = {
          version: args[:version],
          order_by: args[:order_by].to_s,
          sort: args[:sort].to_s
        }

        ::Projects::Ml::ModelVersionFinder.new(object, find_params).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/ml/model_detail_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Ml
    class ModelDetailResolver < Resolvers::BaseResolver
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

      type ::Types::Ml::ModelType, null: true

      argument :id, ::Types::GlobalIDType[::Ml::Model],
        required: true,
        description: 'ID of the model.'

      def resolve(id:)
        Gitlab::Graphql::Lazy.with_value(find_object(id: id)) do |ml_model|
          ml_model if Ability.allowed?(current_user, :read_model_registry, ml_model&.project)
        end
      end

      private

      def find_object(id:)
        GitlabSchema.find_by_gid(id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/namespace_projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class NamespaceProjectsResolver < BaseResolver
    argument :include_subgroups, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Include also subgroup projects.'

    argument :include_sibling_projects, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Include also projects from parent group.',
      experiment: { milestone: '17.2' }

    argument :include_archived, GraphQL::Types::Boolean,
      required: false,
      default_value: true,
      description: 'Include also archived projects.'

    argument :not_aimed_for_deletion, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Include projects that are not aimed for deletion.'

    argument :search, GraphQL::Types::String,
      required: false,
      default_value: nil,
      description: 'Search project with most similar names or paths.'

    argument :sort, Types::Projects::NamespaceProjectSortEnum,
      required: false,
      default_value: nil,
      description: 'Sort projects by the criteria.'

    argument :ids, [GraphQL::Types::ID],
      required: false,
      default_value: nil,
      description: 'Filter projects by IDs.'

    argument :with_issues_enabled, GraphQL::Types::Boolean,
      required: false,
      description: "Return only projects with issues enabled."

    argument :with_merge_requests_enabled, GraphQL::Types::Boolean,
      required: false,
      description: "Return only projects with merge requests enabled."

    argument :with_namespace_domain_pages, GraphQL::Types::Boolean,
      required: false,
      description: "Return only projects that use the namespace domain for pages projects."

    argument :archived_only, GraphQL::Types::Boolean,
      required: false,
      description: "Return only archived projects."

    type Types::ProjectType, null: true

    def resolve(args)
      # The namespace could have been loaded in batch by `BatchLoader`.
      # At this point we need the `id` or the `full_path` of the namespace
      # to query for projects, so make sure it's loaded and not `nil` before continuing.

      ::Namespaces::ProjectsFinder.new(
        namespace: namespace,
        current_user: current_user,
        params: finder_params(args)
      ).execute
    end

    def self.resolver_complexity(args, child_complexity:)
      complexity = super
      complexity + 10
    end

    private

    def namespace
      strong_memoize(:namespace) do
        object.respond_to?(:sync) ? object.sync : object
      end
    end

    def finder_params(args)
      {
        include_subgroups: args[:include_subgroups],
        include_sibling_projects: args[:include_sibling_projects],
        include_archived: args[:include_archived],
        not_aimed_for_deletion: args[:not_aimed_for_deletion],
        sort: args[:sort],
        search: args[:search],
        ids: parse_gids(args[:ids]),
        with_issues_enabled: args[:with_issues_enabled],
        with_merge_requests_enabled: args[:with_merge_requests_enabled],
        with_namespace_domain_pages: args[:with_namespace_domain_pages],
        archived_only: args[:archived_only]
      }
    end

    def parse_gids(gids)
      gids&.map { |gid| GitlabSchema.parse_gid(gid, expected_type: ::Project).model_id }
    end
  end
end

Resolvers::NamespaceProjectsResolver.prepend_mod_with('Resolvers::NamespaceProjectsResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/namespace_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class NamespaceResolver < BaseResolver
    def self.target_type
      'namespace'
    end

    include FullPathResolver

    type Types::NamespaceType, null: true

    def resolve(full_path:)
      model_by_full_path(Namespace, full_path)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/namespaces/work_item_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Namespaces
    class WorkItemResolver < Resolvers::BaseResolver
      type ::Types::WorkItemType, null: true

      argument :iid, GraphQL::Types::String, required: true, description: 'IID of the work item.'

      def self.recent_services_map
        @recent_services_map ||= {
          'issue' => ::Gitlab::Search::RecentIssues
        }
      end

      def ready?(**args)
        return false if resource_parent.is_a?(Group) && !resource_parent.licensed_feature_available?(:epics)

        super
      end

      def resolve(iid:)
        work_item = ::WorkItem.find_by_namespace_id_and_iid(resource_parent.id, iid)

        log_recent_view(work_item) if work_item && current_user

        work_item
      end

      private

      def log_recent_view(work_item)
        base_type = work_item.work_item_type.base_type

        return unless self.class.recent_services_map.key?(base_type)

        service_class = self.class.recent_services_map[base_type]
        return unless defined?(service_class)

        service_class.new(user: current_user).log_view(work_item)
      end

      def resource_parent
        # The namespace could have been loaded in batch by `BatchLoader`.
        # At this point we need the `id` of the namespace to query for work items, so
        # make sure it's loaded and not `nil` before continuing.
        object.respond_to?(:sync) ? object.sync : object
      end
      strong_memoize_attr :resource_parent
    end
  end
end

Resolvers::Namespaces::WorkItemResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/namespaces/work_items_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Namespaces
    # rubocop:disable Graphql/ResolverType -- inherited from Resolvers::WorkItemsResolver
    class WorkItemsResolver < ::Resolvers::WorkItemsResolver
      include TimeFrameHelpers

      GROUP_NAMESPACE_ONLY_ARGS = %i[include_ancestors include_descendants exclude_projects timeframe].freeze

      argument :include_ancestors, GraphQL::Types::Boolean,
        required: false,
        default_value: false,
        description: 'Include work items from ancestor groups. Ignored for project namespaces.'

      argument :include_descendants, GraphQL::Types::Boolean,
        required: false,
        default_value: false,
        description: 'Include work items from descendant groups and projects. Ignored for project namespaces.'

      argument :exclude_projects, GraphQL::Types::Boolean,
        required: false,
        default_value: false,
        description: 'Exclude work items from projects within the group. Ignored for project namespaces.',
        experiment: { milestone: '17.5' }

      argument :timeframe, Types::TimeframeInputType,
        required: false,
        description: 'List items overlapping the given timeframe. Ignored for project namespaces.'

      def ready?(**args)
        return false if object.is_a?(::Namespaces::UserNamespace)

        validate_timeframe_limit!(args[:timeframe]) if group_namespace?

        super
      end

      private

      override :finder
      def finder(args)
        filtered_args = if group_namespace?
                          args.merge(group_id: resource_parent, **transform_timeframe_parameters(args))
                        else
                          # For project namespaces, exclude the group level args
                          args.except(*GROUP_NAMESPACE_ONLY_ARGS)
                        end

        ::WorkItems::WorkItemsFinder.new(current_user, filtered_args)
      end

      def group_namespace?
        object.is_a?(::Group)
      end
      strong_memoize_attr :group_namespace?
    end
    # rubocop:enable Graphql/ResolverType
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/namespaces/work_item_state_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Namespaces
    class WorkItemStateCountsResolver < WorkItemsResolver
      type Types::WorkItemStateCountsType, null: true

      def resolve(**args)
        return if resource_parent.nil?

        work_items_finder = finder(prepare_finder_params(args))
        work_items_finder.parent_param = resource_parent unless group_namespace?

        Gitlab::IssuablesCountForState.new(
          work_items_finder,
          resource_parent,
          # fast_fail and store_in_redis_cache only for group namespaces, to match behaviour of project level
          # WorkItemStateCountsResolver
          fast_fail: group_namespace?,
          store_in_redis_cache: group_namespace?
        )
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/nested_groups_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class NestedGroupsResolver < BaseResolver
    include ResolvesGroups

    type Types::GroupType, null: true

    argument :include_parent_descendants, GraphQL::Types::Boolean,
      required: false,
      description: 'List of descendant groups of the parent group.',
      default_value: true

    argument :owned, GraphQL::Types::Boolean,
      required: false,
      description: 'Limit result to groups owned by authenticated user.'

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query for group name or group full path.'

    argument :ids, [GraphQL::Types::ID],
      required: false,
      description: 'Filter groups by IDs.',
      prepare: ->(global_ids, _ctx) {
        GitlabSchema.parse_gids(global_ids, expected_type: ::Group).map(&:model_id)
      }

    argument :sort, Types::Namespaces::GroupSortEnum,
      required: false,
      description: 'Sort groups by given criteria.',
      default_value: :name_asc

    alias_method :parent, :object

    private

    def resolve_groups(args)
      return Group.none unless parent.present?

      GroupsFinder
        .new(context[:current_user], args.merge(parent: parent))
        .execute
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/noteable/notes_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Noteable
    class NotesResolver < BaseResolver
      include LooksAhead

      type Types::Notes::NoteType.connection_type, null: false

      argument :filter, Types::WorkItems::NotesFilterTypeEnum,
        required: false,
        default_value: ::UserPreference::NOTES_FILTERS[:all_notes],
        description: 'Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY.'

      before_connection_authorization do |nodes, current_user|
        next if nodes.blank?

        # For all noteables where we use this resolver, we can assume that all notes will belong to the same project
        project = nodes.first.project

        ::Preloaders::Projects::NotesPreloader.new(project, current_user).call(nodes)
      end

      def resolve_with_lookahead(**args)
        notes = NotesFinder.new(current_user, build_params(args)).execute
        apply_lookahead(notes)
      end

      private

      def unconditional_includes
        [:author, :project, :note_metadata]
      end

      def preloads
        {
          award_emoji: [:award_emoji]
        }
      end

      def build_params(args)
        params = {
          project: object.project,
          target: object
        }

        params[:notes_filter] = args[:filter] if args[:filter].present?

        params
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/notes/synthetic_note_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Notes
    class SyntheticNoteResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :read_note

      type Types::Notes::NoteType, null: true

      argument :sha, GraphQL::Types::String,
        required: true,
        description: 'Global ID of the note.'

      argument :noteable_id, ::Types::GlobalIDType[::Noteable],
        required: true,
        description: 'Global ID of the resource to search synthetic note on.'

      def resolve(noteable_id:, sha:)
        noteable = authorized_find!(id: noteable_id)

        synthetic_notes = ResourceEvents::MergeIntoNotesService.new(
          noteable, current_user, paginated_notes: nil
        ).execute

        synthetic_notes.find { |note| note.discussion_id == sha }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/organizations/groups_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Organizations
    class GroupsResolver < Resolvers::GroupsResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::GroupType.connection_type, null: true

      authorize :read_group

      private

      alias_method :organization, :object

      def resolve_groups(**args)
        ::Organizations::GroupsFinder.new(current_user, finder_params(args)).execute
      end

      def finder_params(args)
        args.merge(organization: organization)
      end
    end
  end
end

Resolvers::Organizations::GroupsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/organizations/organization_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Organizations
    class OrganizationResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :read_organization

      type Types::Organizations::OrganizationType, null: true

      argument :id,
        Types::GlobalIDType[::Organizations::Organization],
        required: true,
        description: 'ID of the organization.'

      def resolve(id:)
        authorized_find!(id: id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/organizations/organizations_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Organizations
    class OrganizationsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Organizations::OrganizationType.connection_type, null: true
      authorize :read_organization

      def resolve
        # For the Organization MVC, all the organizations are public. We need to change this to only accessible
        # organizations once we start supporting private organizations.
        # See https://gitlab.com/groups/gitlab-org/-/epics/10649.
        ::Organizations::Organization.all
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/organizations/organization_users_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Organizations
    class OrganizationUsersResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource
      include LooksAhead

      type Types::Organizations::OrganizationUserType.connection_type, null: true

      authorize :read_organization_user

      alias_method :organization, :object

      def resolve_with_lookahead
        authorize!(object)

        apply_lookahead(organization_users)
      end

      private

      def organization_users
        ::Organizations::OrganizationUsersFinder
          .new(organization: organization, current_user: context[:current_user])
          .execute
      end

      def preloads
        {
          user: [:user],
          badges: [{ user: [:identities] }]
        }
      end
    end
  end
end

Resolvers::Organizations::OrganizationUsersResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/organizations/projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Organizations
    class ProjectsResolver < Resolvers::ProjectsResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::ProjectType.connection_type, null: true

      authorize :read_project

      private

      alias_method :organization, :object

      def finder_params(args)
        super.merge(organization: organization)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/package_details_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class PackageDetailsResolver < BaseResolver
    extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

    type ::Types::Packages::PackageDetailsType, null: true

    argument :id, ::Types::GlobalIDType[::Packages::Package],
      required: true,
      description: 'Global ID of the package.'

    def resolve(id:)
      Gitlab::Graphql::Lazy.with_value(find_object(id: id)) do |package|
        package if package&.detailed_info?
      end
    end

    private

    def find_object(id:)
      GitlabSchema.find_by_gid(id)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/package_pipelines_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class PackagePipelinesResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::Ci::PipelineType.connection_type, null: true
    extras [:lookahead]

    authorizes_object!
    authorize :read_pipeline

    alias_method :package, :object

    # this resolver can be called for 100 packages max and we want to limit the
    # number of build infos returned for _each_ package when using the new finder.
    MAX_PAGE_SIZE = 20

    # This returns a promise for a connection of promises for pipelines:
    # Lazy[Connection[Lazy[Pipeline]]] structure
    def resolve(lookahead:, first: nil, last: nil, after: nil, before: nil)
      default_value = default_value_for(first: first, last: last, after: after, before: before)
      BatchLoader::GraphQL.for(package.id)
                          .batch(default_value: default_value) do |package_ids, loader|
        build_infos = ::Packages::BuildInfosFinder.new(
          package_ids,
          first: first,
          last: last,
          after: decode_cursor(after),
          before: decode_cursor(before),
          max_page_size: MAX_PAGE_SIZE,
          support_next_page: lookahead.selects?(:page_info)
        ).execute

        build_infos.each do |build_info|
          loader.call(build_info.package_id) do |connection|
            connection.items << lazy_load_pipeline(build_info.pipeline_id)
            connection
          end
        end
      end
    end

    private

    def lazy_load_pipeline(id)
      ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::Ci::Pipeline, id)
        .find
    end

    def default_value_for(first:, last:, after:, before:)
      Gitlab::Graphql::Pagination::ActiveRecordArrayConnection.new(
        [],
        context: context,
        first: first,
        last: last,
        after: after,
        before: before,
        max_page_size: MAX_PAGE_SIZE
      )
    end

    def decode_cursor(encoded)
      return unless encoded

      decoded = Gitlab::Json.parse(context.schema.cursor_encoder.decode(encoded, nonce: true))
      id_from_cursor(decoded)
    rescue JSON::ParserError
      raise Gitlab::Graphql::Errors::ArgumentError, "Please provide a valid cursor"
    end

    def id_from_cursor(cursor)
      cursor&.fetch('id')
    rescue KeyError
      raise Gitlab::Graphql::Errors::ArgumentError, "Please provide a valid cursor"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/packages_base_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class PackagesBaseResolver < BaseResolver
    type Types::Packages::PackageType.connection_type, null: true

    argument :sort, Types::Packages::PackageSortEnum,
      description: 'Sort packages by the criteria.',
      required: false,
      default_value: :created_desc

    argument :package_name, GraphQL::Types::String,
      description: 'Search a package by name.',
      required: false,
      default_value: nil

    argument :package_type, Types::Packages::PackageTypeEnum,
      description: 'Filter a package by type.',
      required: false,
      default_value: nil

    argument :package_version, GraphQL::Types::String,
      description: 'Filter a package by version. If used in combination with `include_versionless`,
          then no versionless packages are returned.',
      required: false,
      default_value: nil

    argument :status, Types::Packages::PackageStatusEnum,
      description: 'Filter a package by status.',
      required: false,
      default_value: nil

    argument :include_versionless, GraphQL::Types::Boolean,
      description: 'Include versionless packages.',
      required: false,
      default_value: false

    SORT_TO_PARAMS_MAP = {
      created_desc: { order_by: 'created', sort: 'desc' },
      created_asc: { order_by: 'created', sort: 'asc' },
      name_desc: { order_by: 'name', sort: 'desc' },
      name_asc: { order_by: 'name', sort: 'asc' },
      version_desc: { order_by: 'version', sort: 'desc' },
      version_asc: { order_by: 'version', sort: 'asc' },
      type_desc: { order_by: 'type', sort: 'desc' },
      type_asc: { order_by: 'type', sort: 'asc' }
    }.freeze

    def resolve(**_args)
      raise NotImplementedError
    end

    private

    def packages_available?
      ::Gitlab.config.packages.enabled
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/pages_deployments_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class PagesDeploymentsResolver < BaseResolver
    type Types::PagesDeploymentType.connection_type, null: true

    argument :active, GraphQL::Types::Boolean, required: false, description: "Filter by active or inactive state."
    argument :sort, Types::SortEnum, required: false, description: "Sort results."
    argument :versioned, GraphQL::Types::Boolean, required: false, description: "Filter deployments that are
versioned or unversioned."

    def resolve(**args)
      Pages::DeploymentsFinder.new(object, args).execute
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/paginated_tree_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class PaginatedTreeResolver < BaseResolver
    type Types::Tree::TreeType.connection_type, null: true

    calls_gitaly!

    argument :path, GraphQL::Types::String,
      required: false,
      default_value: '', # root of the repository
      description: 'Path to get the tree for. Default value is the root of the repository.'
    argument :recursive, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Used to get a recursive tree. Default is false.'
    argument :ref, GraphQL::Types::String,
      required: false,
      description: 'Commit ref to get the tree for. Default value is HEAD.'
    argument :ref_type, Types::RefTypeEnum,
      required: false,
      description: 'Type of ref.'

    alias_method :repository, :object

    def resolve(**args)
      return if repository.empty?

      cursor = args.delete(:after)

      pagination_params = {
        limit: @field.max_page_size || 100,
        page_token: cursor
      }

      tree = repository.tree(
        args[:ref].presence || :head,
        args[:path], recursive: args[:recursive],
        skip_flat_paths: false,
        pagination_params: pagination_params,
        ref_type: args[:ref_type]
      )

      next_cursor = tree.cursor&.next_cursor
      Gitlab::Graphql::ExternallyPaginatedArray.new(cursor, next_cursor, *tree)
    rescue Gitlab::Git::CommandError => e
      raise Gitlab::Graphql::Errors::BaseError.new(
        e,
        extensions: { code: e.code, gitaly_code: e.status, service: e.service }
      )
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_container_registry_protection_rules_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectContainerRegistryProtectionRulesResolver < BaseResolver
    type Types::ContainerRegistry::Protection::RuleType.connection_type, null: true

    alias_method :project, :object

    def resolve(**_args)
      project.container_registry_protection_rules
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_issues_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from Issues::BaseParentResolver
module Resolvers
  class ProjectIssuesResolver < Issues::BaseParentResolver
    accept_release_tag
  end
end
# rubocop:enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_jobs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectJobsResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource
    include LooksAhead

    type ::Types::Ci::JobType.connection_type, null: true
    authorize :read_build
    authorizes_object!
    extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1

    argument :statuses, [::Types::Ci::JobStatusEnum],
      required: false,
      description: 'Filter jobs by status.'

    argument :with_artifacts, ::GraphQL::Types::Boolean,
      required: false,
      description: 'Filter by artifacts presence.'

    argument :name, GraphQL::Types::String,
      required: false,
      experiment: { milestone: '17.11' },
      description: 'Filter jobs by name.'

    argument :sources, [::Types::Ci::JobSourceEnum],
      required: false,
      experiment: { milestone: '17.7' },
      description: "Filter jobs by source."

    argument :kind, ::Types::Ci::JobKindEnum,
      required: false,
      description: 'Filter jobs by kind.'

    alias_method :project, :object

    def resolve_with_lookahead(**args)
      @kind = args[:kind]
      @with_artifacts = args[:with_artifacts]

      filter_by_name = Feature.enabled?(:populate_and_use_build_names_table, project) && args[:name].to_s.present?
      filter_by_sources = args[:sources].present?

      jobs = ::Ci::JobsFinder.new(
        current_user: current_user, project: project, params: {
          scope: args[:statuses], with_artifacts: args[:with_artifacts],
          skip_ordering: filter_by_sources
        }, type: args[:kind] || ::Ci::Build
      ).execute

      # These job filters are currently exclusive with each other
      if filter_by_name
        jobs = ::Ci::BuildNameFinder.new(
          relation: jobs,
          name: args[:name],
          project: project
        ).execute
      elsif filter_by_sources
        jobs = ::Ci::BuildSourceFinder.new(
          relation: jobs,
          sources: args[:sources],
          project: project
        ).execute

        return offset_pagination(apply_lookahead(jobs))
      end

      apply_lookahead(jobs)
    end

    private

    def should_preload_artifacts?
      @with_artifacts || @kind == ::Ci::Build
    end

    def preloads
      base_preloads = {
        previous_stage_jobs_or_needs: [:needs, :pipeline],
        pipeline: [:user],
        build_source: [:source]
      }

      base_preloads[:artifacts] = [:job_artifacts] if should_preload_artifacts?

      base_preloads
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_members_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from MembersResolver

module Resolvers
  class ProjectMembersResolver < MembersResolver
    authorize :read_project_member

    argument :relations, [Types::ProjectMemberRelationEnum],
      description: 'Filter members by the given member relations.',
      required: false,
      default_value: MembersFinder::DEFAULT_RELATIONS

    argument :access_levels, [Types::AccessLevelEnum],
      description: 'Filter members by the given access levels.',
      required: false

    private

    def finder_class
      MembersFinder
    end
  end
end
# rubocop:enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectMergeRequestsResolver < MergeRequestsResolver
    type ::Types::MergeRequestType.connection_type, null: true
    accept_assignee
    accept_author
    accept_reviewer

    def resolve(**args)
      scope = super

      if only_count_is_selected_with_merged_at_filter?(args)
        MergeRequest::MetricsFinder
          .new(current_user, args.merge(target_project: project))
          .execute
      else
        scope
      end
    end

    def only_count_is_selected_with_merged_at_filter?(args)
      return unless lookahead

      # Filter out all elements with blank values.  If any of the values are not
      # scalars, e.g. hashes or array, filter blank values from them and remove
      # them if the resulting collection is empty.
      argument_names = args.except(:lookahead, :sort, :merged_before, :merged_after).filter_map do |key, value|
        value = value.to_hash.compact if value.respond_to?(:to_hash)
        key if value.present?
      end

      # no extra filtering arguments are provided
      return unless argument_names.empty?
      return unless args[:merged_after] || args[:merged_before]

      # Detecting a specific query pattern:
      # mergeRequests(mergedAfter: "X", mergedBefore: "Y") {
      #   count
      #   totalTimeToMerge
      # }
      allowed_selected_fields = [:count, :total_time_to_merge]
      selected_fields = lookahead.selections.map(&:field).map(&:original_name) - [:__typename] # ignore __typename meta field

      # only the allowed_selected_fields are present
      (selected_fields - allowed_selected_fields).empty?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_milestones_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectMilestonesResolver < MilestonesResolver
    include ::API::Concerns::Milestones::GroupProjectParams

    argument :include_ancestors, GraphQL::Types::Boolean,
      required: false,
      description: "Also return milestones in the project's parent group and its ancestors."

    type Types::MilestoneType.connection_type, null: true

    private

    def parent_id_parameters(args)
      project_finder_params(parent, args)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_packages_protection_rules_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectPackagesProtectionRulesResolver < BaseResolver
    type Types::Packages::Protection::RuleType.connection_type, null: true

    alias_method :project, :object

    def resolve(**_args)
      project.package_protection_rules
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_packages_resolver.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/ResolverType

module Resolvers
  class ProjectPackagesResolver < PackagesBaseResolver
    # The GraphQL type is defined in the extended class

    def resolve(sort:, **filters)
      return unless packages_available?

      params = filters.merge(SORT_TO_PARAMS_MAP.fetch(sort))
      params[:preload_pipelines] = false

      ::Packages::PackagesFinder.new(object, params).execute
    end
  end
end
# rubocop: enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/project_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectResolver < BaseResolver
    def self.target_type
      'project'
    end

    include FullPathResolver

    type Types::ProjectType, null: true

    def resolve(full_path:)
      model_by_full_path(Project, full_path)
    end

    def self.complexity_multiplier(args)
      0
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/branch_rules_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class BranchRulesResolver < BaseResolver
      include LooksAhead
      include ::Gitlab::Utils::StrongMemoize

      type Types::Projects::BranchRuleType.connection_type, null: false

      alias_method :project, :object

      def resolve_with_lookahead(**args)
        [*custom_branch_rules(args), *branch_rules]
      end

      private

      # BranchRules for 'All branches' i.e. no associated ProtectedBranch
      def custom_branch_rules(args)
        [all_branches_rule]
      end

      def all_branches_rule
        ::Projects::AllBranchesRule.new(project)
      end
      strong_memoize_attr :all_branches_rule

      def branch_rules
        protected_branches.map do |protected_branch|
          ::Projects::BranchRule.new(project, protected_branch)
        end
      end

      def protected_branches
        apply_lookahead(project.all_protected_branches.sorted_by_name)
      end
    end
  end
end

Resolvers::Projects::BranchRulesResolver.prepend_mod_with('Resolvers::Projects::BranchRulesResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/commit_references_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class CommitReferencesResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      argument :commit_sha, GraphQL::Types::String,
        required: true,
        description: 'Project commit SHA identifier. For example, `287774414568010855642518513f085491644061`.'

      authorize :read_commit

      alias_method :project, :object

      calls_gitaly!

      type ::Types::CommitReferencesType, null: true

      def resolve(commit_sha:)
        authorized_find!(oid: commit_sha)
      end

      def find_object(oid:)
        project.repository.commit(oid)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/deploy_key_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class DeployKeyResolver < BaseResolver
      include LooksAhead

      type Types::AccessLevels::DeployKeyType, null: true

      def resolve_with_lookahead(**args)
        apply_lookahead(Autocomplete::DeployKeysWithWriteAccessFinder.new(current_user,
          object).execute(title_search_term: args[:title_query]))
      end

      def preloads
        {
          user: [:user]
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/fork_details_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class ForkDetailsResolver < BaseResolver
      type Types::Projects::ForkDetailsType, null: true

      argument :ref, GraphQL::Types::String,
        required: false,
        description: 'Ref of the fork. Default value is HEAD.'

      alias_method :project, :object

      def resolve(**args)
        return unless project.forked?
        return unless authorized_fork_source?

        ::Projects::Forks::Details.new(project, args[:ref])
      end

      private

      def authorized_fork_source?
        Ability.allowed?(current_user, :read_code, project.fork_source)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/fork_targets_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class ForkTargetsResolver < BaseResolver
      include LooksAhead
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::NamespaceType.connection_type, null: true

      authorize :fork_project
      authorizes_object!

      alias_method :project, :object

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search query for path or name.'

      def resolve_with_lookahead(**args)
        fork_targets = ForkTargetsFinder.new(project, current_user).execute(args)
        apply_lookahead(fork_targets)
      end

      private

      def preloads
        ResolvesGroups::PRELOADS
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/grafana_integration_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class GrafanaIntegrationResolver < BaseResolver
      type Types::GrafanaIntegrationType, null: true

      alias_method :project, :object

      def resolve(**args)
        return unless project.is_a? Project

        project.grafana_integration
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/is_forked_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class IsForkedResolver < BaseResolver
      type GraphQL::Types::Boolean, null: false

      def resolve
        lazy_fork_network_members = BatchLoader::GraphQL.for(object.id).batch do |ids, loader|
          ForkNetworkMember.by_projects(ids)
            .with_fork_network
            .find_each do |fork_network_member|
              loader.call(fork_network_member.project_id, fork_network_member)
            end
        end

        Gitlab::Graphql::Lazy.with_value(lazy_fork_network_members) do |fork_network_member|
          next false if fork_network_member.nil?

          fork_network_member.fork_network.root_project_id != object.id
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/jira_projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class JiraProjectsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Projects::Services::JiraProjectType.connection_type, null: true
      authorize :admin_project

      argument :name,
        GraphQL::Types::String,
        required: false,
        description: 'Project name or key.'

      def resolve(name: nil, **args)
        authorize!(project)

        response = jira_projects(name: name)

        if response.success?
          projects_array = response.payload[:projects]

          GraphQL::Pagination::ArrayConnection.new(
            projects_array,
            # override default max_page_size to whatever the size of the response is,
            # see https://gitlab.com/gitlab-org/gitlab/-/issues/231394
            **args.merge({ max_page_size: projects_array.size })
          )
        else
          raise Gitlab::Graphql::Errors::BaseError, response.message
        end
      end

      private

      alias_method :jira_integration, :object

      def project
        jira_integration&.project
      end

      def jira_projects(name:)
        args = { query: name }.compact

        Jira::Requests::Projects::ListService.new(project.jira_integration, args).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/plan_limits_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class PlanLimitsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::ProjectPlanLimitsType, null: false

      authorize :read_project

      def resolve
        authorize!(object)

        schedule_allowed = Ability.allowed?(current_user, :read_ci_pipeline_schedules_plan_limit, object)

        {
          ci_pipeline_schedules: schedule_allowed ? object.actual_limits.ci_pipeline_schedules : nil
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ProjectsResolver < BaseResolver
    prepend ::Projects::LookAheadPreloads
    include ProjectSearchArguments

    type Types::ProjectType.connection_type, null: true

    argument :ids, [GraphQL::Types::ID],
      required: false,
      description: 'Filter projects by IDs.'

    argument :full_paths, [GraphQL::Types::String],
      required: false,
      description: 'Filter projects by full paths. You cannot provide more than 50 full paths.'

    argument :with_issues_enabled, GraphQL::Types::Boolean,
      required: false,
      description: "Return only projects with issues enabled."

    argument :with_merge_requests_enabled, GraphQL::Types::Boolean,
      required: false,
      description: "Return only projects with merge requests enabled."

    argument :archived, ::Types::Projects::ArchivedEnum,
      required: false,
      description: 'Filter projects by archived status.'

    argument :min_access_level, ::Types::AccessLevelEnum,
      required: false,
      description: 'Return only projects where current user has at least the specified access level.'

    argument :programming_language_name, GraphQL::Types::String,
      required: false,
      description: 'Filter projects by programming language name (case insensitive). For example: "css" or "ruby".'

    argument :trending, GraphQL::Types::Boolean,
      required: false,
      description: "Return only projects that are trending."

    argument :aimed_for_deletion, GraphQL::Types::Boolean,
      required: false,
      description: 'Return only projects marked for deletion.'

    argument :not_aimed_for_deletion, GraphQL::Types::Boolean,
      required: false,
      description: "Exclude projects that are marked for deletion."

    argument :marked_for_deletion_on, ::Types::DateType,
      required: false,
      description: 'Date when the project was marked for deletion.'

    argument :active, GraphQL::Types::Boolean,
      required: false,
      description: "Filters by projects that are not archived and not marked for deletion."

    argument :visibility_level, ::Types::VisibilityLevelsEnum,
      required: false,
      description: 'Filter projects by visibility level.'

    before_connection_authorization do |projects, current_user|
      ::Preloaders::UserMaxAccessLevelInProjectsPreloader.new(projects, current_user).execute
    end

    def resolve_with_lookahead(**args)
      validate_args!(args)

      projects = ProjectsFinder
        .new(current_user: current_user, params: finder_params(args), project_ids_relation: parse_gids(args[:ids]))
        .execute

      apply_lookahead(projects)
    end

    private

    def validate_args!(args)
      return unless args[:full_paths].present? && args[:full_paths].length > 50

      raise Gitlab::Graphql::Errors::ArgumentError, 'You cannot provide more than 50 full_paths'
    end

    def unconditional_includes
      [
        :creator,
        :group,
        :invited_groups,
        :project_setting,
        :project_namespace,
        {
          namespace: [:namespace_settings_with_ancestors_inherited_settings]
        }
      ]
    end

    def finder_params(args)
      {
        **project_finder_params(args),
        with_issues_enabled: args[:with_issues_enabled],
        with_merge_requests_enabled: args[:with_merge_requests_enabled],
        full_paths: args[:full_paths],
        archived: args[:archived],
        min_access_level: args[:min_access_level],
        language_name: args[:programming_language_name],
        trending: args[:trending],
        aimed_for_deletion: args[:aimed_for_deletion],
        not_aimed_for_deletion: args[:not_aimed_for_deletion],
        marked_for_deletion_on: args[:marked_for_deletion_on],
        visibility_level: args[:visibility_level],
        active: args[:active],
        organization: ::Current.organization
      }
    end

    def parse_gids(gids)
      gids&.map { |gid| GitlabSchema.parse_gid(gid, expected_type: ::Project).model_id }
    end
  end
end

Resolvers::ProjectsResolver.prepend_mod_with('Resolvers::ProjectsResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/services_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    # TODO: Remove in 17.0, see https://gitlab.com/gitlab-org/gitlab/-/merge_requests/108418
    class ServicesResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Projects::ServiceType.connection_type, null: true
      authorize :admin_project
      authorizes_object!

      argument :active,
        GraphQL::Types::Boolean,
        required: false,
        description: 'Indicates if the integration is active.'
      argument :type,
        Types::Projects::ServiceTypeEnum,
        required: false,
        description: 'Type of integration.'

      alias_method :project, :object

      def resolve(active: nil, type: nil)
        items = project.integrations
        items = items.by_active_flag(active) unless active.nil?
        items = items.by_type(type) unless type.blank?
        items
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/snippets_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from ResolvesSnippets

module Resolvers
  module Projects
    class SnippetsResolver < BaseResolver
      include ResolvesSnippets

      alias_method :project, :object

      def resolve(**args)
        return Snippet.none if project.nil?

        unless project.feature_available?(:snippets, current_user)
          raise_resource_not_available_error! 'Snippets are not enabled for this Project'
        end

        super
      end

      private

      def snippet_finder_params(args)
        super.merge(project: project)
      end
    end
  end
end
# rubocop:enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/projects/user_contributed_projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Projects
    class UserContributedProjectsResolver < BaseResolver
      prepend ::Projects::LookAheadPreloads

      type Types::ProjectType.connection_type, null: true

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search query.'

      argument :sort, Types::Projects::ProjectSortEnum,
        description: 'Sort contributed projects.',
        required: false,
        default_value: :latest_activity_desc

      argument :min_access_level, ::Types::AccessLevelEnum,
        required: false,
        description: 'Return only projects where current user has at least the specified access level.'

      argument :include_personal, GraphQL::Types::Boolean,
        description: 'Include personal projects.',
        required: false,
        default_value: false

      argument :programming_language_name, GraphQL::Types::String,
        required: false,
        description: 'Filter projects by programming language name (case insensitive). For example: "css" or "ruby".'

      before_connection_authorization do |projects, current_user|
        ::Preloaders::UserMaxAccessLevelInProjectsPreloader.new(projects, current_user).execute
      end

      alias_method :user, :object

      def resolve_with_lookahead(**args)
        contributed_projects = ContributedProjectsFinder.new(
          user: user,
          current_user: current_user,
          params: finder_params(args)
        ).execute

        return apply_lookahead(contributed_projects) if args[:include_personal]

        apply_lookahead(contributed_projects.joined(user))
      end

      private

      def finder_params(args)
        {
          organization: Current.organization,
          search: args[:search],
          sort: args[:sort],
          min_access_level: args[:min_access_level],
          programming_language_name: args[:programming_language_name]
        }
      end
    end
  end
end

Resolvers::Projects::UserContributedProjectsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/recent_boards_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class RecentBoardsResolver < BaseResolver
    type Types::BoardType, null: true

    def resolve
      parent = object.respond_to?(:sync) ? object.sync : object
      return Board.none unless parent

      recent_visits =
        ::Boards::VisitsFinder.new(parent, current_user).latest(Board::RECENT_BOARDS_SIZE)

      recent_visits&.map(&:board) || []
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/release_milestones_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ReleaseMilestonesResolver < BaseResolver
    type Types::MilestoneType.connection_type, null: true

    alias_method :release, :object

    def resolve(**args)
      offset_pagination(release.milestones.order_by_dates_and_title)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/release_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ReleaseResolver < BaseResolver
    type Types::ReleaseType, null: true

    argument :tag_name, GraphQL::Types::String,
      required: true,
      description: 'Name of the tag associated to the release.'

    alias_method :project, :object

    def self.single
      self
    end

    def resolve(tag_name:)
      ReleasesFinder.new(
        project,
        current_user,
        { tag: tag_name }
      ).execute.first
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/releases_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ReleasesResolver < BaseResolver
    type Types::ReleaseType.connection_type, null: true

    argument :sort, Types::ReleaseSortEnum,
      required: false, default_value: :released_at_desc,
      description: 'Sort releases by given criteria.'

    alias_method :project, :object

    # This resolver has a custom singular resolver
    def self.single
      Resolvers::ReleaseResolver
    end

    SORT_TO_PARAMS_MAP = {
      released_at_desc: { order_by: 'released_at', sort: 'desc' },
      released_at_asc: { order_by: 'released_at', sort: 'asc' },
      created_desc: { order_by: 'created_at', sort: 'desc' },
      created_asc: { order_by: 'created_at', sort: 'asc' }
    }.freeze

    def resolve(sort:)
      ReleasesFinder.new(
        project,
        current_user,
        SORT_TO_PARAMS_MAP[sort]
      ).execute
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/repositories/commit_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Repositories
    class CommitResolver < BaseResolver
      type Types::Repositories::CommitType, null: true

      argument :ref,
        GraphQL::Types::String,
        required: true,
        description: "Commit reference (SHA, branch name, or tag name)."

      calls_gitaly!

      alias_method :repository, :object

      def resolve(ref:)
        repository.commit(ref)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/repositories/ref_commit_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Repositories
    class RefCommitResolver < BaseResolver
      type Types::Repositories::CommitType, null: true

      def resolve(**_args)
        commit = object&.dereferenced_target
        return unless commit

        lazy_project = BatchLoader::GraphQL.for(commit.repository.gl_project_path).batch do |paths, loader|
          paths.each { |path| loader.call(path, Project.find_by_full_path(path)) }
        end

        ::Gitlab::Graphql::Lazy.with_value(lazy_project) do |project|
          ::Commit.new(commit, project) if project
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/repository_branch_names_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class RepositoryBranchNamesResolver < BaseResolver
    type ::GraphQL::Types::String, null: false

    calls_gitaly!

    argument :search_pattern, GraphQL::Types::String,
      required: true,
      description: 'Pattern to search for branch names by.'

    argument :offset, GraphQL::Types::Int,
      required: true,
      description: 'Number of branch names to skip.'

    argument :limit, GraphQL::Types::Int,
      required: true,
      description: 'Number of branch names to return.'

    def resolve(search_pattern:, offset:, limit:)
      ::Repositories::BranchNamesFinder.new(object, offset: offset, limit: limit, search: search_pattern).execute
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/review_requested_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class ReviewRequestedMergeRequestsResolver < UserMergeRequestsResolverBase
    type ::Types::MergeRequestType.connection_type, null: true
    accept_author
    accept_assignee

    def user_role
      :reviewer
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/saved_reply_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class SavedReplyResolver < BaseResolver
    type ::Types::Users::SavedReplyType, null: true

    alias_method :target, :object

    argument :id, Types::GlobalIDType[::Users::SavedReply],
      required: true,
      description: 'ID of a saved reply.'

    def resolve(id:)
      ::Users::SavedReply.find_saved_reply(user_id: current_user.id, id: id.model_id)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/snippets/blobs_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Snippets
    class BlobsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Snippets::BlobType.connection_type, null: true
      authorize :read_snippet
      calls_gitaly!
      authorizes_object!

      alias_method :snippet, :object

      argument :paths, [GraphQL::Types::String],
        required: false,
        description: 'Paths of the blobs.'

      def resolve(paths: [])
        return [snippet.blob] if snippet.empty_repo?

        paths = snippet.all_files if paths.empty?
        blobs = snippet.blobs(paths)

        # TODO: Some blobs, e.g. those with non-utf8 filenames, are returned as nil from the
        # repository. We need to provide a flag to notify the user of this until we come up with a
        # way to retrieve and display these blobs. We will be exploring a more holistic solution for
        # this general problem of making all blobs retrievable as part
        # of https://gitlab.com/gitlab-org/gitlab/-/issues/323082, at which point this attribute may
        # be removed.
        context[:unretrievable_blobs?] = blobs.size < paths.size

        blobs
      end
    end
  end
end

Resolvers::Snippets::BlobsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/snippets_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from ResolvesSnippets

module Resolvers
  class SnippetsResolver < BaseResolver
    include ResolvesIds
    include ResolvesSnippets

    ERROR_MESSAGE = 'Filtering by both an author and a project is not supported'

    alias_method :user, :object

    argument :author_id, ::Types::GlobalIDType[::User],
      required: false,
      description: 'ID of an author.'

    argument :project_id, ::Types::GlobalIDType[::Project],
      required: false,
      description: 'ID of a project.'

    argument :type, Types::Snippets::TypeEnum,
      required: false,
      description: 'Type of snippet.'

    argument :explore,
      GraphQL::Types::Boolean,
      required: false,
      description: 'Explore personal snippets.'

    def resolve(**args)
      if args[:author_id].present? && args[:project_id].present?
        raise Gitlab::Graphql::Errors::ArgumentError, ERROR_MESSAGE
      end

      super
    end

    private

    def snippet_finder_params(args)
      super
        .merge(author: resolve_ids(args[:author_id]),
          project: resolve_ids(args[:project_id]),
          explore: args[:explore])
    end
  end
end
# rubocop:enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/terraform/states_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Terraform
    class StatesResolver < BaseResolver
      type Types::Terraform::StateType.connection_type, null: true

      alias_method :project, :object

      when_single do
        argument :name, GraphQL::Types::String,
          required: true,
          description: 'Name of the Terraform state.'
      end

      def resolve(**args)
        ::Terraform::StatesFinder
          .new(project, current_user, params: args)
          .execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/timelog_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class TimelogResolver < BaseResolver
    include LooksAhead
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type ::Types::TimelogType.connection_type, null: false

    argument :start_date, Types::TimeType,
      required: false,
      description: 'List timelogs within a date range where the logged date is equal to or after startDate.'

    argument :end_date, Types::TimeType,
      required: false,
      description: 'List timelogs within a date range where the logged date is equal to or before endDate.'

    argument :start_time, Types::TimeType,
      required: false,
      description: 'List timelogs within a time range where the logged time is equal to or after startTime.'

    argument :end_time, Types::TimeType,
      required: false,
      description: 'List timelogs within a time range where the logged time is equal to or before endTime.'

    argument :project_id, ::Types::GlobalIDType[::Project],
      required: false,
      description: 'List timelogs for a project.'

    argument :group_id, ::Types::GlobalIDType[::Group],
      required: false,
      description: 'List timelogs for a group.'

    argument :username, GraphQL::Types::String,
      required: false,
      description: 'List timelogs for a user.'

    argument :sort, Types::TimeTracking::TimelogSortEnum,
      description: 'List timelogs in a particular order.',
      required: false,
      default_value: :spent_at_asc

    def resolve_with_lookahead(**args)
      validate_args!(object, args)

      args = parse_datetime_args(args)

      timelogs = Timelogs::TimelogsFinder.new(object, finder_params(args)).execute

      apply_lookahead(timelogs)
    rescue ArgumentError => e
      raise_argument_error(e.message)
    rescue ActiveRecord::RecordNotFound
      raise_resource_not_available_error!
    end

    private

    def finder_params(args)
      {
        username: args[:username],
        start_time: args[:start_time],
        end_time: args[:end_time],
        group_id: args[:group_id]&.model_id,
        project_id: args[:project_id]&.model_id,
        sort: args[:sort]
      }
    end

    def preloads
      {
        note: [:note]
      }
    end

    def validate_args!(object, args)
      unless has_parent?(object, args) || for_current_user?(args) || admin_user?
        raise_argument_error('Non-admin users must provide a groupId, projectId, or current username')
      end

      if args[:start_time] && args[:start_date]
        raise_argument_error('Provide either a start date or time, but not both')
      elsif args[:end_time] && args[:end_date]
        raise_argument_error('Provide either an end date or time, but not both')
      end
    end

    def has_parent?(object, args)
      object || args[:group_id] || args[:project_id]
    end

    def for_current_user?(args)
      args[:username].present? && args[:username] == current_user&.username
    end

    def admin_user?
      current_user&.can_read_all_resources?
    end

    def parse_datetime_args(args)
      if times_provided?(args)
        args
      else
        parsed_args = args.except(:start_date, :end_date)

        parsed_args[:start_time] = args[:start_date].beginning_of_day if args[:start_date]
        parsed_args[:end_time] = args[:end_date].end_of_day if args[:end_date]

        parsed_args
      end
    end

    def times_provided?(args)
      args[:start_time] && args[:end_time]
    end

    def raise_argument_error(message)
      raise Gitlab::Graphql::Errors::ArgumentError, message
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/todo_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class TodoResolver < BaseResolver
    description 'Retrieve a single to-do item'

    type Types::TodoType, null: true

    argument :id, Types::GlobalIDType[Todo],
      required: true,
      description: 'ID of the to-do item.'

    def resolve(id:)
      GitlabSchema.find_by_gid(id)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/todos_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class TodosResolver < BaseResolver
    type Types::TodoType.connection_type, null: true
    include Gitlab::InternalEventsTracking

    alias_method :target, :object

    argument :action, [Types::TodoActionEnum],
      required: false,
      description: 'Action to be filtered.'

    argument :author_id, [GraphQL::Types::ID],
      required: false,
      description: 'ID of an author.'

    argument :project_id, [GraphQL::Types::ID],
      required: false,
      description: 'ID of a project.'

    argument :group_id, [GraphQL::Types::ID],
      required: false,
      description: 'ID of a group.'

    argument :state, [Types::TodoStateEnum],
      required: false,
      description: 'State of the todo.'

    argument :is_snoozed, GraphQL::Types::Boolean,
      required: false,
      description: 'Whether the to-do item is snoozed.'

    argument :type, [Types::TodoTargetEnum],
      required: false,
      description: 'Type of the todo.'

    argument :sort, Types::TodoSortEnum,
      required: false,
      description: 'Sort todos by given criteria.'

    before_connection_authorization do |nodes, current_user|
      Preloaders::UserMaxAccessLevelInProjectsPreloader.new(
        nodes.map(&:project).compact,
        current_user
      ).execute
    end

    def resolve(**args)
      return Todo.none unless current_user.present? && target.present?
      return Todo.none if target.is_a?(User) && target != current_user

      track_bot_user if current_user.bot?

      TodosFinder.new(users: current_user, **todo_finder_params(args)).execute.with_entity_associations
    end

    private

    def todo_finder_params(args)
      {
        state: args[:state],
        is_snoozed: args[:is_snoozed],
        type: args[:type],
        group_id: args[:group_id],
        author_id: args[:author_id],
        action_id: args[:action],
        project_id: args[:project_id],
        sort: args[:sort]
      }.merge(target_params)
    end

    def target_params
      return {} unless TodosFinder::TODO_TYPES.include?(target.class.name)

      {
        type: target.class.name,
        target_id: target.id
      }
    end

    def track_bot_user
      track_internal_event(
        "request_todos_by_bot_user",
        user: current_user,
        additional_properties: {
          label: 'user_type',
          property: current_user.user_type
        }
      )
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/topics_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class TopicsResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::Projects::TopicType, null: true

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query for topic name.'

    argument :organization_id, Types::GlobalIDType[::Organizations::Organization],
      required: false,
      prepare: ->(global_id, _ctx) { global_id&.model_id },
      experiment: { milestone: '17.7' },
      description: 'Global ID of the organization.'

    def resolve(**args)
      organization = authorized_find!(id: args[:organization_id] || ::Current.organization.id)

      return organization_topics(organization.id) unless args[:search].present?

      organization_topics(organization.id).search(args[:search])
    end

    private

    def find_object(id:)
      ::Organizations::Organization.find_by_id(id)
    end

    def authorized_resource?(organization)
      Ability.allowed?(current_user, :read_organization, organization)
    end

    def organization_topics(organization_id)
      ::Projects::Topic.for_organization(organization_id).order_by_non_private_projects_count
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/tree_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class TreeResolver < BaseResolver
    type Types::Tree::TreeType, null: true

    calls_gitaly!

    argument :path, GraphQL::Types::String,
      required: false,
      default_value: '',
      description: 'Path to get the tree for. Default value is the root of the repository.'
    argument :recursive, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Used to get a recursive tree. Default is false.'
    argument :ref, GraphQL::Types::String,
      required: false,
      description: 'Commit ref to get the tree for. Default value is HEAD.'
    argument :ref_type, Types::RefTypeEnum,
      required: false,
      description: 'Type of ref.'

    alias_method :repository, :object

    def resolve(**args)
      return unless repository.exists?

      ref = (args[:ref].presence || :head)

      repository.tree(ref, args[:path], recursive: args[:recursive], ref_type: args[:ref_type])
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/up_votes_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class UpVotesCountResolver < Resolvers::AwardEmoji::BaseVotesCountResolver
    type GraphQL::Types::Int, null: true

    def resolve
      authorize!(object)
      votes_batch_loader.load_upvotes(object)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/user_discussions_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class UserDiscussionsCountResolver < BaseResolver
    # This resolver does not need to authorize object(Issue, MR, Epic, Work Item), because if object is not authorized
    # in the first place we'll not even get to query the count of discussions
    type GraphQL::Types::Int, null: true

    def resolve
      load_discussions_counts
    end

    private

    def load_discussions_counts
      BatchLoader::GraphQL.for(object.id).batch do |ids, loader, args|
        counts = Note.count_for_collection(
          ids, object.class.base_class.name, 'COUNT(DISTINCT discussion_id) as count'
        ).index_by(&:noteable_id)

        ids.each do |id|
          loader.call(id, counts[id]&.count || 0)
        end
      end
    end
  end
end

::Resolvers::UserDiscussionsCountResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/user_merge_requests_resolver_base.rb =====
# frozen_string_literal: true

module Resolvers
  class UserMergeRequestsResolverBase < MergeRequestsResolver
    include ResolvesProject

    argument :group_id,
      type: ::Types::GlobalIDType[::Group],
      required: false,
      description: <<~DESC
               The global ID of the group the authored merge requests should be in.
               Merge requests in subgroups are included.
      DESC

    argument :project_path,
      type: GraphQL::Types::String,
      required: false,
      description: <<~DESC
               The full-path of the project the authored merge requests should be in.
               Incompatible with projectId.
      DESC

    argument :project_id,
      type: ::Types::GlobalIDType[::Project],
      required: false,
      description: <<~DESC
               The global ID of the project the authored merge requests should be in.
               Incompatible with projectPath.
      DESC

    argument :include_archived, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: "Merge requests from archived projects."

    attr_reader :project
    alias_method :user, :object

    def ready?(project_id: nil, project_path: nil, **args)
      return early_return unless can_read_profile?

      if project_id || project_path
        load_project(project_path, project_id)
        return early_return unless can_read_project?
      elsif args[:iids].present?
        raise ::Gitlab::Graphql::Errors::ArgumentError, 'iids requires projectPath or projectId'
      end

      super(**args)
    end

    def resolve(**args)
      prepare_args(args)
      key = :"#{user_role}_id"
      super(key => user.id, **args)
    end

    def user_role
      raise NotImplementedError
    end

    private

    def can_read_profile?
      Ability.allowed?(current_user, :read_user_profile, user)
    end

    def can_read_project?
      Ability.allowed?(current_user, :read_merge_request, project)
    end

    def load_project(project_path, project_id)
      @project = ::Gitlab::Graphql::Lazy.force(resolve_project(full_path: project_path, project_id: project_id))
    end

    def no_results_possible?(args)
      some_argument_is_empty?(args)
    end

    # These arguments are handled in load_project, and should not be passed to
    # the finder directly.
    def prepare_args(args)
      args.delete(:project_id)
      args.delete(:project_path)
      args[:non_archived] = args.delete(:include_archived) != true
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/user_notes_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class UserNotesCountResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type GraphQL::Types::Int, null: true

    def resolve
      authorize!(object)

      load_notes_counts
    end

    def authorized_resource?(object)
      ability = :"read_#{object.class.name.underscore}"
      Ability.allowed?(context[:current_user], ability, object)
    end

    private

    def load_notes_counts
      BatchLoader::GraphQL.for(object.id).batch(key: :user_notes_count) do |ids, loader, args|
        counts = Note.count_for_collection(ids, object.class.name).index_by(&:noteable_id)

        ids.each do |id|
          loader.call(id, counts[id]&.count || 0)
        end
      end
    end
  end
end

::Resolvers::UserNotesCountResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/user_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class UserResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    description 'Retrieve a single user'

    type Types::UserType, null: true

    argument :id, Types::GlobalIDType[User],
      required: false,
      description: 'ID of the User.'

    argument :username, GraphQL::Types::String,
      required: false,
      description: 'Username of the User.'

    validates exactly_one_of: [:id, :username]

    def resolve(id: nil, username: nil)
      authorize!

      if id
        GitlabSchema.object_from_id(id, expected_type: User)
      else
        batch_load(username)
      end
    end

    private

    def batch_load(username)
      BatchLoader::GraphQL.for(username).batch do |usernames, loader|
        User.by_username(usernames).each do |user|
          loader.call(username, user)
        end
      end
    end

    def authorize!
      raise_resource_not_available_error! unless context[:current_user].present?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/frecent_groups_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class FrecentGroupsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type [Types::GroupType], null: true

      def resolve
        return unless current_user.present?

        ::Users::GroupVisit.frecent_groups(user_id: current_user.id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/frecent_projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class FrecentProjectsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type [Types::ProjectType], null: true

      def resolve
        return unless current_user.present?

        ::Users::ProjectVisit.frecent_projects(user_id: current_user.id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/group_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class GroupCountResolver < BaseResolver
      type GraphQL::Types::Int, null: true

      alias_method :user, :object

      def resolve(**args)
        return unless can_read_group_count?

        BatchLoader::GraphQL.for(user.id).batch do |user_ids, loader|
          results = UserGroupsCounter.new(user_ids).execute

          results.each do |user_id, count|
            loader.call(user_id, count)
          end
        end
      end

      def can_read_group_count?
        current_user&.can?(:read_user_membership_counts, user)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/groups_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class GroupsResolver < BaseResolver
      include ResolvesGroups
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::GroupType.connection_type, null: true

      authorize :read_user_groups
      authorizes_object!

      argument :permission_scope,
        ::Types::PermissionTypes::GroupEnum,
        required: false,
        description: 'Filter by permissions the user has on groups.'
      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search by group name or path.'
      argument :sort,
        Types::Namespaces::GroupSortEnum,
        required: false,
        description: 'Sort groups by given criteria.'

      before_connection_authorization do |nodes, current_user|
        Preloaders::GroupPolicyPreloader.new(nodes, current_user).execute
      end

      private

      def resolve_groups(**args)
        args = { **args, organization: context[:current_organization] }
        ::Groups::UserGroupsFinder.new(current_user, object, args).execute
      end
    end
  end
end

Resolvers::Users::GroupsResolver.prepend_mod_with('Resolvers::Users::GroupsResolver')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/organizations_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class OrganizationsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type Types::Organizations::OrganizationType.connection_type, null: true

      authorize :read_user_organizations
      authorizes_object!

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search query, which can be for the organization name or a path.'

      argument :solo_owned, GraphQL::Types::Boolean,
        required: false,
        description: 'When true, returns only organizations solely owned by the user.'

      def resolve(**args)
        ::Organizations::UserOrganizationsFinder.new(current_user, object, args).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/participants_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class ParticipantsResolver < BaseResolver
      type Types::UserType.connection_type, null: true

      def resolve(**args)
        object.visible_participants(current_user)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/project_count_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class ProjectCountResolver < BaseResolver
      type GraphQL::Types::Int, null: true

      alias_method :user, :object

      def resolve(**_args)
        return unless can_read_project_count?

        BatchLoader::GraphQL.for(user.id).batch do |user_ids, loader|
          counts = ProjectAuthorization.for_user(user_ids).count_by_user_id

          user_ids.each do |id|
            loader.call(id, counts.fetch(id, 0))
          end
        end
      end

      def can_read_project_count?
        current_user&.can?(:read_user_membership_counts, user)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/recently_viewed_issues_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class RecentlyViewedIssuesResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type [Types::IssueType], null: true

      authorize :read_user
      authorizes_object!

      def resolve
        recent_issues = ::Gitlab::Search::RecentIssues.new(user: current_user)
        recent_issues.search(nil) # nil skips filtering results by title or description
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/recently_viewed_items_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class RecentlyViewedItemsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type [Types::Users::RecentlyViewedItemType], null: true

      authorize :read_user

      RecentlyViewedItem = Struct.new(:item, :viewed_at)

      def resolve
        all_items = []

        available_types.each do |klass|
          recent_items_service = klass.new(user: current_user)

          recent_items_service.latest_with_timestamps.each do |item, timestamp|
            all_items << RecentlyViewedItem.new(item, timestamp)
          end
        end

        # Sort by viewed_at descending (most recent first)
        all_items.sort_by { |entry| -entry.viewed_at.to_f }
      end

      private

      def available_types
        [::Gitlab::Search::RecentIssues, ::Gitlab::Search::RecentMergeRequests]
      end
    end
  end
end

Resolvers::Users::RecentlyViewedItemsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/recently_viewed_merge_requests_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Users
    class RecentlyViewedMergeRequestsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type [Types::MergeRequestType], null: true

      authorize :read_user
      authorizes_object!

      def resolve
        recent_merge_requests = ::Gitlab::Search::RecentMergeRequests.new(user: current_user)
        recent_merge_requests.search(nil) # nil skips filtering results by title or description
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class UsersResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    type Types::UserType.connection_type, null: true
    description 'Find Users'

    argument :ids, [GraphQL::Types::ID],
      required: false,
      description: 'List of user Global IDs.'

    argument :usernames, [GraphQL::Types::String], required: false,
      description: 'List of usernames.'

    argument :sort, Types::SortEnum,
      description: 'Sort users by the criteria.',
      required: false,
      default_value: :created_desc

    argument :search, GraphQL::Types::String,
      required: false,
      description: "Query to search users by name, username, or primary email."

    argument :admins, GraphQL::Types::Boolean,
      required: false,
      default_value: false,
      description: 'Return only admin users.'

    argument :active, GraphQL::Types::Boolean,
      required: false,
      description: 'Filter by active users. When true, returns active users. When false, returns non-active users.'

    argument :humans, GraphQL::Types::Boolean,
      required: false,
      description: 'Filter by regular users. When true, returns only users that are not bot or internal users. ' \
        'When false, returns only users that are bot or internal users.'

    argument :group_id, ::Types::GlobalIDType[::Group],
      required: false,
      description: 'Return users member of a given group.'

    argument :user_types, [Types::Users::TypeEnum],
      required: false,
      description: 'Filter by user type.',
      experiment: { milestone: '18.3' }

    def resolve(**args)
      authorize!(args[:usernames])

      group_id = args[:group_id]
      group = group_id ? find_authorized_group!(group_id) : nil

      ::UsersFinder.new(
        context[:current_user],
        finder_params(group, args)
      ).execute
    end

    def ready?(**args)
      args = { ids: nil, usernames: nil }.merge!(args)

      return super if args.values.compact.blank?

      if args[:usernames].present? && args[:ids].present?
        raise Gitlab::Graphql::Errors::ArgumentError, 'Provide either a list of usernames or ids'
      end

      super
    end

    def authorize!(usernames)
      raise_resource_not_available_error! unless context[:current_user].present?
    end

    private

    def finder_params(group, args)
      params = {}
      params[:sort] = args[:sort] if args[:sort]
      params[:username] = args[:usernames] if args[:usernames]
      params[:id] = parse_gids(args[:ids]) if args[:ids]
      params[:search] = args[:search] if args[:search]
      params[:admins] = args[:admins] if args[:admins]
      params[:humans] = args[:humans] == true
      params[:without_humans] = args[:humans] == false
      params[:active] = args[:active] == true
      params[:without_active] = args[:active] == false
      params[:group] = group if group
      params[:user_types] = args[:user_types] unless args[:user_types].nil?
      params
    end

    def find_authorized_group!(group_id)
      group = GitlabSchema.find_by_gid(group_id).sync

      unless Ability.allowed?(current_user, :read_group, group)
        raise_resource_not_available_error! "Could not find a Group with ID #{group_id}"
      end

      group
    end

    def parse_gids(gids)
      gids.map { |gid| GitlabSchema.parse_gid(gid, expected_type: ::User).model_id }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/users/snippets_resolver.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/ResolverType -- inherited from ResolvesSnippets

module Resolvers
  module Users
    class SnippetsResolver < BaseResolver
      include ResolvesSnippets
      include Gitlab::Allowable

      alias_method :user, :object

      argument :type, Types::Snippets::TypeEnum,
        required: false,
        description: 'Type of snippet.'

      private

      def resolve_snippets(_args)
        return Snippet.none unless Ability.allowed?(current_user, :read_user_profile, user)

        super
      end

      def snippet_finder_params(args)
        super.merge(author: user)
      end
    end
  end
end
# rubocop:enable Graphql/ResolverType


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/user_starred_projects_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class UserStarredProjectsResolver < BaseResolver
    prepend ::Projects::LookAheadPreloads

    type Types::ProjectType.connection_type, null: true

    argument :search, GraphQL::Types::String,
      required: false,
      description: 'Search query.'

    argument :sort, Types::Projects::ProjectSortEnum,
      required: false,
      description: "List starred projects by sort order.",
      default_value: :name_asc

    argument :min_access_level, ::Types::AccessLevelEnum,
      required: false,
      description: 'Return only projects where current user has at least the specified access level.'

    argument :programming_language_name, GraphQL::Types::String,
      required: false,
      description: 'Filter projects by programming language name (case insensitive). For example: "css" or "ruby".'

    before_connection_authorization do |projects, current_user|
      ::Preloaders::UserMaxAccessLevelInProjectsPreloader.new(projects, current_user).execute
    end

    alias_method :user, :object

    def resolve_with_lookahead(**args)
      projects = StarredProjectsFinder.new(
        user,
        params: finder_params(args),
        current_user: current_user
      ).execute

      apply_lookahead(projects)
    end

    private

    def finder_params(args)
      {
        organization: Current.organization,
        search: args[:search],
        sort: args[:sort],
        min_access_level: args[:min_access_level],
        language_name: args[:programming_language_name]
      }
    end
  end
end

Resolvers::UserStarredProjectsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/wikis/wiki_page_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module Wikis
    class WikiPageResolver < BaseResolver
      description 'Retrieve a wiki page'

      calls_gitaly!

      type Types::Wikis::WikiPageType, null: true

      argument :slug, GraphQL::Types::String, required: false, description: 'Wiki page slug.'

      argument :project_id, ::Types::GlobalIDType[::Project],
        required: false,
        description: 'Wiki page project ID.'

      argument :namespace_id, ::Types::GlobalIDType[::Namespace],
        required: false,
        description: 'Wiki page namespace ID.'

      def resolve(slug: nil, namespace_id: nil, project_id: nil)
        if namespace_id.present? && project_id.present?
          raise Gitlab::Graphql::Errors::ArgumentError,
            'Only one of `namespace_id` or `project_id` are allowed.'
        end

        container = Namespace.find(extract_namespace_id(namespace_id)) if namespace_id.present?
        container = Project.find(extract_project_id(project_id)) if project_id.present?

        return unless slug.present? && container.present?

        wiki = Wiki.for_container(container, current_user)
        page = wiki.find_page(slug, load_content: false)

        page&.find_or_create_meta
      end

      private

      def extract_project_id(gid)
        GitlabSchema.parse_gid(gid, expected_type: ::Project).model_id
      end

      def extract_namespace_id(gid)
        GitlabSchema.parse_gid(gid, expected_type: ::Namespace).model_id
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_item_references_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class WorkItemReferencesResolver < BaseResolver
    prepend ::WorkItems::LookAheadPreloads
    include Gitlab::Graphql::Authorize::AuthorizeResource

    REFERENCES_LIMIT = 10

    authorize :read_work_item

    type ::Types::WorkItemType.connection_type, null: true

    argument :context_namespace_path, GraphQL::Types::ID,
      required: false,
      description: 'Full path of the context namespace (project or group).'

    argument :refs, [GraphQL::Types::String], required: true,
      description: 'Work item references. Can be either a short reference or URL.'

    def ready?(**args)
      if args[:refs].size > REFERENCES_LIMIT
        raise Gitlab::Graphql::Errors::ArgumentError,
          format(
            _('Number of references exceeds the limit. ' \
              'Please provide no more than %{refs_limit} references at the same time.'),
            refs_limit: REFERENCES_LIMIT
          )
      end

      super
    end

    def resolve_with_lookahead(context_namespace_path: nil, refs: [])
      return WorkItem.none if refs.empty?

      @container = authorized_find!(context_namespace_path)

      apply_lookahead(find_work_items(refs))
    end

    private

    attr_reader :container

    def find_work_items(references)
      epic_refs, issue_refs = references.partition { |r| r.match?(/epics|&/) }
      item_ids = references_extractor(issue_refs)&.references(:work_item, ids_only: true) || []

      # Also check for references with :issue and :epic patterns to find legacy items
      item_ids << references_extractor(issue_refs)&.references(:issue, ids_only: true)
      item_ids << references_extractor(epic_refs)&.references(:epic)&.pluck(:issue_id)

      WorkItem.id_in(item_ids.flatten.compact)
    end

    def references_extractor(refs)
      return unless refs.any?

      extractor, analyze_context =
        if container.is_a?(Group)
          [::Gitlab::ReferenceExtractor.new(nil, context[:current_user]), { group: container }]
        else
          [::Gitlab::ReferenceExtractor.new(container, context[:current_user]), {}]
        end

      extractor.analyze(refs.join(' '), analyze_context)

      extractor
    end

    def find_object(full_path)
      Routable.find_by_full_path(full_path)
    end

    def unconditional_includes
      [{ namespace: [:organization] }, *super]
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_item_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class WorkItemResolver < BaseResolver
    include Gitlab::Graphql::Authorize::AuthorizeResource

    authorize :read_work_item

    type Types::WorkItemType, null: true

    argument :id, ::Types::GlobalIDType[::WorkItem], required: true, description: 'Global ID of the work item.'

    def resolve(id:)
      authorized_find!(id: id)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/ancestors_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    # rubocop:disable Graphql/ResolverType -- the type is inherited from the parent class
    class AncestorsResolver < HierarchyResolver
      prepend ::WorkItems::LookAheadPreloads

      def resolve_with_lookahead
        ancestors = object.ancestors
        return WorkItem.none unless ancestors

        truncate_ancestors(apply_lookahead(ancestors)).reverse!
      end

      private

      def truncate_ancestors(ancestors)
        # Iterate from the closest ancestor until root or first missing ancestor
        authorized = authorized_work_items(ancestors)

        previous_ancestor = object.work_item
        authorized.take_while do |ancestor|
          is_direct_parent = previous_ancestor.work_item_parent.id == ancestor.id
          previous_ancestor = ancestor

          is_direct_parent
        end
      end

      def unconditional_includes
        [:namespace, :work_item_parent, :work_item_type]
      end
    end
    # rubocop:enable Graphql/ResolverType
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/children_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    # rubocop:disable Graphql/ResolverType -- the type is inherited from the parent class
    class ChildrenResolver < HierarchyResolver
      argument :state, ::Types::WorkItemStateEnum,
        required: false,
        description: 'Current state of the child work items. Returns all states when omitted.'

      def resolve(state: nil)
        children = object.children(state: state)
        return WorkItem.none unless children.any?

        children = children.inc_relations_for_permission_check unless children.loaded?
        authorized_work_items(children)
      end
    end
    # rubocop:enable Graphql/ResolverType
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/description_template_content_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class DescriptionTemplateContentResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type ::Types::WorkItems::DescriptionTemplateType, null: true

      argument :template_content_input, ::Types::WorkItems::DescriptionTemplateContentInputType,
        required: true,
        description: "Input for fetching a specific description template."

      authorize :read_project

      def resolve(args)
        project = Project.find(args[:template_content_input].project_id)

        authorize!(project)

        ::TemplateFinder.new(:issues, project,
          { name: args[:template_content_input].name, source_template_project_id: project.id }).execute

      rescue Gitlab::Template::Finders::RepoTemplateFinder::FileNotFoundError, ActiveRecord::RecordNotFound
        nil
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/description_templates_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class DescriptionTemplatesResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type ::Types::WorkItems::DescriptionTemplateType.connection_type, null: true

      argument :name, GraphQL::Types::String,
        required: false,
        description: "Fetches the specific DescriptionTemplate.",
        deprecated: { milestone: '17.9',
                      reason: 'name and project ID are both required for fetching,
                       use DescriptionTemplateContentInputType instead' }

      argument :search, GraphQL::Types::String,
        required: false,
        description: "Search for DescriptionTemplates by name.",
        deprecated: { milestone: '17.8', reason: 'search on template names is performed on the FE only' }

      alias_method :namespace, :object

      authorize :read_project

      def resolve(**_args)
        project = fetch_root_templates_project(namespace)
        return unless project

        authorize!(project)

        templates = Array.wrap(::TemplateFinder.new(:issues, project).execute)

        filter_project_templates_for_group(templates) if namespace.is_a?(Group)

        return if templates.blank?

        templates

      rescue Gitlab::Template::Finders::RepoTemplateFinder::FileNotFoundError, ActiveRecord::RecordNotFound
      end

      private

      # When we are at project level we return the project itself to fetch the description templates.
      # When we are at group level we fetch first found file_template_project_id from the namespace or its ancestors

      def fetch_root_templates_project(namespace)
        if namespace.is_a?(::Namespaces::ProjectNamespace)
          namespace.project
        elsif namespace.is_a?(::Group)
          Project.find(namespace.file_template_project_id)
        end
      end

      def filter_project_templates_for_group(templates)
        # Separate project templates from other templates
        project_templates, other_templates = templates.partition { |t| t.category == "Project Templates" }

        # Check if we have duplicate project and group templates from TemplateFinder where
        # project/group results match on name + content + project_id, meaning they refer to the same file
        # but the category returned refers to the parent group of the project

        has_equivalent_group_template = other_templates.any? do |other_template|
          project_templates.any? do |project_template|
            project_template.project_id == other_template.project_id &&
              project_template.name == other_template.name &&
              project_template.content == other_template.content &&
              other_template.category == "Group #{Project.find(project_template.project_id)&.parent&.name}"
          end
        end

        # If the duplicates in this case exist, we omit the project level duplicates
        templates.reject! { |t| t.category == "Project Templates" } if has_equivalent_group_template
      end
    end
  end
end

# rubocop:disable Layout/LineLength -- prepend statement is too long
Resolvers::WorkItems::DescriptionTemplatesResolver.prepend_mod_with('Resolvers::WorkItems::DescriptionTemplatesResolver')
# rubocop:enable Layout/LineLength


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/hierarchy_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class HierarchyResolver < BaseResolver
      type Types::WorkItemType.connection_type, null: true

      private

      def authorized_work_items(work_items)
        preload_resource_parents(work_items) unless work_items.loaded?

        DeclarativePolicy.user_scope do
          work_items.select { |work_item| Ability.allowed?(current_user, :read_work_item, work_item) }
        end
      end

      def preload_resource_parents(work_items)
        return unless current_user

        projects = work_items.filter_map(&:project)
        ::Preloaders::UserMaxAccessLevelInProjectsPreloader.new(projects, current_user).execute if projects.any?

        namespaces = work_items.map(&:namespace)
        namespaces_from_projects = projects.map(&:namespace)
        group_namespaces = (namespaces + namespaces_from_projects).select { |n| n.type == ::Group.sti_name }

        ::Preloaders::GroupPolicyPreloader.new(group_namespaces, current_user).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/linked_items_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class LinkedItemsResolver < BaseResolver
      prepend ::WorkItems::LookAheadPreloads

      argument :filter, ::Types::WorkItems::RelatedLinkTypeEnum,
        required: false,
        description: "Filter by link type. " \
          "Supported values: #{Types::WorkItems::RelatedLinkTypeEnum.values.keys.to_sentence}. " \
          'Returns all types if omitted.'

      type ::Types::WorkItems::LinkedItemType.connection_type, null: true

      def resolve_with_lookahead(**args)
        bulk_load_linked_items(args[:filter])
      end

      private

      def work_item
        object.is_a?(Issue) ? WorkItem.find_by_id(object.id) : object.work_item
      end
      strong_memoize_attr :work_item

      def node_selection(selection = lookahead)
        super.selection(:work_item)
      end

      def bulk_load_linked_items(link_type)
        # Calculate the current nesting level of linked items in the context path
        nesting_level = context[:current_path].count('linkedItems')
        batch_key = "linked_items_level_#{nesting_level}"

        BatchLoader::GraphQL.for(work_item.id).batch(key: batch_key, cache: false) do |item_ids, loader, _args|
          preloads = [:author, :work_item_type, { project: [:route, { namespace: :route }] }]
          linked_items = apply_lookahead(WorkItem.linked_items_for(item_ids, preload: preloads, link_type: link_type))
          grouped_by_source = linked_items_grouped_by_source(linked_items, item_ids)

          # Assign the grouped items to each work item ID in the batch loader
          item_ids.each do |id|
            loader.call(id, grouped_by_source[id] || [])
          end
        end
      end

      def linked_items_grouped_by_source(linked_items, item_ids)
        linked_items.each_with_object({}) do |item, result|
          # Find the ID of the item that this item links to
          target_id = [item.issue_link_source_id, item.issue_link_target_id].find { |id| id != item.id }
          # Skip items that don't link to our target or that the user can't read
          # We optimize authorization for items with the same properties to avoid redundant checks
          next unless item_ids.include?(target_id) && can_read_linked_item?(item)

          result[target_id] ||= []
          result[target_id] << item
        end
      end

      def can_read_linked_item?(item)
        return true if work_item.work_item_type_id == item.work_item_type_id &&
          work_item.resource_parent == item.resource_parent &&
          work_item.confidential == item.confidential

        Ability.allowed?(current_user, :read_work_item, item)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class WorkItemsResolver < BaseResolver
    prepend ::WorkItems::LookAheadPreloads
    include SearchArguments
    include ::WorkItems::SharedFilterArguments
    include ::WorkItems::NonStableCursorSortOptions

    argument :iid,
      GraphQL::Types::String,
      required: false,
      description: 'IID of the work item. For example, "1".'
    argument :sort,
      Types::WorkItems::SortEnum,
      description: 'Sort work items by criteria.',
      required: false,
      default_value: :created_desc

    type Types::WorkItemType.connection_type, null: true

    def resolve_with_lookahead(**args)
      return WorkItem.none if resource_parent.nil?

      # Adding skip_type_authorization in the resolver while it is conditionally enabled.
      # It can be moved to the field definition once the feature flag is removed
      # Issue: https://gitlab.com/gitlab-org/gitlab/-/issues/548096
      context.scoped_set!(:skip_type_authorization, [:read_work_item]) if skip_field_authorization?

      finder = choose_finder(args)

      items = Gitlab::Graphql::Loaders::IssuableLoader
        .new(resource_parent, finder)
        .batching_find_all { |q| apply_lookahead(q) }

      if non_stable_cursor_sort?(args[:sort])
        # Certain complex sorts are not supported by the stable cursor pagination yet.
        # In these cases, we use offset pagination, so we return the correct connection.
        offset_pagination(items)
      else
        items
      end
    end

    private

    def choose_finder(args)
      if ::Feature.enabled?(:glql_es_integration, current_user)
        glql_finder = glql_finder(args)

        return glql_finder if glql_finder.use_elasticsearch_finder?
      end

      finder(prepare_finder_params(args))
    end

    def glql_finder(args)
      ::WorkItems::Glql::WorkItemsFinder.new(current_user, context, resource_parent, args)
    end

    # When we search on a group level, this finder is being overwritten in
    # app/graphql/resolvers/namespaces/work_items_resolver.rb:32
    def finder(args)
      ::WorkItems::WorkItemsFinder.new(current_user, args)
    end

    def prepare_finder_params(args)
      params = super(args)
      params[:iids] ||= [params.delete(:iid)].compact if params[:iid]

      params
    end

    def resource_parent
      # The project could have been loaded in batch by `BatchLoader`.
      # At this point we need the `id` of the project to query for work items, so
      # make sure it's loaded and not `nil` before continuing.
      strong_memoize(:resource_parent) do
        obj = object.is_a?(::Namespaces::ProjectNamespace) ? object.project : object
        obj.respond_to?(:sync) ? obj.sync : obj
      end
    end

    def skip_field_authorization?
      Feature.enabled?(:authorize_issue_types_in_finder, resource_parent.root_ancestor, type: :gitlab_com_derisk)
    end
  end
end

Resolvers::WorkItemsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_item_state_counts_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  class WorkItemStateCountsResolver < WorkItemsResolver
    type Types::WorkItemStateCountsType, null: true

    def resolve(**args)
      return if resource_parent.nil?

      work_item_finder = finder(prepare_finder_params(args))
      work_item_finder.parent_param = resource_parent

      Gitlab::IssuablesCountForState.new(work_item_finder, resource_parent)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/types_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class TypesResolver < BaseResolver
      include LooksAhead

      type ::Types::WorkItems::TypeType.connection_type, null: true

      argument :name, ::Types::IssueTypeEnum,
        description: 'Filter work item types by the given name.',
        required: false

      def resolve_with_lookahead(name: nil)
        context.scoped_set!(:resource_parent, object)

        # This will require a finder in the future when groups/projects get their work item types
        # All groups/projects use all types for now
        base_scope = ::WorkItems::Type
        base_scope = base_scope.by_type(name) if name

        apply_lookahead(base_scope.order_by_name_asc)
      end

      private

      def preloads
        {
          widget_definitions: :enabled_widget_definitions
        }
      end

      def nested_preloads
        {
          widget_definitions: { allowed_child_types: :allowed_child_types_by_name,
                                allowed_parent_types: :allowed_parent_types_by_name }
        }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/user_preference_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class UserPreferenceResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      type ::Types::WorkItems::UserPreference, null: true

      authorize :read_namespace

      argument :namespace_path,
        GraphQL::Types::ID,
        required: true,
        description: 'Full path of the namespace the work item is created in.'

      argument :work_item_type_id,
        ::Types::GlobalIDType[::WorkItems::Type],
        required: false,
        description: 'Global ID of a work item type.'

      def resolve(namespace_path:, work_item_type_id: nil)
        namespace = ::Routable.find_by_full_path(namespace_path)
        namespace = namespace.project_namespace if namespace.is_a?(Project)
        authorize!(namespace)

        work_item_type_id = work_item_type_id&.model_id

        ::WorkItems::UserPreference.find_by_user_namespace_and_work_item_type_id(
          current_user,
          namespace,
          work_item_type_id
        )
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/user_work_items_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class UserWorkItemsResolver < BaseResolver
      prepend ::WorkItems::LookAheadPreloads
      include SearchArguments
      include ::WorkItems::SharedFilterArguments

      NON_FILTER_ARGUMENTS = %i[sort lookahead].freeze

      argument :sort,
        ::Types::WorkItems::SortEnum,
        description: 'Sort work items by criteria.',
        required: false,
        default_value: :created_desc

      type Types::WorkItemType.connection_type, null: true

      before_connection_authorization do |nodes, current_user|
        ::Preloaders::IssuablesPreloader.new(nodes, current_user, [:namespace]).preload_all
      end

      def ready?(**args)
        unless filter_provided?(args)
          raise Gitlab::Graphql::Errors::ArgumentError,
            _('You must provide at least one filter argument for this query')
        end

        super
      end

      def resolve_with_lookahead(**args)
        apply_lookahead(::WorkItems::WorkItemsFinder.new(current_user, prepare_finder_params(args)).execute)
      end

      private

      def filter_provided?(args)
        args.except(*NON_FILTER_ARGUMENTS).values.any?(&:present?)
      end
    end
  end
end

Resolvers::WorkItems::UserWorkItemsResolver.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/widgets_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class WidgetsResolver < BaseResolver
      type [::GraphQL::Types::String], null: true

      MAX_TYPES = 100

      argument :ids,
        [::Types::GlobalIDType[::WorkItems::Type]],
        required: true,
        description: <<~DESC.squish
          Global ID array of work items types to fetch available widgets for.
          A max of #{MAX_TYPES} IDs can be provided at a time.
        DESC

      argument :union,
        ::GraphQL::Types::Boolean,
        default_value: false,
        description: <<~DESC.squish
          When true, returns the union of widgets across all work item types.
          When false, returns only widgets common to all work item types.
        DESC

      def ready?(**args)
        if args[:ids].size > MAX_TYPES
          raise Gitlab::Graphql::Errors::ArgumentError,
            format(
              _('No more than %{max_work_items} work items can be loaded at the same time'),
              max_work_items: MAX_TYPES
            )
        end

        super
      end

      def resolve(ids:, union: false)
        all_widgets = ::WorkItems::Type
          .id_in(ids.map(&:model_id))
          .with_widget_definition_preload
          .map { |type| type.widgets(resource_parent).map { |widget| widget.widget_type.upcase } }

        return [] if all_widgets.blank?

        if union
          all_widgets.reduce(:|)
        else
          all_widgets.reduce(:&)
        end
      end

      private

      def resource_parent
        object.respond_to?(:sync) ? object.sync : object
      end
      strong_memoize_attr :resource_parent
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/resolvers/work_items/work_item_discussions_resolver.rb =====
# frozen_string_literal: true

module Resolvers
  module WorkItems
    class WorkItemDiscussionsResolver < BaseResolver
      include Gitlab::Graphql::Authorize::AuthorizeResource

      authorize :read_work_item
      authorizes_object!

      # this resolver may be calling gitaly as part of parsing notes that contain commit references
      calls_gitaly!

      alias_method :notes_widget, :object

      argument :filter, ::Types::WorkItems::NotesFilterTypeEnum,
        required: false,
        default_value: ::Types::WorkItems::NotesFilterTypeEnum.default_value,
        description: 'Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY.'

      type ::Types::Notes::DiscussionType.connection_type, null: true

      def resolve(**args)
        finder = Issuable::DiscussionsListService.new(current_user, work_item, params(args))

        # precompute noteable_url once so that it is reused for all notes
        context.scoped_set!(:noteable_url, ::Gitlab::UrlBuilder.build(object.work_item))

        Gitlab::Graphql::ExternallyPaginatedArray.new(
          finder.paginator.cursor_for_previous_page,
          finder.paginator.cursor_for_next_page,
          *finder.execute
        )
      end

      def self.calculate_ext_conn_complexity
        true
      end

      def self.complexity_multiplier(args)
        0.05
      end

      private

      def work_item
        notes_widget.work_item
      end
      strong_memoize_attr :work_item

      def params(args)
        {
          notes_filter: args[:filter],
          cursor: args[:after],
          per_page: self.class.nodes_limit(args, @field, context: context)
        }
      end

      def self.nodes_limit(args, field, **kwargs)
        page_size = field&.max_page_size || kwargs[:context]&.schema&.default_max_page_size
        [args[:first], page_size].compact.min
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/base_subscription.rb =====
# frozen_string_literal: true

module Subscriptions
  class BaseSubscription < GraphQL::Schema::Subscription
    include Gitlab::Graphql::VersionFilter::FutureFieldFallback

    object_class Types::BaseObject
    field_class Types::BaseField

    UNAUTHORIZED_ERROR_MESSAGE = 'Unauthorized subscription'

    def initialize(object:, context:, field:)
      super

      # Reset user so that we don't use a stale user for authorization
      current_user.reset if current_user
    end

    # We override graphql-ruby's default `subscribe` since it returns
    # :no_response instead, which leads to empty hashes rendered out
    # to the caller which has caused problems in the client.
    #
    # Eventually, we should move to an approach where the caller receives
    # a response here upon subscribing, but we don't need this currently
    # because Vue components also perform an initial fetch query.
    # See https://gitlab.com/gitlab-org/gitlab/-/issues/402614
    def subscribe(*)
      nil
    end

    def authorized?(*)
      raise NotImplementedError
    end

    private

    def unauthorized!
      unsubscribe if context.query.subscription_update?

      raise GraphQL::ExecutionError, UNAUTHORIZED_ERROR_MESSAGE
    end

    def current_user
      context[:current_user]
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/ci/jobs/status_updated.rb =====
# frozen_string_literal: true

module Subscriptions
  module Ci
    module Jobs
      class StatusUpdated < ::Subscriptions::BaseSubscription
        include Gitlab::Graphql::Laziness

        argument :job_id, ::Types::GlobalIDType[::Ci::Build],
          required: true,
          description: 'Global ID of the job.'

        payload_type Types::Ci::JobType

        def authorized?(job_id:)
          job = force(GitlabSchema.find_by_gid(job_id))

          unauthorized! unless job && Ability.allowed?(current_user, :read_build, job)

          true
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/ci/pipelines/status_updated.rb =====
# frozen_string_literal: true

module Subscriptions
  module Ci
    module Pipelines
      class StatusUpdated < ::Subscriptions::BaseSubscription
        include Gitlab::Graphql::Laziness

        argument :pipeline_id, ::Types::GlobalIDType[::Ci::Pipeline],
          required: true,
          description: 'Global ID of the pipeline.'

        payload_type Types::Ci::PipelineType

        def authorized?(pipeline_id:)
          pipeline = force(GitlabSchema.find_by_gid(pipeline_id))

          unauthorized! unless pipeline && Ability.allowed?(current_user, :read_pipeline, pipeline)

          true
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/issuable_updated.rb =====
# frozen_string_literal: true

module Subscriptions
  class IssuableUpdated < BaseSubscription
    include Gitlab::Graphql::Laziness

    payload_type Types::IssuableType

    argument :issuable_id, Types::GlobalIDType[Issuable],
      required: true,
      description: 'ID of the issuable.'

    def authorized?(issuable_id:)
      issuable = force(GitlabSchema.find_by_gid(issuable_id))

      unauthorized! unless issuable && Ability.allowed?(current_user, :"read_#{issuable.to_ability_name}", issuable)

      true
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/notes/base.rb =====
# frozen_string_literal: true

module Subscriptions
  module Notes
    class Base < ::Subscriptions::BaseSubscription
      include Gitlab::Graphql::Laziness

      argument :noteable_id, ::Types::GlobalIDType[::Noteable],
        required: false,
        description: 'ID of the noteable.'

      def authorized?(noteable_id:)
        noteable = force(GitlabSchema.find_by_gid(noteable_id))

        # unsubscribe if user cannot read the noteable anymore for any reason, e.g. issue was set confidential,
        # in the meantime the read note permissions is checked within its corresponding returned type, i.e. NoteType
        unauthorized! unless noteable && Ability.allowed?(current_user, :"read_#{noteable.to_ability_name}", noteable)

        true
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/notes/created.rb =====
# frozen_string_literal: true

module Subscriptions
  module Notes
    class Created < Base
      payload_type ::Types::Notes::NoteType

      def update(*args)
        case object
        when ResourceEvent
          object.work_item_synthetic_system_note
        when Array
          object.first.work_item_synthetic_system_note(events: object)
        else
          object
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/notes/deleted.rb =====
# frozen_string_literal: true

module Subscriptions
  module Notes
    class Deleted < Base
      payload_type ::Types::Notes::DeletedNoteType

      DeletedNote = Struct.new(:model_id, :model_name, :discussion_model_id, :last_discussion_note) do
        def to_global_id
          ::Gitlab::GlobalId.as_global_id(model_id, model_name: model_name)
        end

        def discussion_id
          ::Gitlab::GlobalId.as_global_id(discussion_model_id, model_name: Discussion.name)
        end
      end

      def update(*args)
        DeletedNote.new(object[:id], object[:model_name], object[:discussion_id], object[:last_discussion_note])
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/notes/updated.rb =====
# frozen_string_literal: true

module Subscriptions
  module Notes
    class Updated < Base
      payload_type Types::Notes::NoteType

      private

      def update(*)
        ::Gitlab::Database::LoadBalancing::SessionMap.current(object.load_balancer).use_primary do
          object.reset
        end
        object
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/user/merge_request_updated.rb =====
# frozen_string_literal: true

module Subscriptions
  module User
    class MergeRequestUpdated < ::Subscriptions::BaseSubscription
      include Gitlab::Graphql::Laziness

      argument :user_id, ::Types::GlobalIDType[::User],
        required: true,
        description: 'ID of the user.'

      payload_type Types::MergeRequestType

      def authorized?(user_id:)
        user = force(GitlabSchema.find_by_gid(user_id))

        unauthorized! unless user && current_user.id == user.id

        true
      end

      def update(user_id:)
        return NO_UPDATE unless Ability.allowed?(current_user, :read_merge_request, object)

        super
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/subscriptions/work_item_updated.rb =====
# frozen_string_literal: true

module Subscriptions
  class WorkItemUpdated < BaseSubscription
    include Gitlab::Graphql::Laziness

    payload_type Types::WorkItemType

    argument :work_item_id, Types::GlobalIDType[WorkItem],
      required: true,
      description: 'ID of the work item.'

    def authorized?(work_item_id:)
      work_item = force(GitlabSchema.find_by_gid(work_item_id))

      unauthorized! unless work_item && Ability.allowed?(current_user, :"read_#{work_item.to_ability_name}", work_item)

      true
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/abuse_report_type.rb =====
# frozen_string_literal: true

module Types
  class AbuseReportType < BaseObject
    graphql_name 'AbuseReport'

    description 'An abuse report'

    authorize :read_abuse_report

    field :id, Types::GlobalIDType[::AbuseReport],
      null: false, description: 'Global ID of the abuse report.'

    field :labels, ::Types::AntiAbuse::AbuseReportLabelType.connection_type,
      null: true, description: 'Labels of the abuse report.'

    field :discussions, ::Types::Notes::AbuseReport::DiscussionType.connection_type,
      null: false, description: "All discussions on the noteable."
    field :notes, ::Types::Notes::AbuseReport::NoteType.connection_type,
      null: false, description: "All notes on the noteable."
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/access_level_enum.rb =====
# frozen_string_literal: true

module Types
  class AccessLevelEnum < BaseEnum
    graphql_name 'AccessLevelEnum'
    description 'Access level to a resource'

    value 'NO_ACCESS', value: Gitlab::Access::NO_ACCESS, description: 'No access.'
    value 'MINIMAL_ACCESS', value: Gitlab::Access::MINIMAL_ACCESS, description: 'Minimal access.'
    value 'GUEST', value: Gitlab::Access::GUEST, description: 'Guest access.'
    value 'PLANNER', value: Gitlab::Access::PLANNER, description: 'Planner access.'
    value 'REPORTER', value: Gitlab::Access::REPORTER, description: 'Reporter access.'
    value 'DEVELOPER', value: Gitlab::Access::DEVELOPER, description: 'Developer access.'
    value 'MAINTAINER', value: Gitlab::Access::MAINTAINER, description: 'Maintainer access.'
    value 'OWNER', value: Gitlab::Access::OWNER, description: 'Owner access.'
  end
end

Types::AccessLevelEnum.prepend_mod_with('Types::AccessLevelEnum')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/access_levels/deploy_key_type.rb =====
# frozen_string_literal: true

module Types
  module AccessLevels
    class DeployKeyType < BaseObject
      graphql_name 'AccessLevelDeployKey'
      description 'Representation of a GitLab deploy key.'

      authorize :read_deploy_key

      field :id,
        type: GraphQL::Types::ID,
        null: false,
        description: 'ID of the deploy key.'

      field :title,
        type: GraphQL::Types::String,
        null: false,
        description: 'Title of the deploy key.'

      field :expires_at,
        type: Types::DateType,
        null: true,
        description: 'Expiration date of the deploy key.'

      field :user,
        type: Types::AccessLevels::UserType,
        null: false,
        description: 'User assigned to the deploy key.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/access_levels/user_type.rb =====
# frozen_string_literal: true

module Types
  module AccessLevels
    class UserType < BaseObject
      graphql_name 'AccessLevelUser'
      description 'Representation of a GitLab user.'

      authorize :read_user

      present_using UserPresenter

      field :id,
        type: GraphQL::Types::ID,
        null: false,
        description: 'ID of the user.'

      field :username,
        type: GraphQL::Types::String,
        null: false,
        description: 'Username of the user.'

      field :name,
        type: GraphQL::Types::String,
        null: false,
        resolver_method: :redacted_name,
        description: <<~DESC
          Human-readable name of the user.
          Returns `****` if the user is a project bot and the requester does not have permission to view the project.
        DESC

      field :public_email,
        type: GraphQL::Types::String,
        null: true,
        description: "User's public email."

      field :avatar_url,
        type: GraphQL::Types::String,
        null: true,
        description: "URL of the user's avatar."

      field :web_url,
        type: GraphQL::Types::String,
        null: false,
        description: 'Web URL of the user.'

      field :web_path,
        type: GraphQL::Types::String,
        null: false,
        description: 'Web path of the user.'

      def redacted_name
        object.redacted_name(context[:current_user])
      end

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/access_level_type.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/AuthorizeTypes

module Types
  class AccessLevelType < Types::BaseObject
    graphql_name 'AccessLevel'
    description 'Represents the access level of a relationship between a User and object that it is related to'

    field :integer_value, GraphQL::Types::Int, null: true,
      description: 'Integer number of the access level.',
      method: :to_i

    field :string_value, Types::AccessLevelEnum, null: true,
      description: 'Enum string of the the access level.',
      method: :to_i

    field :human_access, GraphQL::Types::String, null: true,
      description: 'Human-readable display name for the access level.'

    def human_access
      ::Gitlab::Access.human_access_with_none(object)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/achievements/achievement_type.rb =====
# frozen_string_literal: true

module Types
  module Achievements
    class AchievementType < BaseObject
      graphql_name 'Achievement'

      connection_type_class Types::CountableConnectionType

      authorize :read_achievement

      field :id,
        ::Types::GlobalIDType[::Achievements::Achievement],
        null: false,
        description: 'ID of the achievement.'

      field :namespace,
        ::Types::NamespaceType,
        description: 'Namespace of the achievement.'

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the achievement.'

      field :avatar_url,
        GraphQL::Types::String,
        null: true,
        description: 'URL to avatar of the achievement.'

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description or notes for the achievement.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the achievement was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the achievement was last updated.'

      field :user_achievements,
        Types::Achievements::UserAchievementType.connection_type,
        null: true,
        experiment: { milestone: '15.10' },
        description: "Recipients for the achievement.",
        extras: [:lookahead],
        resolver: ::Resolvers::Achievements::UserAchievementsResolver

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/achievements/user_achievement_type.rb =====
# frozen_string_literal: true

module Types
  module Achievements
    class UserAchievementType < BaseObject
      graphql_name 'UserAchievement'

      connection_type_class Types::CountableConnectionType

      authorize :read_user_achievement

      field :id,
        ::Types::GlobalIDType[::Achievements::UserAchievement],
        null: false,
        description: 'ID of the user achievement.'

      field :achievement,
        ::Types::Achievements::AchievementType,
        null: false,
        description: 'Achievement awarded.'

      field :user,
        ::Types::UserType,
        null: false,
        description: 'Achievement recipient.'

      field :awarded_by_user,
        ::Types::UserType,
        null: false,
        description: 'Awarded by.'

      field :revoked_by_user,
        ::Types::UserType,
        null: true,
        description: 'Revoked by.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the achievement was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the achievement was last updated.'

      field :revoked_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the achievement was revoked.'

      field :priority,
        GraphQL::Types::Int,
        null: true,
        description: 'Priority of the user achievement.'

      field :show_on_profile,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates whether or not the achievement is shown on the profile.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/admin/analytics/usage_trends/measurement_identifier_enum.rb =====
# frozen_string_literal: true

module Types
  module Admin
    module Analytics
      module UsageTrends
        class MeasurementIdentifierEnum < BaseEnum
          graphql_name 'MeasurementIdentifier'
          description 'Possible identifier types for a measurement'

          value 'PROJECTS', 'Project count.', value: 'projects'
          value 'USERS', 'User count.', value: 'users'
          value 'ISSUES', 'Issue count.', value: 'issues'
          value 'MERGE_REQUESTS', 'Merge request count.', value: 'merge_requests'
          value 'GROUPS', 'Group count.', value: 'groups'
          value 'PIPELINES', 'Pipeline count.', value: 'pipelines'
          value 'PIPELINES_SUCCEEDED', 'Pipeline count with success status.', value: 'pipelines_succeeded'
          value 'PIPELINES_FAILED', 'Pipeline count with failed status.', value: 'pipelines_failed'
          value 'PIPELINES_CANCELED', 'Pipeline count with canceled status.', value: 'pipelines_canceled'
          value 'PIPELINES_SKIPPED', 'Pipeline count with skipped status.', value: 'pipelines_skipped'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/admin/analytics/usage_trends/measurement_type.rb =====
# frozen_string_literal: true

module Types
  module Admin
    module Analytics
      module UsageTrends
        class MeasurementType < BaseObject
          graphql_name 'UsageTrendsMeasurement'
          description 'Represents a recorded measurement (object count) for the Admins'

          include Gitlab::Graphql::Authorize::AuthorizeResource

          authorize :read_usage_trends_measurement

          field :recorded_at, Types::TimeType, null: true,
            description: 'Time the measurement was recorded.'

          field :count, GraphQL::Types::Int, null: false,
            description: 'Object count.'

          field :identifier,
            Types::Admin::Analytics::UsageTrends::MeasurementIdentifierEnum,
            null: false,
            description: 'Type of objects being measured.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/admin/sidekiq_queues/delete_jobs_response_type.rb =====
# frozen_string_literal: true

module Types
  module Admin
    module SidekiqQueues
      # We can't authorize against the value passed to this because it's
      # a plain hash.
      class DeleteJobsResponseType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
        graphql_name 'DeleteJobsResponse'
        description 'The response from the AdminSidekiqQueuesDeleteJobs mutation'

        field :completed,
          GraphQL::Types::Boolean,
          null: true,
          description: 'Whether or not the entire queue was processed in time; if not, retrying the same request is safe.'

        field :deleted_jobs,
          GraphQL::Types::Int,
          null: true,
          description: 'Number of matching jobs deleted.'

        field :queue_size,
          GraphQL::Types::Int,
          null: true,
          description: 'Queue size after processing.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/alert_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class AlertSortEnum < SortEnum
      graphql_name 'AlertManagementAlertSort'
      description 'Values for sorting alerts'

      value 'STARTED_AT_ASC', 'Start time by ascending order.', value: :started_at_asc
      value 'STARTED_AT_DESC', 'Start time by descending order.', value: :started_at_desc
      value 'ENDED_AT_ASC', 'End time by ascending order.', value: :ended_at_asc
      value 'ENDED_AT_DESC', 'End time by descending order.', value: :ended_at_desc
      value 'CREATED_TIME_ASC', 'Created time by ascending order.', value: :created_at_asc
      value 'CREATED_TIME_DESC', 'Created time by descending order.', value: :created_at_desc
      value 'UPDATED_TIME_ASC', 'Created time by ascending order.', value: :updated_at_asc
      value 'UPDATED_TIME_DESC', 'Created time by descending order.', value: :updated_at_desc
      value 'EVENT_COUNT_ASC', 'Events count by ascending order.', value: :event_count_asc
      value 'EVENT_COUNT_DESC', 'Events count by descending order.', value: :event_count_desc
      value 'SEVERITY_ASC', 'Severity from less critical to more critical.', value: :severity_asc
      value 'SEVERITY_DESC', 'Severity from more critical to less critical.', value: :severity_desc
      value 'STATUS_ASC', 'Status by order: `Ignored > Resolved > Acknowledged > Triggered`.', value: :status_asc
      value 'STATUS_DESC', 'Status by order: `Triggered > Acknowledged > Resolved > Ignored`.', value: :status_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/alert_status_counts_type.rb =====
# frozen_string_literal: true

# Service for managing alert counts and cache updates.
module Types
  module AlertManagement
    class AlertStatusCountsType < BaseObject
      graphql_name 'AlertManagementAlertStatusCountsType'
      description "Represents total number of alerts for the represented categories"

      authorize :read_alert_management_alert

      ::AlertManagement::Alert.status_names.each do |status|
        field status,
          GraphQL::Types::Int,
          null: true,
          description: "Number of alerts with status #{status.to_s.upcase} for the project"
      end

      field :open,
        GraphQL::Types::Int,
        null: true,
        description: 'Number of alerts with status TRIGGERED or ACKNOWLEDGED for the project.'

      field :all,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of alerts for the project.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/alert_type.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class AlertType < BaseObject
      graphql_name 'AlertManagementAlert'
      description "Describes an alert from the project's Alert Management"

      present_using ::AlertManagement::AlertPresenter

      implements Types::Notes::NoteableInterface
      implements Types::TodoableInterface

      authorize :read_alert_management_alert

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'ID of the alert.'

      field :iid,
        GraphQL::Types::String,
        null: false,
        description: 'Internal ID of the alert.'

      field :issue_iid,
        GraphQL::Types::String,
        null: true,
        deprecated: { reason: 'Use issue field', milestone: '13.10' },
        description: 'Internal ID of the GitLab issue attached to the alert.'

      field :issue,
        Types::IssueType,
        null: true,
        description: 'Issue attached to the alert.'

      field :title,
        GraphQL::Types::String,
        null: true,
        description: 'Title of the alert.'

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of the alert.'

      field :severity,
        AlertManagement::SeverityEnum,
        null: true,
        description: 'Severity of the alert.'

      field :status,
        AlertManagement::StatusEnum,
        null: true,
        description: 'Status of the alert.',
        method: :status_name

      field :service,
        GraphQL::Types::String,
        null: true,
        description: 'Service the alert came from.'

      field :monitoring_tool,
        GraphQL::Types::String,
        null: true,
        description: 'Monitoring tool the alert came from.'

      field :hosts,
        [GraphQL::Types::String],
        null: true,
        description: 'List of hosts the alert came from.'

      field :started_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the alert was raised.'

      field :ended_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the alert ended.'

      field :environment,
        Types::EnvironmentType,
        null: true,
        description: 'Environment for the alert.'

      field :event_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Number of events of the alert.',
        method: :events

      field :details, # rubocop:disable Graphql/JSONType
        GraphQL::Types::JSON,
        null: true,
        description: 'Alert details.'

      field :created_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the alert was created.'

      field :updated_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the alert was last updated.'

      field :assignees,
        Types::UserType.connection_type,
        null: true,
        description: 'Assignees of the alert.'

      field :metrics_dashboard_url,
        GraphQL::Types::String,
        null: true,
        description: 'URL for metrics embed for the alert.',
        deprecated: { reason: 'Returns no data. Underlying feature was removed in 16.0',
                      milestone: '16.0' }
      field :runbook,
        GraphQL::Types::String,
        null: true,
        description: 'Runbook for the alert as defined in alert details.'

      field :todos,
        Types::TodoType.connection_type,
        description: 'To-do items of the current user for the alert.',
        resolver: Resolvers::TodosResolver

      field :details_url,
        GraphQL::Types::String,
        null: false,
        description: 'URL of the alert detail page.'

      field :prometheus_alert,
        Types::PrometheusAlertType,
        null: true,
        description: 'Alert condition for Prometheus.',
        deprecated: {
          reason: 'Returns no data. Underlying feature was removed in 16.0',
          milestone: '17.3'
        }

      field :web_url,
        GraphQL::Types::String,
        method: :details_url,
        null: false,
        description: 'URL of the alert.'

      def metrics_dashboard_url
        nil
      end

      def prometheus_alert
        nil
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/domain_filter_enum.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class DomainFilterEnum < BaseEnum
      graphql_name 'AlertManagementDomainFilter'
      description  'Filters the alerts based on given domain'

      value 'operations', description: 'Alerts for operations domain.'
      value 'threat_monitoring',
        description: 'Alerts for threat monitoring domain.',
        deprecated: {
          reason: 'Network policies are deprecated and will be removed in GitLab 16.0',
          milestone: '15.0'
        }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/http_integration_type.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class HttpIntegrationType < BaseObject
      graphql_name 'AlertManagementHttpIntegration'
      description 'An endpoint and credentials used to accept alerts for a project'

      implements Types::AlertManagement::IntegrationType

      authorize :admin_operations
    end
  end
end

Types::AlertManagement::HttpIntegrationType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/integration_type_enum.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class IntegrationTypeEnum < BaseEnum
      graphql_name 'AlertManagementIntegrationType'
      description 'Values of types of integrations'

      value 'PROMETHEUS', 'Prometheus integration.', value: :prometheus
      value 'HTTP', 'Integration with any monitoring tool.', value: :http
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/integration_type.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    module IntegrationType
      include Types::BaseInterface
      graphql_name 'AlertManagementIntegration'

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'ID of the integration.'

      field :type,
        AlertManagement::IntegrationTypeEnum,
        null: false,
        description: 'Type of integration.'

      field :name,
        GraphQL::Types::String,
        null: true,
        description: 'Name of the integration.'

      field :active,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Whether the endpoint is currently accepting alerts.'

      field :token,
        GraphQL::Types::String,
        null: true,
        description: 'Token used to authenticate alert notification requests.'

      field :url,
        GraphQL::Types::String,
        null: true,
        description: 'Endpoint which accepts alert notifications.'

      field :api_url,
        GraphQL::Types::String,
        null: true,
        description: 'URL at which Prometheus metrics can be queried to populate the metrics dashboard.',
        deprecated: { reason: 'Feature removed in 16.0', milestone: '18.2' }

      def type
        object.type_identifier.to_sym
      end

      def api_url
        nil
      end

      definition_methods do
        def resolve_type(object, context)
          if object.type_identifier == 'prometheus'
            Types::AlertManagement::PrometheusIntegrationType
          else
            Types::AlertManagement::HttpIntegrationType
          end
        end
      end

      orphan_types Types::AlertManagement::PrometheusIntegrationType,
        Types::AlertManagement::HttpIntegrationType
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/prometheus_integration_type.rb =====
# frozen_string_literal: true

# Deprecated:
#   Remove with PrometheusIntegration mutations during any major release.
module Types
  module AlertManagement
    class PrometheusIntegrationType < ::Types::BaseObject
      graphql_name 'AlertManagementPrometheusIntegration'
      description '**DEPRECATED - Use AlertManagementHttpIntegration directly** An endpoint and credentials used to accept Prometheus alerts for a project'

      implements Types::AlertManagement::IntegrationType

      authorize :admin_operations
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/severity_enum.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class SeverityEnum < BaseEnum
      graphql_name 'AlertManagementSeverity'
      description 'Alert severity values'

      ::AlertManagement::Alert.severities.keys.each do |severity|
        value severity.upcase, value: severity, description: "#{severity.titleize} severity"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/alert_management/status_enum.rb =====
# frozen_string_literal: true

module Types
  module AlertManagement
    class StatusEnum < BaseEnum
      graphql_name 'AlertManagementStatus'
      description 'Alert status values'

      ::AlertManagement::Alert.status_names.each do |status|
        value status.to_s.upcase, value: status, description: "#{::AlertManagement::Alert::STATUS_DESCRIPTIONS[status]}."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/flow_metrics.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      module FlowMetrics
        def self.[](context = :project)
          Class.new(BaseObject) do
            graphql_name "#{context.capitalize}ValueStreamAnalyticsFlowMetrics"
            description 'Exposes aggregated value stream flow metrics'

            field :issue_count,
              Types::Analytics::CycleAnalytics::MetricType,
              null: true,
              description: 'Number of issues opened in the given period.',
              resolver: Resolvers::Analytics::CycleAnalytics::IssueCountResolver[context]
            field :deployment_count,
              Types::Analytics::CycleAnalytics::MetricType,
              null: true,
              description: 'Number of production deployments in the given period.',
              resolver: Resolvers::Analytics::CycleAnalytics::DeploymentCountResolver[context]
          end
        end
      end
    end
  end
end

mod = Types::Analytics::CycleAnalytics::FlowMetrics
mod.prepend_mod_with('Types::Analytics::CycleAnalytics::FlowMetrics')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/link_type.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      # rubocop: disable Graphql/AuthorizeTypes
      class LinkType < BaseObject
        graphql_name 'ValueStreamMetricLinkType'

        field :name,
          GraphQL::Types::String,
          null: false,
          description: 'Name of the link group.'

        field :label,
          GraphQL::Types::String,
          null: false,
          description: 'Label for the link.'

        field :url,
          GraphQL::Types::String,
          null: false,
          description: 'Drill-down URL.'

        field :docs_link,
          GraphQL::Types::Boolean,
          null: true,
          description: 'Link to the metric documentation.'
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/metric_type.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      # rubocop: disable Graphql/AuthorizeTypes
      class MetricType < BaseObject
        graphql_name 'ValueStreamAnalyticsMetric'
        description ''

        field :value,
          GraphQL::Types::Float,
          null: true,
          description: 'Value for the metric.'

        field :identifier,
          GraphQL::Types::String,
          null: false,
          description: 'Identifier for the metric.'

        field :unit,
          GraphQL::Types::String,
          null: true,
          description: 'Unit of measurement.'

        field :title,
          GraphQL::Types::String,
          null: false,
          description: 'Title for the metric.'

        field :links,
          [LinkType],
          null: false,
          description: 'Optional links for drilling down.'
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/value_streams/stage_event_enum.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      module ValueStreams
        class StageEventEnum < BaseEnum
          graphql_name 'ValueStreamStageEvent'
          description 'Stage event identifiers'

          Gitlab::Analytics::CycleAnalytics::StageEvents.to_enum.each do |key, value|
            value(key.to_s.upcase, description: "#{key.to_s.humanize} event.", value: value)
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/value_streams/stage_items_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      module ValueStreams
        class StageItemsSortEnum < BaseEnum
          graphql_name 'ValueStreamStageItemSort'
          description 'Sorting values available to value stream stage items'

          value 'DURATION_ASC', 'Duration by ascending order.', value: { sort: :duration, direction: :asc }
          value 'DURATION_DESC', 'Duration by ascending order.', value: { sort: :duration, direction: :desc }
          value 'END_EVENT_ASC', 'Stage end event time by ascending order.',
            value: { sort: :end_event, direction: :asc }
          value 'END_EVENT_DESC', 'Stage end event time by descending order.',
            value: { sort: :end_event, direction: :desc }
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/value_streams/stage_items_type.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      module ValueStreams
        # rubocop: disable Graphql/AuthorizeTypes -- # Already authorized in parent.
        class StageItemsType < BaseObject
          graphql_name 'ValueStreamStageItems'

          include EntityDateHelper

          field :end_event_timestamp,
            Types::TimeType,
            null: true,
            description: 'When exited the stage.'

          field :duration,
            GraphQL::Types::String,
            null: true,
            description: 'Duration of the item on the stage.'

          field :record,
            ::Types::IssuableType,
            null: true,
            description: 'Item record.'

          def duration
            return unless object.total_time.present?

            duration_array = distance_of_time_as_hash(object.total_time.to_f).first

            duration_array.reverse.join(' ')
          end

          def record
            object
          end
        end
        # rubocop: enable Graphql/AuthorizeTypes
      end
    end
  end
end

Types::Analytics::CycleAnalytics::ValueStreams::StageItemsType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/value_streams/stage_metrics_type.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      module ValueStreams
        # rubocop: disable Graphql/AuthorizeTypes -- # Already authorized in parent value stream type.
        class StageMetricsType < BaseObject
          graphql_name 'ValueStreamStageMetrics'

          field :average,
            ::Types::Analytics::CycleAnalytics::MetricType,
            description: 'Average duration in seconds.'

          field :count,
            ::Types::Analytics::CycleAnalytics::MetricType,
            description: 'Limited item count. The backend counts maximum 1000 items, ' \
              'for free projects, and maximum 10,000 items for licensed ' \
              'projects or licensed groups.'

          field :median,
            ::Types::Analytics::CycleAnalytics::MetricType,
            description: 'Median duration in seconds.'

          field :items,
            description: 'Items in the stage.',
            resolver: Resolvers::Analytics::CycleAnalytics::ValueStreams::StageItemsResolver,
            experiment: { milestone: '17.4' }

          def count
            {
              value: object.count,
              identifier: 'value_stream_stage_count',
              title: s_('CycleAnalytics|Item count')
            }
          end

          def average
            {
              value: object.average.seconds,
              identifier: 'value_stream_stage_average',
              title: s_('CycleAnalytics|Average duration'),
              unit: s_('CycleAnalytics|seconds')
            }
          end

          def median
            {
              value: object.median.seconds,
              identifier: 'value_stream_stage_median',
              title: s_('CycleAnalytics|Median duration'),
              unit: s_('CycleAnalytics|seconds')
            }
          end
        end
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end

Types::Analytics::CycleAnalytics::ValueStreams::StageMetricsType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/value_streams/stage_type.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      module ValueStreams
        # rubocop: disable Graphql/AuthorizeTypes -- # Already authorized in parent value stream type.
        class StageType < BaseObject
          graphql_name 'ValueStreamStage'

          field :id,
            type: ::Types::GlobalIDType[::Analytics::CycleAnalytics::Stage],
            null: false,
            description: "ID of the value stream."

          field :name,
            GraphQL::Types::String,
            null: false,
            description: 'Name of the stage.'

          field :hidden,
            GraphQL::Types::Boolean,
            null: false,
            description: 'Whether the stage is hidden.'

          field :custom,
            GraphQL::Types::Boolean,
            null: false,
            description: 'Whether the stage is customized.'

          field :start_event_identifier,
            StageEventEnum,
            null: false,
            description: 'Start event identifier.'

          field :end_event_identifier,
            StageEventEnum,
            null: false,
            description: 'End event identifier.'

          field :start_event_html_description,
            GraphQL::Types::String,
            null: false,
            description: 'HTML description of the start event.'

          field :end_event_html_description,
            GraphQL::Types::String,
            null: false,
            description: 'HTML description of the end event.'

          field :metrics,
            Types::Analytics::CycleAnalytics::ValueStreams::StageMetricsType,
            null: false,
            resolver: Resolvers::Analytics::CycleAnalytics::ValueStreams::StageMetricsResolver,
            description: 'Aggregated metrics for the given stage'

          def start_event_identifier
            events_enum[object.start_event_identifier]
          end

          def end_event_identifier
            events_enum[object.end_event_identifier]
          end

          def start_event_html_description
            stage_entity.start_event_html_description
          end

          def end_event_html_description
            stage_entity.end_event_html_description
          end

          def events_enum
            Gitlab::Analytics::CycleAnalytics::StageEvents.to_enum.with_indifferent_access
          end

          def stage_entity
            @stage_entity ||= ::Analytics::CycleAnalytics::StageEntity.new(object)
          end
        end
        # rubocop: enable Graphql/AuthorizeTypes
      end
    end
  end
end

Types::Analytics::CycleAnalytics::ValueStreams::StageType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/analytics/cycle_analytics/value_stream_type.rb =====
# frozen_string_literal: true

module Types
  module Analytics
    module CycleAnalytics
      class ValueStreamType < BaseObject
        graphql_name 'ValueStream'

        authorize :read_cycle_analytics

        field :id,
          type: ::Types::GlobalIDType[::Analytics::CycleAnalytics::ValueStream],
          null: false,
          description: "ID of the value stream."

        field :name,
          GraphQL::Types::String,
          null: false,
          description: 'Name of the value stream.'

        field :namespace, Types::NamespaceType,
          null: false,
          description: 'Namespace the value stream belongs to.'

        field :project, Types::ProjectType,
          null: true,
          description: 'Project the value stream belongs to, returns empty if it belongs to a group.',
          experiment: { milestone: '15.6' }

        field :stages,
          null: true,
          resolver: Resolvers::Analytics::CycleAnalytics::StagesResolver,
          description: 'Value Stream stages.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/anti_abuse/abuse_report_label_type.rb =====
# frozen_string_literal: true

module Types
  module AntiAbuse
    class AbuseReportLabelType < BaseObject
      graphql_name 'AbuseReportLabel'

      implements LabelInterface

      connection_type_class Types::CountableConnectionType

      authorize :read_label

      field :id, Types::GlobalIDType[::AntiAbuse::Reports::Label],
        null: false,
        description: 'Global ID of the abuse report label.'

      markdown_field :description_html, null: true
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/app_config/gitlab_instance_feature_flag_type.rb =====
# frozen_string_literal: true

module Types
  module AppConfig
    class GitlabInstanceFeatureFlagType < ::Types::BaseObject
      graphql_name 'GitlabInstanceFeatureFlag'
      description 'A feature flag for the GitLab instance.'

      authorize :read_instance_metadata

      field :enabled, ::GraphQL::Types::Boolean, null: false,
        description: 'Indicates whether the GitLab instance feature flag is enabled or not.'
      field :name, ::GraphQL::Types::String, null: false,
        description: 'Name of the GitLab instance feature flag.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/app_config/instance_metadata_type.rb =====
# frozen_string_literal: true

module Types
  module AppConfig
    class InstanceMetadataType < ::Types::BaseObject
      graphql_name 'Metadata'

      authorize :read_instance_metadata

      field :enterprise, GraphQL::Types::Boolean, null: false,
        description: 'Enterprise edition.'
      field :feature_flags, [::Types::AppConfig::GitlabInstanceFeatureFlagType], null: false,
        description: 'Feature flags for the GitLab instance.',
        experiment: { milestone: '17.4' },
        resolver: ::Resolvers::AppConfig::GitlabInstanceFeatureFlagsResolver
      field :kas, ::Types::AppConfig::KasType, null: false,
        description: 'Metadata about KAS.'
      field :revision, GraphQL::Types::String, null: false,
        description: 'Revision.'
      field :version, GraphQL::Types::String, null: false,
        description: 'Version.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/app_config/kas_type.rb =====
# frozen_string_literal: true

module Types
  module AppConfig
    class KasType < ::Types::BaseObject
      graphql_name 'Kas'

      authorize :read_instance_metadata

      field :enabled, GraphQL::Types::Boolean, null: false,
        description: 'Indicates whether the Kubernetes agent server is enabled.'
      field :external_k8s_proxy_url, GraphQL::Types::String, null: true,
        description: 'URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy.'
      # rubocop:disable GraphQL/ExtractType -- we want to keep this way for backwards compatibility
      field :external_url, GraphQL::Types::String, null: true,
        description: 'URL used by the agents to communicate with the server.'
      # rubocop:enable GraphQL/ExtractType
      field :version, GraphQL::Types::String, null: true,
        description: 'KAS version.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/assignee_wildcard_id_enum.rb =====
# frozen_string_literal: true

module Types
  class AssigneeWildcardIdEnum < BaseEnum
    graphql_name 'AssigneeWildcardId'
    description 'Assignee ID wildcard values'

    value 'NONE', 'No assignee is assigned.'
    value 'ANY', 'An assignee is assigned.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/audit_events/audit_event_type.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/AuthorizeTypes -- Authorization is handled in the ComplianceViolationType from which this is called
module Types
  module AuditEvents
    class AuditEventType < ::Types::BaseObject
      graphql_name 'AuditEvent'
      description 'Audit event.'

      field :id, GraphQL::Types::ID,
        null: false, description: 'Audit Event ID.'

      field :created_at, Types::TimeType,
        null: false, description: 'Timestamp when the audit event was created.'

      field :author, Types::UserType,
        null: true, description: 'User who triggered the event.'

      field :event_name, GraphQL::Types::String,
        null: true, description: 'Name of the event.'

      field :details, GraphQL::Types::String,
        null: true, description: 'Additional details of the audit event.'

      field :target_type, GraphQL::Types::String,
        null: true, description: 'Type of the target of the audit event.'

      field :target_details, GraphQL::Types::String,
        null: true, description: 'Additional details of the target.'

      field :target_id, GraphQL::Types::ID, # rubocop:disable GraphQL/ExtractType -- not needed as it is part of audit event only
        null: true, description: 'ID of the target of the audit event.'

      field :ip_address, GraphQL::Types::String,
        null: true, description: 'IP address of the user.'

      field :entity_path, GraphQL::Types::String,
        null: true, description: 'Path of the entity.'

      field :entity_id, GraphQL::Types::ID,
        null: true, description: 'ID of the entity.'

      field :entity_type, GraphQL::Types::String, # rubocop:disable GraphQL/ExtractType -- not needed as it is part of audit event only
        null: true, description: 'Type of the entity.'

      field :project, Types::ProjectType,
        null: true, description: 'Project associated with the audit event.'

      field :group, Types::GroupType,
        null: true, description: 'Group associated with the audit event.'

      field :user, Types::UserType,
        null: true, description: 'User associated with the audit event.'

      def details
        return unless object.details

        object.details.to_json
      end

      def group
        object.group if object.respond_to?(:group)
      end

      def project
        object.project if object.respond_to?(:project)
      end
    end
  end
end
# rubocop: enable Graphql/AuthorizeTypes


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/audit_events/definition_type.rb =====
# frozen_string_literal: true

module Types
  module AuditEvents
    class DefinitionType < ::Types::BaseObject
      graphql_name 'AuditEventDefinition'
      description 'Represents the YAML definitions for audit events defined ' \
        'in `ee/config/audit_events/types/<event-type-name>.yml` ' \
        'and `config/audit_events/types/<event-type-name>.yml`.'

      authorize :audit_event_definitions

      field :name, GraphQL::Types::String,
        null: false,
        description: 'Key name of the audit event.'

      field :description, GraphQL::Types::String,
        null: false,
        description: 'Description of what action the audit event tracks.'

      field :introduced_by_issue, GraphQL::Types::String,
        null: true,
        description: 'Link to the issue introducing the event. For older' \
          'audit events, it can be a commit URL rather than a' \
          'merge request URL.'

      field :introduced_by_mr, GraphQL::Types::String,
        null: true,
        description: 'Link to the merge request introducing the event. For' \
          'older audit events, it can be a commit URL rather than' \
          'a merge request URL.'

      field :feature_category, GraphQL::Types::String,
        null: false,
        description: 'Feature category associated with the event.'

      field :milestone, GraphQL::Types::String,
        null: false,
        description: 'Milestone the event was introduced in.'

      field :saved_to_database, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates if the event is saved to PostgreSQL database.'

      field :streamed, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates if the event is streamed to an external destination.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/availability_enum.rb =====
# frozen_string_literal: true

module Types
  class AvailabilityEnum < BaseEnum
    graphql_name 'AvailabilityEnum'
    description 'User availability status'

    ::UserStatus.availabilities.keys.each do |availability_value|
      value availability_value.upcase, value: availability_value, description: availability_value.titleize
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/award_emojis/award_emoji_type.rb =====
# frozen_string_literal: true

module Types
  module AwardEmojis
    class AwardEmojiType < BaseObject
      graphql_name 'AwardEmoji'
      description 'An emoji awarded by a user'

      authorize :read_emoji

      present_using AwardEmojiPresenter

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Emoji name.'

      field :description,
        GraphQL::Types::String,
        null: false,
        description: 'Emoji description.'

      field :unicode,
        GraphQL::Types::String,
        null: false,
        description: 'Emoji in Unicode.'

      field :emoji,
        GraphQL::Types::String,
        null: false,
        description: 'Emoji as an icon.'

      field :unicode_version,
        GraphQL::Types::String,
        null: false,
        description: 'Unicode version for the emoji.'

      field :user,
        Types::UserType,
        null: false,
        description: 'User who awarded the emoji.'

      def user
        Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.user_id).find
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_argument.rb =====
# frozen_string_literal: true

module Types
  class BaseArgument < GraphQL::Schema::Argument
    include Gitlab::Graphql::Deprecations

    attr_reader :doc_reference

    def initialize(*args, **kwargs, &block)
      @doc_reference = kwargs.delete(:see)

      super(*args, **kwargs, &block)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_edge.rb =====
# frozen_string_literal: true

module Types
  class BaseEdge < GraphQL::Types::Relay::BaseEdge
    field_class Types::BaseField
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_enum.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/GraphqlNamePosition
module Types
  class BaseEnum < GraphQL::Schema::Enum
    class CustomValue < GraphQL::Schema::EnumValue
      include Gitlab::Graphql::Deprecations
    end

    enum_value_class(CustomValue)

    class << self
      # Registers enum definition by the given DeclarativeEnum module
      #
      # @param enum_mod [Module] The enum module to be used
      # @param use_name [Boolean] Does not override the name if set `false`
      # @param use_description [Boolean] Does not override the description if set `false`
      #
      # Example:
      #
      #   class MyEnum < BaseEnum
      #     declarative_enum MyDeclarativeEnum
      #   end
      #
      # Disabling descriptions rubocop for a false positive here
      #
      def declarative_enum(enum_mod, use_name: true, use_description: true)
        graphql_name(enum_mod.name) if use_name
        description(enum_mod.description) if use_description

        enum_mod.definition.each do |key, content|
          value(key.to_s.upcase, value: key.to_s, description: content[:description])
        end
      end

      # Helper to define an enum member for each element of a Rails AR enum
      def from_rails_enum(enum, description:)
        enum.each_key do |name|
          value name.to_s.upcase,
            value: name,
            description: format(description, name: name)
        end
      end

      def value(*args, **kwargs, &block)
        enum[args[0].downcase] = kwargs[:value] || args[0]

        super(*args, **kwargs, &block)
      end

      # Returns an indifferent access hash with the key being the downcased name of the attribute
      # and the value being the Ruby value (either the explicit `value` passed or the same as the value attr).
      def enum
        @enum_values ||= {}.with_indifferent_access
      end

      def authorization
        @authorization ||= ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(authorize)
      end

      def authorize(*abilities)
        @abilities = abilities
      end

      def authorized?(object, context)
        authorization.ok?(object, context[:current_user], scope_validator: context[:scope_validator])
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_field.rb =====
# frozen_string_literal: true

module Types
  class BaseField < GraphQL::Schema::Field
    include Gitlab::Graphql::Deprecations
    include Gitlab::Graphql::Authorize::AuthorizeResource

    argument_class ::Types::BaseArgument

    DEFAULT_COMPLEXITY = 1

    attr_reader :doc_reference
    attr_accessor :skip_type_authorization

    def initialize(**kwargs, &block)
      @requires_argument = kwargs.delete(:requires_argument)
      @calls_gitaly = kwargs.delete(:calls_gitaly)
      @doc_reference = kwargs.delete(:see)

      given_complexity = kwargs[:complexity] || kwargs[:resolver_class].try(:complexity)
      @constant_complexity = given_complexity.is_a?(Integer) && given_complexity > 0
      kwargs[:complexity] = field_complexity(kwargs[:resolver_class], given_complexity)

      @authorize = Array.wrap(kwargs.delete(:authorize))
      @skip_type_authorization = Array.wrap(kwargs.delete(:skip_type_authorization))
      @scopes = Array.wrap(kwargs.delete(:scopes) || %i[api read_api])
      after_connection_extensions = kwargs.delete(:late_extensions) || []

      super(**kwargs, &block)

      # We want to avoid the overhead of this in prod
      extension ::Gitlab::Graphql::CallsGitaly::FieldExtension if Gitlab.dev_or_test_env?
      extension ::Gitlab::Graphql::Present::FieldExtension
      extension ::Gitlab::Graphql::Authorize::FieldExtension

      after_connection_extensions.each { extension _1 } if after_connection_extensions.any?
    end

    def may_call_gitaly?
      @constant_complexity || calls_gitaly?
    end

    def requires_argument?
      value = @requires_argument.nil? ? @resolver_class.try(:requires_argument?) : @requires_argument
      !!value || arguments.values.any? { |argument| argument.type.non_null? }
    end

    # By default fields authorize against the current object, but that is not how our
    # resolvers work - they use declarative permissions to authorize fields
    # manually (so we make them opt in).
    # TODO: https://gitlab.com/gitlab-org/gitlab/-/issues/300922
    #       (separate out authorize into permissions on the object, and on the
    #       resolved values)
    # We do not support argument authorization in our schema. If/when we do,
    # we should call `super` here, to apply argument authorization checks.
    # See: https://gitlab.com/gitlab-org/gitlab/-/issues/324647
    def authorized?(object, args, ctx)
      field_authorized?(object, ctx) && resolver_authorized?(object, ctx)
    end

    # This gets called from the gem's `calculate_complexity` method, allowing us
    # to ensure our complexity calculation is used even for connections.
    # This code is actually a copy of the default case in `calculate_complexity`
    # in `lib/graphql/schema/field.rb`
    # (https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/schema/field.rb)
    def complexity_for(child_complexity:, query:, lookahead:)
      defined_complexity = complexity

      case defined_complexity
      when Proc
        arguments = query.arguments_for(lookahead.ast_nodes.first, self)

        if arguments.respond_to?(:keyword_arguments)
          defined_complexity.call(query.context, arguments.keyword_arguments, child_complexity)
        else
          child_complexity
        end
      when Numeric
        defined_complexity + child_complexity
      else
        raise("Invalid complexity: #{defined_complexity.inspect} on #{path} (#{inspect})")
      end
    end

    def base_complexity
      complexity = DEFAULT_COMPLEXITY
      complexity += 1 if calls_gitaly?
      complexity
    end

    def calls_gitaly?
      !!(@calls_gitaly.nil? ? @resolver_class.try(:calls_gitaly?) : @calls_gitaly)
    end

    def constant_complexity?
      @constant_complexity
    end

    private

    def field_authorized?(object, ctx)
      object = object.node if object.is_a?(GraphQL::Pagination::Connection::Edge)

      return true if authorization.ok?(object, ctx[:current_user], scope_validator: ctx[:scope_validator])

      # Fields on MutationType should populate the 'errors' response when authorization fails
      # for consistency with mutation authorization responses.
      # See https://gitlab.com/gitlab-org/gitlab/-/blob/1abb46e235d96f2fa9098d2fb4190143c7c3adb9/app/graphql/mutations/base_mutation.rb#L61-62
      return false unless owner == Types::MutationType

      raise_resource_not_available_error!
    end

    # Historically our resolvers have used declarative permission checks only
    # for _what they resolved_, not the _object they resolved these things from_
    # We preserve these semantics here, and only apply resolver authorization
    # if the resolver has opted in.
    def resolver_authorized?(object, ctx)
      if @resolver_class && @resolver_class.try(:authorizes_object?)
        @resolver_class.authorized?(object, ctx)
      else
        true
      end
    end

    def authorization
      @authorization ||= ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(@authorize, @scopes)
    end

    def field_complexity(resolver_class, current)
      return current if current.present? && current > 0

      if resolver_class
        field_resolver_complexity
      else
        base_complexity
      end
    end

    def field_resolver_complexity
      # Complexity can be either integer or proc. If proc is used then it's
      # called when computing a query complexity and context and query
      # arguments are available for computing complexity.  For resolvers we use
      # proc because we set complexity depending on arguments and number of
      # items which can be loaded.
      proc do |ctx, args, child_complexity|
        # Resolvers may add extra complexity depending on used arguments
        complexity = child_complexity + resolver&.try(
          :resolver_complexity, args, child_complexity: child_complexity
        ).to_i
        complexity += 1 if calls_gitaly?
        ext_conn = resolver&.try(:calculate_ext_conn_complexity)
        complexity += complexity * connection_complexity_multiplier(ctx, args, calculate_ext_conn_complexity: ext_conn)

        complexity.to_i
      end
    end

    def connection_complexity_multiplier(ctx, args, calculate_ext_conn_complexity:)
      # Resolvers may add extra complexity depending on number of items being loaded.
      return 0 if !connection? && !calculate_ext_conn_complexity

      page_size   = max_page_size || ctx.schema.default_max_page_size
      limit_value = [args[:first], args[:last], page_size].compact.min
      multiplier  = resolver&.try(:complexity_multiplier, args).to_f
      limit_value * multiplier
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_input_object.rb =====
# frozen_string_literal: true

module Types
  class BaseInputObject < GraphQL::Schema::InputObject
    prepend Gitlab::Graphql::CopyFieldDescription

    argument_class ::Types::BaseArgument
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_interface.rb =====
# frozen_string_literal: true

module Types
  module BaseInterface
    include GraphQL::Schema::Interface
    include Gitlab::Graphql::VersionFilter::FutureFieldFallback

    field_class ::Types::BaseField

    definition_methods do
      def authorized?(object, context)
        resolve_type(object, context).authorized?(object, context)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_object.rb =====
# frozen_string_literal: true

module Types
  class BaseObject < GraphQL::Schema::Object
    include Gitlab::Graphql::VersionFilter::FutureFieldFallback

    prepend Gitlab::Graphql::Present
    prepend Gitlab::Graphql::ExposePermissions
    prepend Gitlab::Graphql::MarkdownField

    field_class Types::BaseField
    edge_type_class Types::BaseEdge

    def self.authorize(*args)
      raise 'Cannot redefine authorize' if @authorize_args && args.any?

      @authorize_args = args.freeze if args.any?
      @authorize_args || (superclass.respond_to?(:authorize) ? superclass.authorize : nil)
    end

    def self.accepts(*types)
      @accepts ||= []
      @accepts += types
      @accepts
    end

    # All graphql fields exposing an id, should expose a global id.
    def id
      GitlabSchema.id_from_object(object)
    end

    def self.authorization_scopes
      [:api, :read_api]
    end

    def self.authorization
      @authorization ||= ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(authorize, authorization_scopes)
    end

    def self.authorized?(object, context)
      authorization.ok?(object, context[:current_user],
        scope_validator: context[:scope_validator],
        skip_abilities: context[:skip_type_authorization]
      )
    end

    def current_user
      context[:current_user]
    end

    def self.assignable?(object)
      assignable = accepts

      return true if assignable.blank?

      assignable.any? { |cls| object.is_a?(cls) }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_scalar.rb =====
# frozen_string_literal: true

module Types
  class BaseScalar < GraphQL::Schema::Scalar
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/base_union.rb =====
# frozen_string_literal: true

module Types
  class BaseUnion < GraphQL::Schema::Union
    def self.authorized?(object, context)
      resolve_type(object, context).authorized?(object, context)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/blame/blame_type.rb =====
# frozen_string_literal: true

module Types
  module Blame
    # rubocop: disable Graphql/AuthorizeTypes
    class BlameType < BaseObject
      # This is presented through `Repository` that has its own authorization
      graphql_name 'Blame'

      present_using Gitlab::BlamePresenter

      field :first_line, GraphQL::Types::String, null: true,
        description: 'First line of Git Blame for given range.', calls_gitaly: true
      field :groups, [Types::Blame::GroupsType], null: true,
        description: 'Git Blame grouped by contiguous lines for commit.', calls_gitaly: true,
        method: :groups_commit_data
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/blame/commit_data_type.rb =====
# frozen_string_literal: true

module Types
  module Blame
    # rubocop: disable Graphql/AuthorizeTypes
    class CommitDataType < BaseObject
      # This is presented through `Repository` that has its own authorization
      graphql_name 'CommitData'

      field :age_map_class, GraphQL::Types::String, null: false, description: 'CSS class for age of commit.'
      field :author_avatar, GraphQL::Types::String, null: false, description: 'Link to author avatar.'
      field :commit_author_link, GraphQL::Types::String, null: false, description: 'Link to the commit author.'
      field :commit_link, GraphQL::Types::String, null: false, description: 'Link to the commit.'
      field :project_blame_link, GraphQL::Types::String,
        null: true, description: 'Link to blame prior to the change.'
      field :time_ago_tooltip, GraphQL::Types::String, null: false, description: 'Time of commit.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/blame/groups_type.rb =====
# frozen_string_literal: true

module Types
  module Blame
    # rubocop: disable Graphql/AuthorizeTypes
    class GroupsType < BaseObject
      # This is presented through `Repository` that has its own authorization
      graphql_name 'Groups'

      field :commit, Types::Repositories::CommitType, null: false,
        description: 'Commit responsible for specified group.'
      field :commit_data, Types::Blame::CommitDataType, null: true,
        description: 'HTML data derived from commit needed to present blame.', calls_gitaly: true
      field :lineno, GraphQL::Types::Int, null: false, description: 'Starting line number for the commit group.'
      field :lines, [GraphQL::Types::String], null: false, description: 'Array of lines added for the commit group.'
      field :span, GraphQL::Types::Int, null: false,
        description: 'Number of contiguous lines which the blame spans for the commit group.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/blob_viewers/type_enum.rb =====
# frozen_string_literal: true

module Types
  module BlobViewers
    class TypeEnum < BaseEnum
      graphql_name 'BlobViewersType'
      description 'Types of blob viewers'

      value 'rich', value: :rich, description: 'Rich blob viewers type.'
      value 'simple', value: :simple, description: 'Simple blob viewers type.'
      value 'auxiliary', value: :auxiliary, description: 'Auxiliary blob viewers type.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/blob_viewer_type.rb =====
# frozen_string_literal: true

module Types
  class BlobViewerType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
    graphql_name 'BlobViewer'
    description 'Represents how the blob content should be displayed'

    field :type, Types::BlobViewers::TypeEnum,
      description: 'Type of blob viewer.',
      null: false

    field :load_async, GraphQL::Types::Boolean,
      description: 'Shows whether the blob content is loaded asynchronously.',
      null: false

    field :collapsed, GraphQL::Types::Boolean,
      description: 'Shows whether the blob should be displayed collapsed.',
      method: :collapsed?,
      null: false

    field :too_large, GraphQL::Types::Boolean,
      description: 'Shows whether the blob is too large to be displayed.',
      method: :too_large?,
      null: false

    field :render_error, GraphQL::Types::String,
      description: 'Error rendering the blob content.',
      null: true

    field :file_type, GraphQL::Types::String,
      description: 'Content file type.',
      method: :partial_name,
      null: false

    field :loading_partial_name, GraphQL::Types::String,
      description: 'Loading partial name.',
      null: false

    def collapsed
      !!object&.collapsed?
    end

    def too_large
      !!object&.too_large?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/board_list_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class BoardListType < BaseObject
    graphql_name 'BoardList'
    description 'Represents a list for an issue board'

    include Gitlab::Utils::StrongMemoize

    alias_method :list, :object

    field :id, GraphQL::Types::ID,
      null: false,
      description: 'ID (global ID) of the list.'

    field :collapsed, GraphQL::Types::Boolean, null: true,
      description: 'Indicates if the list is collapsed for the user.'
    field :issues_count, GraphQL::Types::Int, null: true,
      description: 'Count of issues in the list.'
    field :label, Types::LabelType, null: true,
      description: 'Label of the list.'
    field :list_type, GraphQL::Types::String, null: false,
      description: 'Type of the list.'
    field :position, GraphQL::Types::Int, null: true,
      description: 'Position of list within the board.'
    field :title, GraphQL::Types::String, null: false,
      description: 'Title of the list.'

    field :issues,
      ::Types::IssueType.connection_type,
      null: true,
      description: 'Board issues.',
      late_extensions: [Gitlab::Graphql::Board::IssuesConnectionExtension],
      resolver: ::Resolvers::BoardListIssuesResolver

    def issues_count
      metadata[:size]
    end

    def collapsed
      object.collapsed?(context[:current_user])
    end

    def metadata
      strong_memoize(:metadata) do
        params = (context[:issue_filters] || {}).merge(board_id: list.board_id, id: list.id)

        ::Boards::Issues::ListService
          .new(list.board.resource_parent, current_user, params)
          .metadata
      end
    end

    # board lists have a data dependency on label - so we batch load them here
    def title
      BatchLoader::GraphQL.for(object).batch do |lists, callback|
        ActiveRecord::Associations::Preloader.new(records: lists, associations: :label).call

        # all list titles are preloaded at this point
        lists.each { |list| callback.call(list, list.title) }
      end
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end

Types::BoardListType.prepend_mod_with('Types::BoardListType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/boards/board_issuable_input_base_type.rb =====
# frozen_string_literal: true

module Types
  module Boards
    # Common arguments that we can be used to filter boards epics and issues
    class BoardIssuableInputBaseType < BaseInputObject
      argument :label_name, [GraphQL::Types::String, { null: true }],
        required: false,
        description: 'Filter by label name.'

      argument :author_username, GraphQL::Types::String,
        required: false,
        description: 'Filter by author username.'

      argument :my_reaction_emoji, GraphQL::Types::String,
        required: false,
        description: 'Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/boards/board_issue_input_base_type.rb =====
# frozen_string_literal: true

module Types
  module Boards
    # rubocop: disable Graphql/AuthorizeTypes
    class BoardIssueInputBaseType < BoardIssuableInputBaseType
      argument :iids, [GraphQL::Types::String],
        required: false,
        description: 'List of IIDs of issues. For example `["1", "2"]`.'

      argument :milestone_title, GraphQL::Types::String,
        required: false,
        description: 'Filter by milestone title.'

      argument :assignee_username, [GraphQL::Types::String, { null: true }],
        required: false,
        description: 'Filter by assignee username.'

      argument :release_tag, GraphQL::Types::String,
        required: false,
        description: 'Filter by release tag.'

      argument :types, [Types::IssueTypeEnum],
        as: :issue_types,
        description: 'Filter by the given issue types.',
        required: false

      argument :milestone_wildcard_id, ::Types::MilestoneWildcardIdEnum,
        required: false,
        description: 'Filter by milestone ID wildcard.'
    end
  end
end

Types::Boards::BoardIssueInputBaseType.prepend_mod_with('Types::Boards::BoardIssueInputBaseType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/boards/board_issue_input_type.rb =====
# frozen_string_literal: true

module Types
  module Boards
    class BoardIssueInputType < BoardIssueInputBaseType
      graphql_name 'BoardIssueInput'

      argument :not, NegatedBoardIssueInputType,
        required: false,
        description: 'List of negated arguments.'

      argument :or, Types::Issues::UnionedIssueFilterInputType,
        required: false,
        description: 'List of arguments with inclusive OR.'

      argument :search, GraphQL::Types::String,
        required: false,
        description: 'Search query for issue title or description.'

      argument :assignee_wildcard_id, ::Types::AssigneeWildcardIdEnum,
        required: false,
        description: 'Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames.'

      argument :confidential, GraphQL::Types::Boolean,
        required: false,
        description: 'Filter by confidentiality.'
    end
  end
end

Types::Boards::BoardIssueInputType.prepend_mod_with('Types::Boards::BoardIssueInputType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/boards/negated_board_issue_input_type.rb =====
# frozen_string_literal: true

module Types
  module Boards
    class NegatedBoardIssueInputType < BoardIssueInputBaseType
    end
  end
end

Types::Boards::NegatedBoardIssueInputType.prepend_mod_with('Types::Boards::NegatedBoardIssueInputType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/board_type.rb =====
# frozen_string_literal: true

module Types
  class BoardType < BaseObject
    graphql_name 'Board'
    description 'Represents a project or group issue board'
    accepts ::Board
    authorize :read_issue_board

    present_using BoardPresenter

    field :id, type: GraphQL::Types::ID, null: false,
      description: 'ID (global ID) of the board.'
    field :name, type: GraphQL::Types::String, null: true,
      description: 'Name of the board.'

    field :hide_backlog_list, type: GraphQL::Types::Boolean, null: true,
      description: 'Whether or not backlog list is hidden.'

    field :hide_closed_list, type: GraphQL::Types::Boolean, null: true,
      description: 'Whether or not closed list is hidden.'

    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of when the board was created.'

    field :updated_at, Types::TimeType, null: false,
      description: 'Timestamp of when the board was last updated.'

    field :lists,
      Types::BoardListType.connection_type,
      null: true,
      description: 'Lists of the board.',
      resolver: Resolvers::BoardListsResolver,
      extras: [:lookahead]

    field :web_path, GraphQL::Types::String, null: false,
      description: 'Web path of the board.'

    field :web_url, GraphQL::Types::String, null: false,
      description: 'Web URL of the board.'
  end
end

Types::BoardType.prepend_mod_with('Types::BoardType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_protections/base_access_level_input_type.rb =====
# frozen_string_literal: true

module Types
  module BranchProtections
    class BaseAccessLevelInputType < Types::BaseInputObject
      argument :access_level, type: GraphQL::Types::Int,
        required: false,
        description: 'Access level allowed to perform action.'
    end
  end
end

Types::BranchProtections::BaseAccessLevelInputType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_protections/base_access_level_type.rb =====
# frozen_string_literal: true

module Types
  module BranchProtections
    class BaseAccessLevelType < Types::BaseObject
      authorize :read_protected_branch

      field :access_level,
        type: GraphQL::Types::Int,
        null: false,
        description: 'GitLab::Access level.'

      field :access_level_description,
        type: GraphQL::Types::String,
        null: false,
        description: 'Human readable representation for the access level.',
        method: 'humanize'
    end
  end
end

Types::BranchProtections::BaseAccessLevelType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_protections/merge_access_level_input_type.rb =====
# frozen_string_literal: true

module Types
  module BranchProtections
    class MergeAccessLevelInputType < BaseAccessLevelInputType
      graphql_name 'MergeAccessLevelInput'
      description 'Defines which user roles, users, or groups can merge into a protected branch.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_protections/merge_access_level_type.rb =====
# frozen_string_literal: true

module Types
  module BranchProtections
    class MergeAccessLevelType < BaseAccessLevelType # rubocop:disable Graphql/AuthorizeTypes
      graphql_name 'MergeAccessLevel'
      description 'Defines which user roles, users, or groups can merge into a protected branch.'
      accepts ::ProtectedBranch::MergeAccessLevel
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_protections/push_access_level_input_type.rb =====
# frozen_string_literal: true

module Types
  module BranchProtections
    class PushAccessLevelInputType < BaseAccessLevelInputType
      graphql_name 'PushAccessLevelInput'
      description 'Defines which user roles, users, deploy keys, or groups can push to a protected branch.'

      argument :deploy_key_id, Types::GlobalIDType[DeployKey],
        prepare: ->(global_id, _ctx) { global_id.model_id.to_i },
        required: false,
        description: 'Deploy key assigned to the access level.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_protections/push_access_level_type.rb =====
# frozen_string_literal: true

module Types
  module BranchProtections
    class PushAccessLevelType < BaseAccessLevelType # rubocop:disable Graphql/AuthorizeTypes
      graphql_name 'PushAccessLevel'
      description 'Defines which user roles, users, or groups can push to a protected branch.'
      accepts ::ProtectedBranch::PushAccessLevel

      field :deploy_key,
        Types::AccessLevels::DeployKeyType,
        null: true,
        description: 'Deploy key assigned to the access level.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_rules/branch_protection_input_type.rb =====
# frozen_string_literal: true

module Types
  module BranchRules
    class BranchProtectionInputType < Types::BaseInputObject
      argument :merge_access_levels, [Types::BranchProtections::MergeAccessLevelInputType],
        required: false,
        default_value: [],
        replace_null_with_default: true,
        description: 'Details about who can merge into the branch rule target.'

      argument :push_access_levels, [Types::BranchProtections::PushAccessLevelInputType],
        required: false,
        default_value: [],
        replace_null_with_default: true,
        description: 'Details about who can push to the branch rule target.'

      argument :allow_force_push, GraphQL::Types::Boolean,
        required: false,
        default_value: false,
        replace_null_with_default: true,
        description: 'Allows users with write access to the branch rule target to force push changes.'

      def prepare
        to_h
      end
    end
  end
end

Types::BranchRules::BranchProtectionInputType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_rules/branch_protection_type.rb =====
# frozen_string_literal: true

module Types
  module BranchRules
    class BranchProtectionType < BaseObject
      graphql_name 'BranchProtection'
      description 'Branch protection details for a branch rule.'
      accepts ::ProtectedBranch
      authorize :read_protected_branch

      field :merge_access_levels,
        type: Types::BranchProtections::MergeAccessLevelType.connection_type,
        null: true,
        description: 'Details about who can merge when the branch is the source branch.'

      field :push_access_levels,
        type: Types::BranchProtections::PushAccessLevelType.connection_type,
        null: true,
        description: 'Details about who can push when the branch is the source branch.'

      field :allow_force_push,
        type: GraphQL::Types::Boolean,
        null: false,
        description: 'Toggle force push to the branch for users with write access.'
    end
  end
end

Types::BranchRules::BranchProtectionType.prepend_mod_with('Types::BranchRules::BranchProtectionType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/branch_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class BranchType < BaseObject
    graphql_name 'Branch'

    field :name,
      GraphQL::Types::String,
      null: false,
      description: 'Name of the branch.'

    field :commit, Types::Repositories::CommitType,
      null: true, resolver: Resolvers::Repositories::RefCommitResolver,
      description: 'Commit for the branch.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/analytics_aggregation_period_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class AnalyticsAggregationPeriodEnum < BaseEnum
      graphql_name 'AnalyticsAggregationPeriod'

      value 'DAY', description: 'Daily aggregation.', value: :day
      value 'WEEK', description: 'Weekly aggregation.', value: :week
      value 'MONTH', description: 'Monthly aggregation.', value: :month
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/analytics_job_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class AnalyticsJobStatusEnum < BaseEnum
      graphql_name 'PipelineAnalyticsJobStatus'

      value 'ANY', description: 'Jobs with any status.', value: :any
      value 'FAILED', description: 'Job that failed.', value: :failed
      value 'SUCCESS', description: 'Job that succeeded.', value: :success
      value 'OTHER', description: 'Job that was canceled or skipped.', value: :other
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/analytics_period_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- this type is authorized by the resolver
    class AnalyticsPeriodType < BaseObject
      graphql_name 'PipelineAnalyticsPeriod'

      field :label, ::Types::DateType, null: true,
        experiment: { milestone: '17.5' },
        description: 'Data point label (UTC time).'

      field :count, GraphQL::Types::BigInt, null: true,
        experiment: { milestone: '17.5' },
        description: 'Pipeline count, optionally filtered by status.' do
          argument :status,
            type: ::Types::Ci::AnalyticsJobStatusEnum,
            required: true,
            default_value: :any,
            description: 'Filter pipeline totals by status. ' \
              'If not specified, totals for all pipeline statuses are returned.'
        end

      field :duration_statistics, ::Types::Ci::DurationStatisticsType, null: true,
        description: 'Pipeline duration statistics.',
        experiment: { milestone: '17.5' }

      def count(status:)
        object[:count].fetch(status, 0)
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/analytics_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- this type is authorized by the resolver
    class AnalyticsType < BaseObject
      graphql_name 'PipelineAnalytics'

      field :aggregate, Types::Ci::AnalyticsPeriodType, null: true,
        description: 'Pipeline analytics for the specified filter.', experiment: { milestone: '17.5' }

      field :time_series, [Types::Ci::AnalyticsPeriodType], null: true,
        experiment: { milestone: '17.9' },
        description:
          "Pipeline analytics shown over time based on the specified filter. " \
          "Data is aggregated in UTC, with adaptive resolution: hourly for 7-day windows or less, " \
          "daily for longer periods." do
            argument :period, Types::Ci::AnalyticsAggregationPeriodEnum, description: "Periodicity of aggregated data."
          end

      field :month_pipelines_labels, [GraphQL::Types::String], null: true,
        description: 'Labels for the monthly pipeline count. Only available for projects.'
      field :month_pipelines_successful, [GraphQL::Types::Int], null: true,
        description: 'Total monthly successful pipeline count. Only available for projects.'
      field :month_pipelines_totals, [GraphQL::Types::Int], null: true,
        description: 'Total monthly pipeline count. Only available for projects.'
      field :pipeline_times_labels, [GraphQL::Types::String], null: true,
        description: 'Pipeline times labels. Only available for projects.'
      field :pipeline_times_values, [GraphQL::Types::Int], null: true,
        description: 'Pipeline times. Only available for projects.'
      field :week_pipelines_labels, [GraphQL::Types::String], null: true,
        description: 'Labels for the weekly pipeline count. Only available for projects.'
      field :week_pipelines_successful, [GraphQL::Types::Int], null: true,
        description: 'Total weekly successful pipeline count. Only available for projects.'
      field :week_pipelines_totals, [GraphQL::Types::Int], null: true,
        description: 'Total weekly pipeline count. Only available for projects.'
      field :year_pipelines_labels, [GraphQL::Types::String], null: true,
        description: 'Labels for the yearly pipeline count. Only available for projects.'
      field :year_pipelines_successful, [GraphQL::Types::Int], null: true,
        description: 'Total yearly successful pipeline count. Only available for projects.'
      field :year_pipelines_totals, [GraphQL::Types::Int], null: true,
        description: 'Total yearly pipeline count. Only available for projects.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/application_setting_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class ApplicationSettingType < BaseObject
      graphql_name 'CiApplicationSettings'

      authorize :read_application_setting

      field :keep_latest_artifact, GraphQL::Types::Boolean, null: true,
        description: 'Whether to keep the latest jobs artifacts.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/build_need_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    # This type is only accessible from CiJob
    class BuildNeedType < BaseObject
      graphql_name 'CiBuildNeed'

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the BuildNeed.'
      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the job we need to complete.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/catalog/resources/component_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Catalog
      module Resources
        # rubocop: disable Graphql/AuthorizeTypes -- Authorization is handled by VersionType
        class ComponentType < BaseObject
          graphql_name 'CiCatalogResourceComponent'

          field :id, ::Types::GlobalIDType[::Ci::Catalog::Resources::Component], null: false,
            description: 'ID of the component.'

          field :name, GraphQL::Types::String, null: true,
            description: 'Name of the component.'

          field :include_path, GraphQL::Types::String, null: true,
            description: 'Path used to include the component.'

          field :inputs, [Types::Ci::Inputs::SpecType], null: true,
            description: 'Inputs for the component.'

          field :last_30_day_usage_count, GraphQL::Types::Int, null: true,
            description: 'Number of times the component has been used in the last 30 days ' \
              'in a pipeline using `include`.'

          def inputs
            object.spec.fetch('inputs', {}).map do |key, value|
              {
                name: key,
                required?: !value&.key?('default'),
                default: value&.dig('default'),
                description: value&.dig('description'),
                regex: value&.dig('regex'),
                type: value&.dig('type') || 'string'
              }
            end
          end
        end
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/catalog/resource_scope_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Catalog
      class ResourceScopeEnum < BaseEnum
        graphql_name 'CiCatalogResourceScope'
        description 'Values for scoping catalog resources'

        value 'ALL', 'All catalog resources visible to the current user.', value: :all
        value 'NAMESPACES', 'Catalog resources belonging to authorized namespaces of the user.', value: :namespaces
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/catalog/resource_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Catalog
      class ResourceSortEnum < BaseEnum
        graphql_name 'CiCatalogResourceSort'
        description 'Values for sorting catalog resources'

        value 'NAME_ASC', 'Name by ascending order.', value: :name_asc
        value 'NAME_DESC', 'Name by descending order.', value: :name_desc
        value 'LATEST_RELEASED_AT_ASC', 'Latest release date by ascending order.', value: :latest_released_at_asc
        value 'LATEST_RELEASED_AT_DESC', 'Latest release date by descending order.', value: :latest_released_at_desc
        value 'CREATED_ASC', 'Created date by ascending order.', value: :created_at_asc
        value 'CREATED_DESC', 'Created date by descending order.', value: :created_at_desc
        value 'STAR_COUNT_ASC', 'Star count by ascending order.', value: :star_count_asc
        value 'STAR_COUNT_DESC', 'Star count by descending order.', value: :star_count_desc
        value 'USAGE_COUNT_ASC', 'Last 30-day usage count by ascending order.', value: :usage_count_asc
        value 'USAGE_COUNT_DESC', 'Last 30-day usage count by descending order.', value: :usage_count_desc
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/catalog/resources/verification_level_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Catalog
      module Resources
        class VerificationLevelEnum < BaseEnum
          graphql_name 'CiCatalogResourceVerificationLevel'

          ::Ci::Catalog::VerifiedNamespace::VERIFICATION_LEVELS.each do |level, _|
            value level.upcase, value: level.to_s, description: "The resource is #{level.to_s.titleize}"
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/catalog/resources/version_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Catalog
      module Resources
        # rubocop: disable Graphql/AuthorizeTypes -- Authorization is handled by Ci::Catalog::Resources
        class VersionType < BaseObject
          graphql_name 'CiCatalogResourceVersion'

          connection_type_class Types::CountableConnectionType

          field :id, ::Types::GlobalIDType[::Ci::Catalog::Resources::Version], null: false,
            description: 'Global ID of the version.'

          field :created_at, Types::TimeType, null: true, description: 'Timestamp of when the version was created.'

          field :released_at, Types::TimeType, null: true, description: 'Timestamp of when the version was released.',
            experiment: { milestone: '16.7' }

          field :name, GraphQL::Types::String, null: true,
            description: 'Name that uniquely identifies the version within the catalog resource.'

          field :path, GraphQL::Types::String, null: true,
            description: 'Relative web path to the version.'

          field :author, Types::UserType, null: true, description: 'User that created the version.'

          field :commit, Types::Repositories::CommitType, null: true, complexity: 10, calls_gitaly: true,
            description: 'Commit associated with the version.'

          field :components, Types::Ci::Catalog::Resources::ComponentType.connection_type, null: true,
            description: 'Components belonging to the catalog resource.'

          field :readme, GraphQL::Types::String, null: true, calls_gitaly: true,
            description: 'Readme data.' do
              extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
            end

          markdown_field :readme_html, null: true

          def readme_html_resolver
            ctx = context.to_h.dup.merge(project: object.project)
            ::MarkupHelper.markdown(object.readme, ctx, { requested_path: object.project.path })
          end

          def author
            Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.author_id).find
          end
        end
        # rubocop: enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/catalog/resource_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Catalog
      # rubocop: disable Graphql/AuthorizeTypes
      class ResourceType < BaseObject
        graphql_name 'CiCatalogResource'

        connection_type_class Types::CountableConnectionType

        field :id, GraphQL::Types::ID, null: false,
          description: 'ID of the catalog resource.'

        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the catalog resource.'

        field :description, GraphQL::Types::String, null: true,
          description: 'Description of the catalog resource.'

        field :topics, [GraphQL::Types::String], null: true,
          description: 'Topics for the catalog resource.'

        field :icon, GraphQL::Types::String, null: true,
          description: 'Icon for the catalog resource.',
          method: :avatar_path

        field :full_path, GraphQL::Types::ID, null: true,
          description: 'Full project path of the catalog resource.',
          experiment: { milestone: '16.11' }

        field :web_path, GraphQL::Types::String, null: true,
          description: 'Web path of the catalog resource.',
          experiment: { milestone: '16.1' }

        field :versions, Types::Ci::Catalog::Resources::VersionType.connection_type, null: true,
          description: 'Versions of the catalog resource. This field can only be ' \
            'resolved for one catalog resource in any single request.',
          resolver: Resolvers::Ci::Catalog::Resources::VersionsResolver

        field :visibility_level, Types::VisibilityLevelsEnum, null: true,
          description: 'Visibility level of the catalog resource.'

        field :verification_level, Types::Ci::Catalog::Resources::VerificationLevelEnum, null: true,
          description: 'Verification level of the catalog resource.'

        field :latest_released_at, Types::TimeType, null: true,
          description: "Release date of the catalog resource's latest version.",
          experiment: { milestone: '16.5' }

        field :star_count, GraphQL::Types::Int, null: false,
          description: 'Number of times the catalog resource has been starred.'

        field :starrers_path, GraphQL::Types::String, null: true,
          description: 'Relative path to the starrers page for the catalog resource project.'

        field :last_30_day_usage_count, GraphQL::Types::Int, null: false,
          description: 'Number of projects that used a component from this catalog resource in a pipeline, by using ' \
            '`include:component`, in the last 30 days.',
          experiment: { milestone: '17.0' }

        field :archived, GraphQL::Types::Boolean, null: true,
          description: 'Indicates the archived status of the project.'

        def web_path
          ::Gitlab::Routing.url_helpers.project_path(object.project)
        end

        def starrers_path
          Gitlab::Routing.url_helpers.project_starrers_path(object.project)
        end

        # rubocop: disable GraphQL/ResolverMethodLength -- this will be refactored:
        # https://gitlab.com/gitlab-org/gitlab/-/issues/510648
        def topics
          BatchLoader::GraphQL.for(object).batch do |resources, loader|
            # rubocop: disable CodeReuse/ActiveRecord -- this is necessary to batch
            project_ids = resources.pluck(:project_id)
            project_topics = ::Projects::ProjectTopic.where(project_id: project_ids)
            topics = ::Projects::Topic.where(id: project_topics.pluck(:topic_id))
            grouped_project_topics = project_topics.group_by(&:project_id)

            resources.each do |resource|
              project_topics_ids_for_resource = grouped_project_topics.fetch(resource.project_id,
                []).pluck(:topic_id)
              topics_for_resource = topics.select { |topic| project_topics_ids_for_resource.include?(topic.id) }

              loader.call(resource, topics_for_resource.pluck(:name))
              # rubocop: enable CodeReuse/ActiveRecord
            end
          end
        end
        # rubocop: enable GraphQL/ResolverMethodLength
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/ci_cd_setting_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class CiCdSettingType < BaseObject
      graphql_name 'ProjectCiCdSetting'

      authorize :manage_merge_request_settings

      field :display_pipeline_variables,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether pipeline variables can be displayed in the UI.',
        method: :display_pipeline_variables?,
        authorize: :admin_project
      field :group_runners_enabled,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether group runners are enabled for the project.',
        authorize: :admin_project
      field :inbound_job_token_scope_enabled,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether CI/CD job tokens generated in other projects ' \
          'have restricted access to this project.',
        method: :inbound_job_token_scope_enabled?,
        authorize: :admin_project
      field :job_token_scope_enabled,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether CI/CD job tokens generated in this project ' \
          'have restricted access to other projects.',
        method: :job_token_scope_enabled?,
        authorize: :admin_project
      field :keep_latest_artifact,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the latest artifact should be kept for the project.',
        method: :keep_latest_artifacts_available?,
        authorize: :admin_project
      field :merge_pipelines_enabled,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether merged results pipelines are enabled.',
        method: :merge_pipelines_enabled?
      field :pipeline_variables_minimum_override_role,
        GraphQL::Types::String,
        null: false,
        description: 'Minimum role required to set variables when creating a pipeline or running a job.'
      field :project,
        Types::ProjectType,
        null: true,
        description: 'Project the CI/CD settings belong to.',
        authorize: :admin_project
      field :push_repository_for_job_token_allowed,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates the ability to push to the original project ' \
          'repository using a job token',
        method: :push_repository_for_job_token_allowed?,
        authorize: :admin_project
    end
  end
end

Types::Ci::CiCdSettingType.prepend_mod_with('Types::Ci::CiCdSettingType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/code_quality_degradation_severity_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class CodeQualityDegradationSeverityEnum < BaseEnum
      graphql_name 'CodeQualityDegradationSeverity'

      ::Gitlab::Ci::Reports::CodequalityReports::SEVERITY_PRIORITIES.keys.each do |status|
        value status.upcase,
          description: "Code Quality degradation has a status of #{status}.",
          value: status
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/code_quality_report_summary_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `PipelineType` that has its own authorization
    class CodeQualityReportSummaryType < BaseObject
      graphql_name 'CodeQualityReportSummary'
      description 'Code Quality report for a pipeline'

      field :count, GraphQL::Types::Int, null: true,
        description: 'Total number of Code Quality reports.'
      ::Gitlab::Ci::Reports::CodequalityReports::SEVERITY_PRIORITIES.each_key do |status|
        field status, GraphQL::Types::Int, null: true,
          description: "Total number of #{status} status."
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/group_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Config
      # rubocop:disable Graphql/AuthorizeTypes -- Authorization handled in the CiLint mutation
      class GroupType < BaseObject
        graphql_name 'CiConfigGroupV2'

        field :jobs, [Types::Ci::Config::JobType], null: true,
          description: 'Jobs in group.'
        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the job group.'
        field :size, GraphQL::Types::Int, null: true,
          description: 'Size of the job group.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/include_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Config
      class IncludeTypeEnum < BaseEnum
        graphql_name 'CiConfigIncludeType'
        description 'Include type.'

        value 'remote', description: 'Remote include.', value: :remote
        value 'local', description: 'Local include.', value: :local
        value 'file', description: 'Project file include.', value: :file
        value 'template', description: 'Template include.', value: :template
        value 'component', description: 'Component include.', value: :component
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/include_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    module Config
      class IncludeType < BaseObject
        graphql_name 'CiConfigInclude'

        field :type,
          Types::Ci::Config::IncludeTypeEnum,
          null: true,
          description: 'Include type.'

        field :location,
          GraphQL::Types::String,
          null: true,
          description: 'File location. It can be masked if it contains masked variables. For example, ' \
            '`".gitlab/ci/build-images.gitlab-ci.yml"`.'

        field :blob,
          GraphQL::Types::String,
          null: true,
          description: 'File blob location. It can be masked if it contains masked variables. For example, ' \
            '`"https://gitlab.com/gitlab-org/gitlab/-/blob/e52d6d0246d7375291850e61f0abc101fbda9dc2' \
            '/.gitlab/ci/build-images.gitlab-ci.yml"`.'

        field :raw,
          GraphQL::Types::String,
          null: true,
          description: 'File raw location. It can be masked if it contains masked variables. For example, ' \
            '`"https://gitlab.com/gitlab-org/gitlab/-/raw/e52d6d0246d7375291850e61f0abc101fbda9dc2' \
            '/.gitlab/ci/build-images.gitlab-ci.yml"`.'

        field :extra, # rubocop:disable Graphql/JSONType
          GraphQL::Types::JSON,
          null: true,
          description: 'Extra information for the `include`, which can contain `job_name`, `project`, and `ref`. ' \
            'Values can be masked if they contain masked variables.'

        field :context_project,
          GraphQL::Types::String,
          null: true,
          description: 'Current project scope, e.g., "gitlab-org/gitlab".'

        field :context_sha,
          GraphQL::Types::String,
          null: true,
          description: 'Current sha scope.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/job_restriction_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    module Config
      class JobRestrictionType < BaseObject
        graphql_name 'CiConfigJobRestriction'

        field :refs, [GraphQL::Types::String], null: true,
          description: 'Git refs the job restriction applies to.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/job_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Config
      # rubocop:disable Graphql/AuthorizeTypes -- Authorization handled in the CiLint mutation
      class JobType < BaseObject
        graphql_name 'CiConfigJobV2'

        field :after_script,
          [GraphQL::Types::String],
          null: true,
          description: 'Override a set of commands that are executed after the job.'
        field :allow_failure, GraphQL::Types::Boolean, null: true,
          description: 'Allow job to fail.'
        field :before_script,
          [GraphQL::Types::String],
          null: true,
          description: 'Override a set of commands that are executed before the job.'
        field :environment, GraphQL::Types::String, null: true,
          description: 'Name of an environment to which the job deploys.'
        field :except, Types::Ci::Config::JobRestrictionType, null: true,
          description: 'Limit when jobs are not created.'
        field :group_name, GraphQL::Types::String, null: true,
          description: 'Name of the job group.'
        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the job.'
        field :needs,
          [Types::Ci::Config::NeedType],
          null: true,
          description: 'Builds that must complete before the jobs run.'
        field :only,
          Types::Ci::Config::JobRestrictionType,
          null: true,
          description: 'Jobs are created when these conditions do not apply.'
        field :script, [GraphQL::Types::String], null: true,
          description: 'Shell script that is executed by a runner.'
        field :stage, GraphQL::Types::String, null: true,
          description: 'Name of the job stage.'
        field :tags, [GraphQL::Types::String], null: true,
          description: 'List of tags that are used to select a runner.'
        field :when, GraphQL::Types::String, null: true,
          description: 'When to run the job.',
          resolver_method: :restrict_when_to_run_jobs

        def restrict_when_to_run_jobs
          object[:when]
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/need_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    module Config
      class NeedType < BaseObject
        graphql_name 'CiConfigNeed'

        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the need.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/stage_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Config
      # rubocop:disable Graphql/AuthorizeTypes -- Authorization handled in the CiLint mutation
      class StageType < BaseObject
        graphql_name 'CiConfigStageV2'

        field :groups, [Types::Ci::Config::GroupType], null: true,
          description: 'Groups of jobs for the stage.'
        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the stage.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config/status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Config
      class StatusEnum < BaseEnum
        graphql_name 'CiConfigStatus'
        description 'Values for YAML processor result'

        value 'VALID', 'Configuration file is valid.', value: :valid
        value 'INVALID', 'Configuration file is not valid.', value: :invalid
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- Authorization handled by the CiLint mutation
    class ConfigType < BaseObject
      graphql_name 'CiConfigV2'

      field :errors, [GraphQL::Types::String], null: true,
        description: 'Linting errors.'
      field :includes, [Types::Ci::Config::IncludeType], null: true,
        description: 'List of included files.'
      field :merged_yaml, GraphQL::Types::String, null: true,
        description: 'Merged CI configuration YAML.'
      field :stages, [Types::Ci::Config::StageType], null: true,
        description: 'Stages of the pipeline.'
      field :status, Types::Ci::Config::StatusEnum, null: true,
        description: 'Status of linting, can be either valid or invalid.'
      field :warnings, [GraphQL::Types::String], null: true,
        description: 'Linting warnings.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/analyzers_entity_input_type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      class AnalyzersEntityInputType < BaseInputObject
        graphql_name 'SastCiConfigurationAnalyzersEntityInput'
        description 'Represents the analyzers entity in SAST CI configuration'

        argument :name, GraphQL::Types::String, required: true,
          description: 'Name of analyzer.'

        argument :enabled, GraphQL::Types::Boolean, required: true,
          description: 'State of the analyzer.'

        argument :variables, [::Types::CiConfiguration::Sast::EntityInputType],
          description: 'List of variables for the analyzer.',
          required: false
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/analyzers_entity_type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      # rubocop: disable Graphql/AuthorizeTypes
      class AnalyzersEntityType < BaseObject
        graphql_name 'SastCiConfigurationAnalyzersEntity'
        description 'Represents an analyzer entity in SAST CI configuration'

        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the analyzer.'

        field :label, GraphQL::Types::String, null: true,
          description: 'Analyzer label used in the config UI.'

        field :enabled, GraphQL::Types::Boolean, null: true,
          description: 'Indicates whether an analyzer is enabled.'

        field :description, GraphQL::Types::String, null: true,
          description: 'Analyzer description that is displayed on the form.'

        field :variables,
          ::Types::CiConfiguration::Sast::EntityType.connection_type,
          null: true,
          description: 'List of supported variables.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/entity_input_type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      class EntityInputType < BaseInputObject
        graphql_name 'SastCiConfigurationEntityInput'
        description 'Represents an entity in SAST CI configuration'

        argument :field, GraphQL::Types::String, required: true,
          description: 'CI keyword of entity.'

        argument :default_value, GraphQL::Types::String, required: true,
          description: 'Default value that is used if value is empty.'

        argument :value, GraphQL::Types::String, required: true,
          description: 'Current value of the entity.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/entity_type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      # rubocop: disable Graphql/AuthorizeTypes
      class EntityType < BaseObject
        graphql_name 'SastCiConfigurationEntity'
        description 'Represents an entity in SAST CI configuration'

        field :field, GraphQL::Types::String, null: true,
          description: 'CI keyword of entity.'

        field :label, GraphQL::Types::String, null: true,
          description: 'Label for entity used in the form.'

        field :type, GraphQL::Types::String, null: true,
          description: 'Type of the field value.'

        field :options,
          ::Types::CiConfiguration::Sast::OptionsEntityType.connection_type,
          null: true,
          description: 'Different possible values of the field.'

        field :default_value, GraphQL::Types::String, null: true,
          description: 'Default value that is used if value is empty.'

        field :description, GraphQL::Types::String, null: true,
          description: 'Entity description that is displayed on the form.'

        field :value, GraphQL::Types::String, null: true,
          description: 'Current value of the entity.'

        field :size, ::Types::CiConfiguration::Sast::UiComponentSizeEnum, null: true,
          description: 'Size of the UI component.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/input_type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      class InputType < BaseInputObject
        graphql_name 'SastCiConfigurationInput'
        description 'Represents a CI configuration of SAST'

        argument :global, [::Types::CiConfiguration::Sast::EntityInputType],
          description: 'List of global entities related to SAST configuration.',
          required: false

        argument :pipeline, [::Types::CiConfiguration::Sast::EntityInputType],
          description: 'List of pipeline entities related to SAST configuration.',
          required: false

        argument :analyzers, [::Types::CiConfiguration::Sast::AnalyzersEntityInputType],
          description: 'List of analyzers and related variables for the SAST configuration.',
          required: false
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/options_entity_type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      # rubocop: disable Graphql/AuthorizeTypes
      class OptionsEntityType < BaseObject
        graphql_name 'SastCiConfigurationOptionsEntity'
        description 'Represents an entity for options in SAST CI configuration'

        field :label, GraphQL::Types::String, null: true,
          description: 'Label of option entity.'

        field :value, GraphQL::Types::String, null: true,
          description: 'Value of option entity.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/type.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      # rubocop: disable Graphql/AuthorizeTypes
      class Type < BaseObject
        graphql_name 'SastCiConfiguration'
        description 'Represents a CI configuration of SAST'

        field :global,
          ::Types::CiConfiguration::Sast::EntityType.connection_type,
          null: true,
          description: 'List of global entities related to SAST configuration.'

        field :pipeline,
          ::Types::CiConfiguration::Sast::EntityType.connection_type,
          null: true,
          description: 'List of pipeline entities related to SAST configuration.'

        field :analyzers,
          ::Types::CiConfiguration::Sast::AnalyzersEntityType.connection_type,
          null: true,
          description: 'List of analyzers entities attached to SAST configuration.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci_configuration/sast/ui_component_size_enum.rb =====
# frozen_string_literal: true

module Types
  module CiConfiguration
    module Sast
      class UiComponentSizeEnum < BaseEnum
        graphql_name 'SastUiComponentSize'
        description 'Size of UI component in SAST configuration page'

        value 'SMALL', description: "Size of UI component in SAST configuration page is small."
        value 'MEDIUM', description: "Size of UI component in SAST configuration page is medium."
        value 'LARGE', description: "Size of UI component in SAST configuration page is large."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/config_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class ConfigVariableType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
      graphql_name 'CiConfigVariable'
      description 'CI/CD config variables.'

      field :key, GraphQL::Types::String,
        null: true,
        description: 'Name of the variable.'

      field :description, GraphQL::Types::String,
        null: true,
        description: 'Description for the CI/CD config variable.'

      field :value, GraphQL::Types::String,
        null: true,
        description: 'Value of the variable.'

      field :value_options, [GraphQL::Types::String],
        hash_key: :options,
        null: true,
        description: 'Value options for the variable.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/detailed_status_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `PipelineType` that has its own authorization
    class DetailedStatusType < BaseObject
      graphql_name 'DetailedStatus'

      field :action,
        Types::Ci::StatusActionType,
        null: true,
        calls_gitaly: true,
        description: 'Action information for the status. This includes method, button title, icon, path, and title.'
      field :deployment_details_path, GraphQL::Types::String, null: true,
        description: 'Path of the deployment details for the status.'
      field :details_path, GraphQL::Types::String, null: true,
        description: 'Path of the details for the status.'
      field :favicon, GraphQL::Types::String, null: true,
        description: 'Favicon of the status.'
      field :group, GraphQL::Types::String, null: true,
        description: 'Group of the status.',
        deprecated: {
          reason: 'The `group` attribute is deprecated. Use `name` instead',
          milestone: '16.4'
        }
      field :has_details, GraphQL::Types::Boolean, null: true,
        description: 'Indicates if the status has further details.',
        method: :has_details?
      field :icon, GraphQL::Types::String, null: true,
        description: 'Icon of the status.',
        deprecated: {
          reason: 'The `icon` attribute is deprecated. Use `name` to ' \
            'identify the status to display instead',
          milestone: '16.4'
        }
      field :id, GraphQL::Types::String, null: false,
        description: 'ID for a detailed status.',
        extras: [:parent]
      field :label, GraphQL::Types::String, null: true,
        description: 'Human-readable label of the status (e.g. success).',
        calls_gitaly: true
      field :name, GraphQL::Types::String, null: true,
        description: 'Machine-readable status name (e.g. SUCCESS).'
      field :text, GraphQL::Types::String, null: true,
        description: 'Text of the status.',
        deprecated: {
          reason: 'The `text` attribute is being deprecated. Use `label` instead',
          milestone: '16.4'
        }
      field :tooltip, GraphQL::Types::String, null: true,
        description: 'Tooltip associated with the status.',
        method: :status_tooltip

      def id(parent:)
        "#{object.id}-#{parent.id}"
      end

      def action
        return unless object.has_action?

        {
          button_title: object.action_button_title,
          icon: object.action_icon,
          method: object.action_method,
          path: object.action_path,
          title: object.action_title,
          confirmation_message: object.confirmation_message
        }
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/duration_statistics_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- this represents a hash, from the computed percentiles query
    class DurationStatisticsType < BaseObject
      graphql_name 'CiDurationStatistics'
      description 'Histogram of durations for a group of CI/CD jobs or pipelines.'

      PERCENTILES = ::Ci::CollectPipelineAnalyticsServiceBase::ALLOWED_PERCENTILES

      PERCENTILES.each do |p|
        field "p#{p}", Types::DurationType,
          null: true, description: "#{p}th percentile. #{p}% of the durations are lower than this value.",
          experiment: { milestone: '15.8' }

        define_method(:"p#{p}") do
          object[:"p#{p}"]
        end
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/freeze_period_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class FreezePeriodStatusEnum < BaseEnum
      graphql_name 'CiFreezePeriodStatus'
      description 'Deploy freeze period status'

      value 'ACTIVE', value: :active, description: 'Freeze period is active.'
      value 'INACTIVE', value: :inactive, description: 'Freeze period is inactive.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/freeze_period_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class FreezePeriodType < BaseObject
      graphql_name 'CiFreezePeriod'
      description 'Represents a deployment freeze window of a project'

      authorize :read_freeze_period

      present_using ::Ci::FreezePeriodPresenter

      field :status, Types::Ci::FreezePeriodStatusEnum,
        description: 'Freeze period status.',
        null: false

      field :start_cron, GraphQL::Types::String,
        description: 'Start of the freeze period in cron format.',
        null: false,
        method: :freeze_start

      field :end_cron, GraphQL::Types::String,
        description: 'End of the freeze period in cron format.',
        null: false,
        method: :freeze_end

      field :cron_timezone, GraphQL::Types::String,
        description: 'Time zone for the cron fields, defaults to UTC if not provided.',
        null: true

      field :start_time, Types::TimeType,
        description: 'Timestamp (UTC) of when the current/next active period starts.',
        null: true

      field :end_time, Types::TimeType,
        description: 'Timestamp (UTC) of when the current/next active period ends.',
        null: true,
        method: :time_end_from_now
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/group_environment_scope_connection_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class GroupEnvironmentScopeConnectionType < GraphQL::Types::Relay::BaseConnection
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/group_environment_scope_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class GroupEnvironmentScopeType < BaseObject
      graphql_name 'CiGroupEnvironmentScope'
      description 'CI/CD environment scope for a group.'

      connection_type_class Types::Ci::GroupEnvironmentScopeConnectionType

      field :name, GraphQL::Types::String,
        null: true,
        description: 'Scope name defininig the enviromnments that can use the variable.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/group_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class GroupType < BaseObject
      graphql_name 'CiGroup'

      field :detailed_status, Types::Ci::DetailedStatusType, null: true,
        description: 'Detailed status of the group.'
      field :id, GraphQL::Types::String, null: false,
        description: 'ID for a group.'
      field :jobs, Ci::JobType.connection_type, null: true,
        description: 'Jobs in group.'
      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the job group.'
      field :size, GraphQL::Types::Int, null: true,
        description: 'Size of the group.'

      def detailed_status
        object.detailed_status(context[:current_user])
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/group_variable_connection_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class GroupVariableConnectionType < GraphQL::Types::Relay::BaseConnection
      field :limit, GraphQL::Types::Int,
        null: false,
        description: 'Maximum amount of group CI/CD variables.'

      def limit
        ::Plan.default.actual_limits.group_ci_variables
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/group_variables_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # Not inheriting from Types::SortEnum since we only want
    # to implement a subset of the sort values it defines.
    class GroupVariablesSortEnum < BaseEnum
      graphql_name 'CiGroupVariablesSort'
      description 'Values for sorting inherited variables'

      # Borrowed from Types::SortEnum
      # These values/descriptions should stay in-sync as much as possible.
      value 'CREATED_DESC', 'Created at descending order.', value: :created_desc
      value 'CREATED_ASC', 'Created at ascending order.', value: :created_asc

      value 'KEY_DESC', 'Key by descending order.', value: :key_desc
      value 'KEY_ASC', 'Key by ascending order.', value: :key_asc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/group_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class GroupVariableType < ProjectVariableType
      graphql_name 'CiGroupVariable'
      description 'CI/CD variables for a group.'

      connection_type_class Types::Ci::GroupVariableConnectionType
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/inherited_ci_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class InheritedCiVariableType < BaseObject
      graphql_name 'InheritedCiVariable'
      description 'CI/CD variables a project inherits from its parent group and ancestors.'

      include Gitlab::Utils::StrongMemoize

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the variable.'

      field :key, GraphQL::Types::String,
        null: true,
        description: 'Name of the variable.'

      field :description, GraphQL::Types::String,
        null: true,
        description: 'Description of the variable.'

      field :raw, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is raw.'

      field :variable_type, ::Types::Ci::VariableTypeEnum,
        null: true,
        description: 'Type of the variable.'

      field :environment_scope, GraphQL::Types::String,
        null: true,
        description: 'Scope defining the environments that can use the variable.'

      field :protected, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is protected.'

      field :masked, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is masked.'

      field :hidden, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is hidden.'

      field :group_name, GraphQL::Types::String,
        null: true,
        description: 'Indicates group the variable belongs to.'

      field :group_ci_cd_settings_path, GraphQL::Types::String,
        null: true,
        description: 'Indicates the path to the CI/CD settings of the group the variable belongs to.'

      def group_ci_cd_settings_path
        return unless current_user && Ability.allowed?(current_user, :admin_cicd_variables, object.group)

        object.group_ci_cd_settings_path
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/inputs/field_type.rb =====
# frozen_string_literal: true

# This class represents a CI input value that has been persisted and can be passed to pipelines created in its project.
# For example, users can configure CI input values when creating pipeline schedules.
# Those values are then passed to pipelines created by the schedule.

module Types
  module Ci
    module Inputs
      # rubocop:disable Graphql:AuthorizeTypes -- Authorization will always be handled by the fields that use this type
      class FieldType < BaseObject
        graphql_name 'CiInputsField'
        description 'CI input saved for a pipeline schedule'

        field :name,
          GraphQL::Types::String,
          null: false,
          description: 'Name of the input.'

        field :value,
          Inputs::ValueType,
          null: true,
          description: 'Value of the input.'
      end
      # rubocop:enable Graphql:AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/inputs/input_type.rb =====
# frozen_string_literal: true

# This class represents a GraphQL `Input` object that allows users to set CI inputs values when running a pipeline or
# configuring a pipeline schedule. The `Inputs` namespace refers to CI inputs, and the `InputType` class name refers to
# a GraphQL `Input` object.

module Types
  module Ci
    module Inputs
      class InputType < BaseInputObject
        graphql_name 'CiInputsInput'
        description 'Attributes for defining an input.'

        argument :name,
          GraphQL::Types::String,
          required: true,
          description: 'Name of the input.'

        argument :value,
          Inputs::ValueType,
          required: true,
          description: 'Value of the input.'

        argument :destroy,
          GraphQL::Types::Boolean,
          required: false,
          description: 'Set to `true` to delete the input.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/inputs/spec_type.rb =====
# frozen_string_literal: true

# This class represents a single CI inputs definition from a CI Header `spec:inputs` section. It is used to display
# inputs definitions on a CI component's details page in the CI Catalog, and to populate the CI inputs form on the new
# pipeline page.

module Types
  module Ci
    module Inputs
      class SpecType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Authorization checked upstream
        graphql_name 'CiInputsSpec'

        description 'Input for pipeline creation'

        field :name, GraphQL::Types::String,
          null: false,
          description: 'Name of the input.'

        field :type, Types::Ci::Inputs::TypeEnum,
          null: false,
          description: 'Input data type.'

        field :description, GraphQL::Types::String,
          null: true,
          description: 'Description of the input.'

        field :required, GraphQL::Types::Boolean,
          null: false,
          description: 'Indicates whether the input is required.',
          method: :required?

        field :default, Types::Ci::Inputs::ValueType,
          null: true,
          description: 'Default value for the input, if provided.'

        field :options, Types::Ci::Inputs::ValueType,
          null: true,
          description: 'Possible values that the input can take, if provided.'

        field :regex, GraphQL::Types::String,
          null: true,
          description: 'Regular expression pattern that the input value must match if provided.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/inputs/type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module Inputs
      class TypeEnum < BaseEnum
        graphql_name 'CiInputsType'
        description 'Available input types'

        ::Ci::PipelineCreation::Inputs::SpecInputs.input_types.each do |input_type|
          value input_type.upcase, description: "#{input_type.capitalize} input", value: input_type
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/inputs/value_type.rb =====
# frozen_string_literal: true

# This class represents the value of a CI input. It is used to provide default values to UI forms that users can
# use to populate inputs for a pipeline, and to configure inputs values for pipeline schedules.

module Types
  module Ci
    module Inputs
      class ValueType < BaseScalar
        graphql_name 'CiInputsValue'
        description 'Value for a CI input. Can be a string, array, number, or boolean.'

        def self.coerce_input(value, _ctx)
          case value
          when String, Array, Numeric, TrueClass, FalseClass, NilClass
            value
          else
            raise GraphQL::CoercionError, 'Invalid CI input value'
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/instance_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class InstanceVariableType < BaseObject
      graphql_name 'CiInstanceVariable'
      description 'CI/CD variables for a GitLab instance.'

      implements VariableInterface

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the variable.'

      field :description, GraphQL::Types::String,
        null: true,
        description: 'Description of the variable.'

      field :environment_scope, GraphQL::Types::String,
        null: true,
        deprecated: {
          reason: 'No longer used, only available for GroupVariableType and ProjectVariableType',
          milestone: '15.3'
        },
        description: 'Scope defining the environments that can use the variable.'

      field :protected, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is protected.'

      field :masked, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is masked.'

      field :raw, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is raw.'

      def environment_scope
        nil
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_artifact_file_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class JobArtifactFileTypeEnum < BaseEnum
      graphql_name 'JobArtifactFileType'

      ::Enums::Ci::JobArtifact.type_and_format_pairs.keys.each do |file_type|
        description = file_type == :codequality ? "CODE QUALITY" : file_type.to_s.titleize.upcase # This is needed as doc lint will not allow codequality as one word
        value file_type.to_s.upcase, value: file_type.to_s, description: "#{description} job artifact file type."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_artifact_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class JobArtifactType < BaseObject
      graphql_name 'CiJobArtifact'

      field :id, Types::GlobalIDType[::Ci::JobArtifact], null: false,
        description: 'ID of the artifact.'

      field :download_path, GraphQL::Types::String, null: true,
        description: "URL for downloading the artifact's file."

      field :file_type, ::Types::Ci::JobArtifactFileTypeEnum, null: true,
        description: 'File type of the artifact.'

      field :name, GraphQL::Types::String, null: true,
        description: 'File name of the artifact.',
        method: :filename

      field :size, GraphQL::Types::BigInt, null: false,
        description: 'Size of the artifact in bytes.'

      field :expire_at, Types::TimeType, null: true,
        description: 'Expiry date of the artifact.'

      field :expired, GraphQL::Types::Boolean, null: false,
        description: 'Expired state of the artifact.',
        method: :expired?

      def download_path
        ::Gitlab::Routing.url_helpers.download_project_job_artifacts_path(
          object.project,
          object.job,
          file_type: object.file_type
        )
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_base_field.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # JobBaseField ensures that only allow-listed fields can be returned without a permission check.
    # All other fields go through a permissions check based on the :job_field_authorization value passed in the context.
    # rubocop: disable Graphql/AuthorizeTypes
    class JobBaseField < ::Types::BaseField
      PUBLIC_FIELDS = %i[allow_failure duration id kind status created_at finished_at queued_at queued_duration
        updated_at runner].freeze

      attr_accessor :if_unauthorized

      def initialize(**kwargs, &block)
        @if_unauthorized = kwargs.delete(:if_unauthorized)

        super
      end

      def authorized?(object, args, ctx)
        current_user = ctx[:current_user]
        permission = ctx[:job_field_authorization]

        if permission.nil? ||
            PUBLIC_FIELDS.include?(ctx[:current_field].original_name) ||
            current_user.can?(permission, object)
          return super
        end

        false
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_failure_reason_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class JobFailureReasonEnum < BaseEnum
      graphql_name 'CiJobFailureReason'

      ::Enums::Ci::CommitStatus.failure_reasons.each_key do |reason|
        value reason.to_s.upcase,
          description: "A job that failed due to #{reason.to_s.tr('_', ' ')}.",
          value: reason
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_interface_base_field.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable GraphQL/GraphqlName -- Not a type
    # rubocop: disable Graphql/AuthorizeTypes -- Not a type
    class JobInterfaceBaseField < ::Types::BaseField
      def initialize(**kwargs, &block)
        kwargs[:authorize] = :read_build

        super
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
    # rubocop: enable GraphQL/GraphqlName
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_interface.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # This inteface sets [authorize: :read_build] (field-level authorization via
    # JobInterfaceBaseField) for all defined fields to ensure implementing types
    # don't expose inherited fields without proper authorization.
    #
    # Implementing types can opt-out from this field-level auth and use
    # type-level auth by re-defining the field without the authorize argument.
    # For example, JobMinimalAccessType uses :read_build_metadata type-level
    # auth to expose a set of defined fields and leaves inherited fields it does
    # not want to expose to use field-level auth using :read_build.
    module JobInterface
      include BaseInterface

      graphql_name 'CiJobInterface'

      field_class ::Types::Ci::JobInterfaceBaseField

      connection_type_class Types::LimitedCountableConnectionType

      field :active, GraphQL::Types::Boolean, null: true, method: :active?,
        description: 'Indicates the job is active.'
      field :allow_failure, ::GraphQL::Types::Boolean, null: true,
        description: 'Whether the job is allowed to fail.'
      field :artifacts, Types::Ci::JobArtifactType.connection_type, null: true,
        description: 'Artifacts generated by the job.'
      field :browse_artifacts_path, GraphQL::Types::String, null: true,
        description: "URL for browsing the artifact's archive."
      field :cancelable, GraphQL::Types::Boolean, null: true, method: :cancelable?,
        description: 'Indicates the job can be canceled.'
      field :can_play_job, GraphQL::Types::Boolean,
        null: true, resolver_method: :can_play_job?,
        description: 'Indicates whether the current user can play the job.',
        calls_gitaly: true
      field :commit_path, GraphQL::Types::String, null: true,
        description: 'Path to the commit that triggered the job.'
      field :created_at, Types::TimeType, null: true,
        description: "When the job was created."
      field :coverage, GraphQL::Types::Float, null: true,
        description: 'Coverage level of the job.'
      field :created_by_tag, GraphQL::Types::Boolean, null: true,
        description: 'Whether the job was created by a tag.', method: :tag?
      field :detailed_status, Types::Ci::DetailedStatusType, null: true,
        description: 'Detailed status of the job.'
      field :duration, GraphQL::Types::Int, null: true,
        description: 'Duration of the job in seconds.'
      field :erased_at, Types::TimeType, null: true,
        description: "When the job was erased."
      # rubocop:disable Layout/LineLength -- otherwise description is creating unnecessary newlines.
      field :exit_code, GraphQL::Types::Int, null: true,
        description: 'Exit code of the job. Available for jobs that started after upgrading to GitLab 16.10 and failed with an exit code.'
      # rubocop:enable Layout/LineLength
      field :failure_message, GraphQL::Types::String, null: true,
        description: 'Message on why the job failed.'
      field :finished_at, Types::TimeType, null: true,
        description: 'When a job has finished running.'
      field :id, ::Types::GlobalIDType[::CommitStatus].as('JobID'), null: true,
        description: 'ID of the job.'
      field :kind, type: ::Types::Ci::JobKindEnum, null: true,
        description: 'Indicates the type of job.'
      field :manual_job, GraphQL::Types::Boolean, null: true,
        description: 'Whether the job has a manual action.'
      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the job.'
      field :pipeline, Types::Ci::PipelineInterface, null: true,
        description: 'Pipeline the job belongs to.'
      field :playable, GraphQL::Types::Boolean, null: true, method: :playable?,
        description: 'Indicates the job can be played.'
      field :play_path, GraphQL::Types::String, null: true,
        description: 'Play path of the job.'
      field :project, Types::Projects::ProjectInterface, null: true, description: 'Project that the job belongs to.'
      field :queued_at, Types::TimeType, null: true,
        description: 'When the job was enqueued and marked as pending.'
      field :queued_duration,
        type: Types::DurationType,
        null: true,
        description: 'How long the job was enqueued before starting.'
      field :ref_name, GraphQL::Types::String, null: true,
        description: 'Ref name of the job.'
      field :ref_path, GraphQL::Types::String, null: true,
        description: 'Path to the ref.'
      field :retried, GraphQL::Types::Boolean, null: true,
        description: 'Indicates that the job has been retried.'
      field :retryable, GraphQL::Types::Boolean, null: true,
        description: 'Indicates the job can be retried.'
      field :retry_path, GraphQL::Types::String, null: true,
        description: 'Retry path of the job.'
      field :runner, Types::Ci::RunnerType, null: true, description: 'Runner assigned to execute the job.'
      field :scheduled, GraphQL::Types::Boolean, null: true, method: :scheduled?,
        description: 'Indicates the job is scheduled.'
      field :scheduled_at, Types::TimeType, null: true,
        description: 'Schedule for the build.'
      # rubocop:disable Layout/LineLength -- otherwise description is creating unnecessary newlines.
      field :scheduling_type, GraphQL::Types::String, null: true,
        description: 'Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise.'
      # rubocop:enable Layout/LineLength
      field :short_sha, type: GraphQL::Types::String, null: true,
        description: 'Short SHA1 ID of the commit.'
      field :source, GraphQL::Types::String, null: true,
        description: 'Policy or action that initiated the job. If not set, the value is inherited from the pipeline.'
      field :stage, Types::Ci::StageType, null: true,
        description: 'Stage of the job.'
      field :started_at, Types::TimeType, null: true,
        description: 'When the job was started.'
      field :status,
        type: ::Types::Ci::JobStatusEnum,
        null: true,
        description: "Status of the job."
      field :stuck, GraphQL::Types::Boolean, null: true, method: :stuck?,
        description: 'Indicates the job is stuck.'
      field :tags, [GraphQL::Types::String], null: true,
        description: 'Tags for the current job.'
      field :trace, Types::Ci::JobTraceType, null: true,
        description: 'Trace generated by the job.'
      field :triggered, GraphQL::Types::Boolean, null: true,
        description: 'Whether the job was triggered.'
      field :user_permissions, Types::PermissionTypes::Ci::Job,
        description: 'Permissions for the current user on the job.',
        null: true,
        method: :itself
      field :web_path, GraphQL::Types::String, null: true,
        description: 'Web path of the job.'

      def detailed_status
        object.detailed_status(context[:current_user])
      end

      def manual_job
        object.try(:action?)
      end

      def ref_name
        object&.ref
      end

      def triggered
        object.pipeline.trigger_id.present?
      end

      def self.resolve_type(_object, _context)
        ::Types::Ci::JobType
      end
    end
  end
end

Types::Ci::JobInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_kind_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class JobKindEnum < BaseEnum
      graphql_name 'CiJobKind'

      value 'BUILD', value: ::Ci::Build, description: 'Standard CI job.'
      value 'BRIDGE', value: ::Ci::Bridge, description: 'Bridge CI job connecting a parent and child pipeline.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_need_union.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class JobNeedUnion < GraphQL::Schema::Union
      TypeNotSupportedError = Class.new(StandardError)

      possible_types Types::Ci::JobType, Types::Ci::BuildNeedType

      def self.resolve_type(object, context)
        case object
        when ::Ci::BuildNeed
          Types::Ci::BuildNeedType
        when CommitStatus
          Types::Ci::JobType
        else
          raise TypeNotSupportedError
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_source_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class JobSourceEnum < BaseEnum
      graphql_name 'CiJobSource'

      ::Ci::BuildSource.sources.keys.map(&:to_s).each do |source|
        value source.upcase,
          description: "A job initiated by #{source.tr('_', ' ')}.",
          value: source
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class JobStatusEnum < BaseEnum
      graphql_name 'CiJobStatus'

      ::Ci::HasStatus::AVAILABLE_STATUSES.each do |status|
        value status.upcase,
          description: "A job that is #{status.tr('_', ' ')}.",
          value: status
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_accessible_group_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes -- this type does not need authorization
  module Ci
    class JobTokenAccessibleGroupType < BaseObject
      graphql_name 'CiJobTokenAccessibleGroup'

      description 'Group that can access the current project by authenticating with a CI/CD job token.'

      field :avatar_url,
        type: GraphQL::Types::String,
        null: true,
        description: 'Avatar URL of the group.'

      field :full_path, GraphQL::Types::ID, null: false,
        description: 'Full path of the group.'

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the group.'

      field :name, GraphQL::Types::String, null: false,
        description: 'Name of the group.'

      field :path, GraphQL::Types::String, null: false,
        description: 'Path of the group.'

      field :web_url, GraphQL::Types::String, null: true,
        description: 'Web URL of the group.'

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_accessible_project_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes -- this type does not need authorization
  module Ci
    class JobTokenAccessibleProjectType < BaseObject
      graphql_name 'CiJobTokenAccessibleProject'
      description 'Project that can access the current project by authenticating with a CI/CD job token.'

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the project.'

      field :name, GraphQL::Types::String,
        null: false,
        description: 'Name of the project (without namespace).'

      field :path, GraphQL::Types::String,
        null: false,
        description: 'Path of the project.'

      field :full_path, GraphQL::Types::ID,
        null: false,
        description: 'Full path of the project.'

      field :web_url, GraphQL::Types::String,
        null: true,
        description: 'Web URL of the project.'

      field :avatar_url, GraphQL::Types::String,
        null: true,
        calls_gitaly: true,
        description: 'URL to avatar image file of the project.'

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_auth_log_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes -- this type is authorized by the resolver
  module Ci
    class JobTokenAuthLogType < BaseObject
      graphql_name 'CiJobTokenAuthLog'
      connection_type_class Types::CountableConnectionType

      field :origin_project, Types::Ci::JobTokenAccessibleProjectType,
        null: false,
        experiment: { milestone: '17.6' },
        description: 'Origin project.'

      field :last_authorized_at, Types::TimeType,
        null: false,
        experiment: { milestone: '17.6' },
        description: 'Last authorization date time.'
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_scope/allowlist_entry_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module JobTokenScope
      # rubocop: disable Graphql/AuthorizeTypes -- Authorization is handled by parent class
      class AllowlistEntryType < BaseObject
        graphql_name 'CiJobTokenScopeAllowlistEntry'
        description 'Represents an allowlist entry for the CI_JOB_TOKEN'

        connection_type_class Types::CountableConnectionType

        field :source_project,
          Types::ProjectType,
          null: false,
          description: "Project that owns the allowlist entry."

        field :target,
          Ci::JobTokenScope::TargetType,
          null: true,
          description: 'Group or project allowed by the entry.'

        field :direction,
          GraphQL::Types::String,
          null: true,
          description: 'Direction of access. Defaults to INBOUND.',
          deprecated: { reason: 'Outbound job token scope is being removed. This field can only be INBOUND',
                        milestone: '18.0' }

        field :default_permissions,
          GraphQL::Types::Boolean,
          description: 'Indicates whether default permissions are enabled (true) or fine-grained permissions are ' \
            'enabled (false).'

        field :job_token_policies,
          [Types::Ci::JobTokenScope::PoliciesEnum],
          null: true,
          description: 'List of policies for the entry.',
          experiment: { milestone: '17.5' }

        field :added_by,
          Types::UserType,
          null: true,
          description: 'User that added the entry.'

        field :created_at,
          Types::TimeType,
          null: false,
          description: 'When the entry was created.'

        field :autopopulated,
          GraphQL::Types::Boolean,
          null: true,
          description: 'Indicates whether the entry is created by the autopopulation process.'

        def source_project
          Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.source_project_id).find
        end

        def target
          case object
          when ::Ci::JobToken::ProjectScopeLink
            Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.target_project_id).find
          when ::Ci::JobToken::GroupScopeLink
            Gitlab::Graphql::Loaders::BatchModelLoader.new(Group, object.target_group_id).find
          end
        end

        def direction
          case object
          when ::Ci::JobToken::ProjectScopeLink
            object.direction
          when ::Ci::JobToken::GroupScopeLink
            'inbound'
          end
        end

        def job_token_policies
          object.job_token_policies - ::Ci::JobToken::Policies::DEPRECATED_POLICIES.map(&:to_s)
        end
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_scope/allowlist_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module JobTokenScope
      # rubocop: disable Graphql/AuthorizeTypes -- Authorization is handled by parent class
      class AllowlistType < BaseObject
        graphql_name 'CiJobTokenScopeAllowlist'

        field :groups_allowlist,
          Types::Ci::JobTokenScope::AllowlistEntryType.connection_type,
          null: true,
          description: "Allowlist of groups that can access the current project " \
            "by authenticating with a CI/CD job token."

        field :projects_allowlist,
          Types::Ci::JobTokenScope::AllowlistEntryType.connection_type,
          null: true,
          description: "Allowlist of projects that can access the current project " \
            "by authenticating with a CI/CD job token."
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_scope/direction_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module JobTokenScope
      class DirectionEnum < BaseEnum
        graphql_name 'CiJobTokenScopeDirection'
        description 'Direction of access.'

        value 'OUTBOUND',
          value: :outbound,
          description: 'Job token scope project can access target project in the outbound allowlist.'

        value 'INBOUND',
          value: :inbound,
          description: 'Target projects in the inbound allowlist can access the scope project ' \
            'through their job tokens.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_scope/policies_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module JobTokenScope
      class PoliciesEnum < BaseEnum
        graphql_name 'CiJobTokenScopePolicies'
        description 'CI_JOB_TOKEN policy'

        ::Ci::JobToken::Policies.all_values.each do |policy|
          value policy.upcase, value: policy, description: policy.titleize
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_scope/target_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module JobTokenScope
      class TargetType < BaseUnion
        graphql_name 'CiJobTokenScopeTarget'
        description 'Represents an object that is the target of a CI_JOB_TOKEN allowlist entry'

        possible_types Types::Ci::JobTokenAccessibleProjectType, Types::Ci::JobTokenAccessibleGroupType

        def self.resolve_type(object, _context)
          case object
          when Project
            Types::Ci::JobTokenAccessibleProjectType
          when Group
            Types::Ci::JobTokenAccessibleGroupType
          else
            raise 'Unsupported CI job token scope target type'
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_token_scope_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # Authorization is in the resolver based on the parent project
  # TODO: remove once https://gitlab.com/gitlab-org/govern/authorization/team-tasks/-/issues/87 is resolved
  module Ci
    class JobTokenScopeType < BaseObject
      graphql_name 'CiJobTokenScopeType'

      field :projects,
        Types::ProjectType.connection_type,
        null: false,
        description: 'Allow list of projects that can be accessed by CI Job tokens created by the project.',
        method: :outbound_projects,
        deprecated: {
          reason: 'The `projects` attribute is being deprecated. Use `outbound_allowlist`',
          milestone: '15.9'
        }

      field :outbound_allowlist,
        Types::ProjectType.connection_type,
        null: false,
        description: "Allow list of projects that are accessible using the current project's CI Job tokens.",
        method: :outbound_projects,
        deprecated: { reason: 'Outbound job token scope is being removed. Only inbound allowlist is supported',
                      milestone: '18.0' }

      field :inbound_allowlist,
        Types::Ci::JobTokenAccessibleProjectType.connection_type,
        null: false,
        description: "Allowlist of projects that can access the current project " \
          "by authenticating with a CI/CD job token.",
        method: :inbound_projects

      field :groups_allowlist,
        Types::Ci::JobTokenAccessibleGroupType.connection_type,
        null: false,
        description: "Allowlist of groups that can access the current project " \
          "by authenticating with a CI/CD job token.",
        method: :groups

      field :inbound_allowlist_count,
        GraphQL::Types::Int,
        null: false,
        description: "Count of projects that can access the current project " \
          "by authenticating with a CI/CD job token. " \
          "The count does not include nested projects.",
        method: :inbound_projects_count

      field :groups_allowlist_count,
        GraphQL::Types::Int,
        null: false,
        description: "Count of groups that can access the current project " \
          "by authenticating with a CI/CD job token. " \
          "The count does not include subgroups.",
        method: :groups_count

      field :group_allowlist_autopopulated_ids,
        [::Types::GlobalIDType[::Group]],
        null: false,
        description: 'List of IDs of groups which have been created by the  ' \
          'autopopulation process.',
        method: :autopopulated_group_ids

      field :inbound_allowlist_autopopulated_ids,
        [::Types::GlobalIDType[::Project]],
        null: false,
        description: 'List of IDs of projects which have been created by the  ' \
          'autopopulation process.',
        method: :autopopulated_inbound_project_ids
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_trace_type.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/AuthorizeTypes
module Types
  module Ci
    class JobTraceType < BaseObject
      graphql_name 'CiJobTrace'
      MAX_SIZE_KB = 16
      MAX_SIZE_B = MAX_SIZE_KB * 1024

      field :html_summary, GraphQL::Types::String, null: false,
        experiment: { milestone: '15.11' },
        description: 'HTML summary that contains the tail lines of the trace. ' \
          "Returns at most #{MAX_SIZE_KB}KB of raw bytes from the trace. " \
          'The returned string might start with an unexpected invalid UTF-8 code point due to truncation.' do
        argument :last_lines, Integer,
          required: false, default_value: 10,
          description: 'Number of tail lines to return, up to a maximum of 100 lines.'
      end

      def html_summary(last_lines:)
        object.html(
          last_lines: last_lines.clamp(1, 100),
          max_size: MAX_SIZE_B
        ).html_safe
      end
    end
  end
end
# rubocop: enable Graphql/AuthorizeTypes


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/job_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    # The permission is presented through `StageType` that has its own authorization
    class JobType < BaseObject
      graphql_name 'CiJob'

      implements ::Types::Ci::JobInterface

      present_using ::Ci::BuildPresenter
      field_class Types::Ci::JobBaseField

      connection_type_class Types::LimitedCountableConnectionType

      expose_permissions Types::PermissionTypes::Ci::Job

      field :allow_failure, ::GraphQL::Types::Boolean, null: false,
        description: 'Whether the job is allowed to fail.'
      field :duration, GraphQL::Types::Int, null: true,
        description: 'Duration of the job in seconds.'
      field :id, ::Types::GlobalIDType[::CommitStatus].as('JobID'), null: true,
        description: 'ID of the job.'
      field :kind, type: ::Types::Ci::JobKindEnum, null: false,
        description: 'Indicates the type of job.'
      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the job.'
      field :needs, BuildNeedType.connection_type, null: true,
        description: 'References to builds that must complete before the jobs run.'
      field :pipeline, Types::Ci::PipelineInterface, null: true,
        description: 'Pipeline the job belongs to.'

      field :runner, Types::Ci::RunnerType, null: true, description: 'Runner assigned to execute the job.'
      field :runner_manager, ::Types::Ci::RunnerManagerType, null: true,
        description: 'Runner manager assigned to the job.'
      field :stage, Types::Ci::StageType, null: true,
        description: 'Stage of the job.'
      field :status,
        type: ::Types::Ci::JobStatusEnum,
        null: true,
        description: "Status of the job."
      field :tags, [GraphQL::Types::String], null: true,
        description: 'Tags for the current job.'

      # Life-cycle timestamps:
      field :created_at, Types::TimeType, null: false,
        description: "When the job was created."
      field :erased_at, Types::TimeType, null: true,
        description: "When the job was erased."
      field :finished_at, Types::TimeType, null: true,
        description: 'When a job has finished running.'
      field :queued_at, Types::TimeType, null: true,
        description: 'When the job was enqueued and marked as pending.'
      field :scheduled_at, Types::TimeType, null: true,
        description: 'Schedule for the build.'
      field :started_at, Types::TimeType, null: true,
        description: 'When the job was started.'

      # Life-cycle durations:
      field :queued_duration,
        type: Types::DurationType,
        null: true,
        description: 'How long the job was enqueued before starting.'

      field :active, GraphQL::Types::Boolean, null: false, method: :active?,
        description: 'Indicates the job is active.'
      field :artifacts, Types::Ci::JobArtifactType.connection_type, null: true,
        description: 'Artifacts generated by the job.'
      field :browse_artifacts_path, GraphQL::Types::String, null: true,
        description: "URL for browsing the artifact's archive."
      field :cancelable, GraphQL::Types::Boolean, null: false, method: :cancelable?,
        description: 'Indicates the job can be canceled.'
      field :commit_path, GraphQL::Types::String, null: true,
        description: 'Path to the commit that triggered the job.'
      field :coverage, GraphQL::Types::Float, null: true,
        description: 'Coverage level of the job.'
      field :created_by_tag, GraphQL::Types::Boolean, null: false,
        description: 'Whether the job was created by a tag.', method: :tag?
      field :detailed_status, Types::Ci::DetailedStatusType, null: true,
        description: 'Detailed status of the job.'
      field :downstream_pipeline, Types::Ci::PipelineType, null: true,
        description: 'Downstream pipeline for a bridge.'
      field :manual_job, GraphQL::Types::Boolean, null: true,
        description: 'Whether the job has a manual action.'
      field :manual_variables, ManualVariableType.connection_type, null: true,
        description: 'Variables added to a manual job when the job is triggered.'
      field :play_path, GraphQL::Types::String, null: true,
        description: 'Play path of the job.'
      field :playable, GraphQL::Types::Boolean, null: false, method: :playable?,
        description: 'Indicates the job can be played.'
      field :previous_stage_jobs, Types::Ci::JobType.connection_type,
        null: true,
        description: 'Jobs from the previous stage.'
      field :previous_stage_jobs_or_needs, Types::Ci::JobNeedUnion.connection_type,
        null: true,
        description: 'Jobs that must complete before the job runs. Returns `BuildNeed`, ' \
          'which is the needed jobs if the job uses the `needs` keyword, or the previous stage jobs otherwise.',
        deprecated: { reason: 'Replaced by previousStageJobs and needs fields', milestone: '16.4' }
      field :ref_name, GraphQL::Types::String, null: true,
        description: 'Ref name of the job.'
      field :ref_path, GraphQL::Types::String, null: true,
        description: 'Path to the ref.'
      field :retried, GraphQL::Types::Boolean, null: true,
        description: 'Indicates that the job has been retried.'
      field :retry_path, GraphQL::Types::String, null: true,
        description: 'Retry path of the job.'
      field :retryable, GraphQL::Types::Boolean, null: false,
        description: 'Indicates the job can be retried.'
      field :scheduled, GraphQL::Types::Boolean, null: false, method: :scheduled?,
        description: 'Indicates the job is scheduled.'
      field :scheduling_type, GraphQL::Types::String, null: true,
        description: 'Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise.'
      field :short_sha, type: GraphQL::Types::String, null: false,
        description: 'Short SHA1 ID of the commit.',
        if_unauthorized: 'Unauthorized'
      field :stuck, GraphQL::Types::Boolean, null: false, method: :stuck?,
        description: 'Indicates the job is stuck.'
      field :triggered, GraphQL::Types::Boolean, null: true,
        description: 'Whether the job was triggered.'
      field :web_path, GraphQL::Types::String, null: true,
        description: 'Web path of the job.'

      field :project, Types::ProjectType, null: true, description: 'Project that the job belongs to.'

      field :can_play_job, GraphQL::Types::Boolean,
        null: false, resolver_method: :can_play_job?,
        description: 'Indicates whether the current user can play the job.',
        calls_gitaly: true

      field :failure_message, GraphQL::Types::String, null: true,
        description: 'Message on why the job failed.'

      field :source, GraphQL::Types::String, null: true,
        description: 'Policy or action that initiated the job. If not set, the value is inherited from the pipeline.'

      field :exit_code, GraphQL::Types::Int, null: true,
        description: 'Exit code of the job. Available for jobs that started after upgrading to GitLab 16.10 and failed with an exit code.'

      def can_play_job?
        object.playable? && Ability.allowed?(current_user, :play_job, object)
      end

      def kind
        return ::Ci::Build unless [::Ci::Build, ::Ci::Bridge].include?(object.build.class)

        object.build.class
      end

      def retryable
        object.build.retryable?
      end

      def pipeline
        Gitlab::Graphql::Loaders::BatchModelLoader.new(::Ci::Pipeline, object.pipeline_id).find
      end

      def downstream_pipeline
        object.downstream_pipeline if object.respond_to?(:downstream_pipeline)
      end

      def tags
        object.tags.map(&:name) if object.is_a?(::Ci::Build)
      end

      def artifacts
        object.job_artifacts if object.is_a?(::Ci::Build)
      end

      def source
        object.source if object.is_a?(::Ci::Build)
      end

      def trace
        object.trace if object.has_trace?
      end

      def previous_stage_jobs_or_needs
        if object.scheduling_type == 'stage'
          Gitlab::Graphql::Lazy.with_value(previous_stage_jobs) do |jobs|
            jobs
          end
        else
          object.needs
        end
      end

      def previous_stage_jobs
        BatchLoader::GraphQL.for([object.pipeline_id, object.stage_idx - 1]).batch(default_value: []) do |tuples, loader|
          pipeline_ids = tuples.map(&:first).uniq
          stage_idxs = tuples.map(&:second).uniq

          # This query can fetch unneeded jobs when querying for more than one pipeline.
          # It was decided that fetching and discarding the jobs is preferable to making a more complex query.
          jobs = CommitStatus.in_pipelines(pipeline_ids).for_stage(stage_idxs).latest
          grouped_jobs = jobs.group_by { |job| [job.pipeline_id, job.stage_idx] }

          tuples.each do |tuple|
            loader.call(tuple, grouped_jobs.fetch(tuple, []))
          end
        end
      end

      def stage
        ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::Ci::Stage, object.stage_id).find
      end

      def runner
        Gitlab::Graphql::Loaders::BatchModelLoader.new(::Ci::Runner, object.runner_id).find
      end

      def runner_manager
        BatchLoader::GraphQL.for(object.id).batch(key: :runner_managers) do |build_ids, loader|
          plucked_build_to_runner_manager_ids =
            ::Ci::RunnerManagerBuild.for_build(build_ids).pluck_build_id_and_runner_manager_id
          runner_managers = ::Ci::RunnerManager.id_in(plucked_build_to_runner_manager_ids.values.uniq)
          Preloaders::RunnerManagerPolicyPreloader.new(runner_managers, current_user).execute
          runner_managers_by_id = runner_managers.index_by(&:id)

          build_ids.each do |build_id|
            loader.call(build_id, runner_managers_by_id[plucked_build_to_runner_manager_ids[build_id]])
          end
        end
      end

      # This class is a secret union!
      # TODO: turn this into an actual union, so that fields can be referenced safely!
      def id
        return unless object.id.present?

        model_name = object.type || ::CommitStatus.name
        id = object.id
        Gitlab::GlobalId.build(model_name: model_name, id: id)
      end

      def commit_path
        ::Gitlab::Routing.url_helpers.project_commit_path(object.project, object.sha)
      end

      def ref_path
        ::Gitlab::Routing.url_helpers.project_commits_path(object.project, ref_name)
      end

      def web_path
        ::Gitlab::Routing.url_helpers.project_job_path(object.project, object) unless object.is_a?(::Ci::Bridge)
      end

      def retry_path
        return unless retryable

        ::Gitlab::Routing.url_helpers.retry_project_job_path(object.project, object)
      end

      def play_path
        ::Gitlab::Routing.url_helpers.play_project_job_path(object.project, object)
      end

      def browse_artifacts_path
        ::Gitlab::Routing.url_helpers.browse_project_job_artifacts_path(object.project, object)
      end

      def coverage
        object&.coverage
      end

      def manual_variables
        if object.try(:action?) && !object.is_a?(GenericCommitStatus)
          BatchLoader::GraphQL.for(object.id).batch do |job_ids, loader|
            variables_by_job_id = ::Ci::JobVariable.for_jobs(job_ids).group_by(&:job_id)

            job_ids.each do |id|
              loader.call(id, variables_by_job_id[id] || [])
            end
          end
        else
          ::Ci::JobVariable.none
        end
      end

      def exit_code
        object.exit_code if object.build.respond_to?(:exit_code)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/legacy_config/config_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- Authorization handled by the ConfigResolver
    module LegacyConfig
      class ConfigType < ::Types::Ci::ConfigType
        graphql_name 'CiConfig'

        field :stages, Types::Ci::LegacyConfig::StageType.connection_type, null: true,
          description: 'Stages of the pipeline.'
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/legacy_config/group_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- Authorization handled by the ConfigResolver
    module LegacyConfig
      class GroupType < ::Types::Ci::Config::GroupType
        graphql_name 'CiConfigGroup'

        field :jobs, Types::Ci::LegacyConfig::JobType.connection_type, null: true,
          description: 'Jobs in group.'
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/legacy_config/job_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- Authorization handled by the ConfigResolver
    module LegacyConfig
      class JobType < ::Types::Ci::Config::JobType
        graphql_name 'CiConfigJob'

        field :needs,
          Types::Ci::Config::NeedType.connection_type,
          null: true,
          description: 'Builds that must complete before the jobs run.'
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/legacy_config/stage_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- Authorization handled by the ConfigResolver
    module LegacyConfig
      class StageType < ::Types::Ci::Config::StageType
        graphql_name 'CiConfigStage'

        field :groups, Types::Ci::LegacyConfig::GroupType.connection_type, null: true,
          description: 'Groups of jobs for the stage.'
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/manual_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class ManualVariableType < BaseObject
      graphql_name 'CiManualVariable'
      description 'CI/CD variables given to a manual job.'

      implements VariableInterface

      field :environment_scope, GraphQL::Types::String,
        null: true,
        deprecated: {
          reason: 'No longer used, only available for GroupVariableType and ProjectVariableType',
          milestone: '15.3'
        },
        description: 'Scope defining the environments that can use the variable.'

      def environment_scope
        nil
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/namespace_settings_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class NamespaceSettingsType < BaseObject
      graphql_name 'CiCdSettings'

      authorize :maintainer_access

      field :pipeline_variables_default_role, GraphQL::Types::String,
        null: true,
        description: 'Indicates the default minimum role required to override pipeline variables in the namespace.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_base_field.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable GraphQL/GraphqlName -- Not a type
    # rubocop: disable Graphql/AuthorizeTypes -- Not a type
    class PipelineBaseField < ::Types::BaseField
      def initialize(**kwargs, &block)
        kwargs[:authorize] = :read_pipeline

        super
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
    # rubocop: enable GraphQL/GraphqlName
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_config_source_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineConfigSourceEnum < BaseEnum
      ::Enums::Ci::Pipeline.config_sources.keys.each do |state_symbol|
        description = state_symbol == :auto_devops_source ? "Auto DevOps source." : "#{state_symbol.to_s.titleize.capitalize}." # This is needed to avoid failure in doc lint
        value state_symbol.to_s.upcase, value: state_symbol.to_s, description: description
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_counts_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineCountsType < BaseObject
      graphql_name 'PipelineCounts'
      description "Represents pipeline counts for the project"

      authorize :read_pipeline

      (::Types::Ci::PipelineScopeEnum.values.keys - %w[BRANCHES TAGS]).each do |scope|
        field scope.downcase,
          GraphQL::Types::Int,
          null: true,
          description: "Number of pipelines with scope #{scope} for the project"
      end

      field :all,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of pipelines for the project.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_creation/request_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module PipelineCreation
      # rubocop:disable Graphql/AuthorizeTypes -- Authorization is handled in the `ProjectType#ci_pipeline_creation_request` field
      class RequestType < BaseObject
        graphql_name 'CiPipelineCreationRequest'

        description 'Information about an asynchronous pipeline creation request'

        field :status, StatusEnum,
          null: false,
          description: 'Current status of the pipeline creation.'

        field :pipeline_id, GlobalIDType[::Ci::Pipeline],
          null: true,
          description: 'ID of the created pipeline if creation was successful.'

        field :error, GraphQL::Types::String,
          null: true,
          description: 'Error message if pipeline creation failed.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_creation/status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module PipelineCreation
      class StatusEnum < BaseEnum
        graphql_name 'CiPipelineCreationStatus'

        description 'The status of a pipeline creation'

        ::Ci::PipelineCreation::Requests::STATUSES.each do |status|
          value status.upcase, description: "The pipeline creation is #{status.tr('_', ' ')}", value: status
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_interface.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # This inteface sets [authorize: :read_pipeline] (field-level authorization
    # via PipelineBaseField) for all defined fields to ensure implementing types
    # don't expose inherited fields without proper authorization.
    #
    # Implementing types can opt-out from this field-level auth and use
    # type-level auth by re-defining the field without the authorize argument.
    # For example, PipelineType uses :read_pipeline type-level auth and
    # redefines all fields in this interface to opt-out while
    # PipelineMinimalAccessType uses :read_pipeline_metadata type-level auth to
    # expose a set of defined fields and leaves inherited fields it does not
    # want to expose to use field-level auth using :read_pipeline.
    module PipelineInterface
      include BaseInterface

      graphql_name 'PipelineInterface'

      connection_type_class Types::CountableConnectionType

      field_class ::Types::Ci::PipelineBaseField

      field :id, GraphQL::Types::ID, null: true,
        description: 'ID of the pipeline.'
      field :iid, GraphQL::Types::String, null: true,
        description: 'Internal ID of the pipeline.'
      field :path, GraphQL::Types::String, null: true,
        description: "Relative path to the pipeline's page."
      field :project, Types::Projects::ProjectInterface, null: true,
        description: 'Project the pipeline belongs to.'
      field :user,
        type: 'Types::UserType',
        null: true,
        description: 'Pipeline user.'

      def self.resolve_type(_object, _context)
        PipelineType
      end

      def path
        ::Gitlab::Routing.url_helpers.project_pipeline_path(object.project, object)
      end
    end
  end
end

Types::Ci::PipelineInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_manual_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes -- Authentication at another location
    class PipelineManualVariableType < BaseObject
      graphql_name 'PipelineManualVariable'
      description 'CI/CD variables added to a manual pipeline.'

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the variable.'

      field :key, GraphQL::Types::String,
        null: true,
        description: 'Name of the variable.'

      field :value, GraphQL::Types::String,
        null: true,
        description: 'Value of the variable.'

      def value
        return unless Ability.allowed?(current_user, :read_pipeline_variable, object.pipeline)

        object.value
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_merge_request_event_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineMergeRequestEventTypeEnum < BaseEnum
      graphql_name 'PipelineMergeRequestEventType'
      description 'Event type of the pipeline associated with a merge request'

      value 'MERGED_RESULT',
        'Pipeline run on the changes from the source branch combined with the target branch.',
        value: :merged_result
      value 'DETACHED',
        'Pipeline run on the changes in the merge request source branch.',
        value: :detached
    end
  end
end

Types::Ci::PipelineMergeRequestEventTypeEnum.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_message_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class PipelineMessageType < BaseObject
      graphql_name 'PipelineMessage'

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the pipeline message.'

      field :content, GraphQL::Types::String, null: false,
        description: 'Content of the pipeline message.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_schedule_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineScheduleSortEnum < BaseEnum
      graphql_name 'PipelineScheduleSort'
      description 'Values for sorting pipeline schedules.'

      value 'ID_DESC', 'Sort pipeline schedules by ID in descending order.', value: :id_desc
      value 'ID_ASC', 'Sort pipeline schedules by ID in ascending order.', value: :id_asc
      value 'DESCRIPTION_DESC', 'Sort pipeline schedules by description in descending order.', value: :description_desc
      value 'DESCRIPTION_ASC', 'Sort pipeline schedules by description in ascending order.', value: :description_asc
      value 'REF_DESC', 'Sort pipeline schedules by target in descending order.', value: :ref_desc
      value 'REF_ASC', 'Sort pipeline schedules by target in ascending order.', value: :ref_asc
      value 'NEXT_RUN_AT_DESC', 'Sort pipeline schedules by next run in descending order.', value: :next_run_at_desc
      value 'NEXT_RUN_AT_ASC', 'Sort pipeline schedules by next run in ascending order.', value: :next_run_at_asc
      value 'CREATED_AT_DESC', 'Sort pipeline schedules by created date in descending order.', value: :created_at_desc
      value 'CREATED_AT_ASC', 'Sort pipeline schedules by created date in ascending order.', value: :created_at_asc
      value 'UPDATED_AT_DESC', 'Sort pipeline schedules by updated date in descending order.', value: :updated_at_desc
      value 'UPDATED_AT_ASC', 'Sort pipeline schedules by updated date in ascending order.', value: :updated_at_asc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_schedule_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineScheduleStatusEnum < BaseEnum
      graphql_name 'PipelineScheduleStatus'

      value 'ACTIVE', value: "active", description: 'Active pipeline schedules.'
      value 'INACTIVE', value: "inactive", description: 'Inactive pipeline schedules.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_schedule_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineScheduleType < BaseObject
      graphql_name 'PipelineSchedule'

      description 'Represents a pipeline schedule'

      connection_type_class Types::CountableConnectionType

      expose_permissions Types::PermissionTypes::Ci::PipelineSchedules

      authorize :read_pipeline_schedule

      field :id, GraphQL::Types::ID, null: false, description: 'ID of the pipeline schedule.'

      field :description, GraphQL::Types::String, null: true, description: 'Description of the pipeline schedule.'

      field :owner, ::Types::UserType, null: true, description: 'Owner of the pipeline schedule.'

      field :active, GraphQL::Types::Boolean, null: false, description: 'Indicates if the pipeline schedule is active.'

      field :project, ::Types::ProjectType, null: true, description: 'Project of the pipeline schedule.'

      field :next_run_at, Types::TimeType, null: true, description: 'Time when the next pipeline will run.'

      field :real_next_run, Types::TimeType, null: true, description: 'Time when the next pipeline will run.'

      field :last_pipeline, PipelineType, null: true, description: 'Last pipeline object.'

      field :ref_for_display, GraphQL::Types::String,
        null: true, description: 'Git ref for the pipeline schedule.'

      field :for_tag, GraphQL::Types::Boolean,
        null: false, description: 'Indicates if a pipelines schedule belongs to a tag.', method: :for_tag?

      field :edit_path, GraphQL::Types::String,
        null: true,
        description: 'Edit path of the pipeline schedule.',
        authorize: :update_pipeline_schedule

      field :inputs,
        Types::Ci::Inputs::FieldType.connection_type,
        null: true,
        description: 'Inputs configured for the pipeline schedule.',
        experiment: { milestone: '17.10' }

      field :variables,
        Types::Ci::PipelineScheduleVariableType.connection_type,
        null: true,
        description: 'Pipeline schedule variables.',
        authorize: :read_pipeline_schedule_variables

      field :ref, GraphQL::Types::String,
        null: true, description: 'Ref of the pipeline schedule.', method: :ref_for_display

      field :ref_path, GraphQL::Types::String,
        null: true,
        description: 'Path to the ref that triggered the pipeline.'

      field :cron, GraphQL::Types::String,
        null: false,
        description: 'Cron notation for the schedule.'

      field :cron_timezone, GraphQL::Types::String,
        null: false,
        description: 'Timezone for the pipeline schedule.'

      field :created_at, Types::TimeType,
        null: false, description: 'Timestamp of when the pipeline schedule was created.'

      field :updated_at, Types::TimeType,
        null: false, description: 'Timestamp of when the pipeline schedule was last updated.'

      def ref_path
        ref_for_display = object.ref_for_display
        return unless ref_for_display

        ::Gitlab::Routing.url_helpers.project_commits_path(object.project, ref_for_display)
      end

      def edit_path
        ::Gitlab::Routing.url_helpers.edit_project_pipeline_schedule_path(object.project, object)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_schedule_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineScheduleVariableType < BaseObject
      graphql_name 'PipelineScheduleVariable'

      authorize :read_pipeline_schedule_variables

      implements VariableInterface
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_scope_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineScopeEnum < BaseEnum
      SCOPES_DESCRIPTION = {
        running: 'Pipeline is running.',
        pending: 'Pipeline has not started running yet.',
        finished: 'Pipeline has completed.',
        branches: 'Branches.',
        tags: 'Tags.'
      }.freeze

      SCOPES_DESCRIPTION.each do |scope, description|
        value scope.to_s.upcase,
          description: description,
          value: scope.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_sources_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineSourcesEnum < BaseEnum
      graphql_name 'CiPipelineSources'
      description 'Ci Pipeline sources enum'

      Enums::Ci::Pipeline.sources.each_key do |source|
        article = %w[a e i o u].include?(source.to_s[0].downcase) ? 'an' : 'a'
        desc_source = source.to_s.include?('api') ? 'API' : source
        description = "Pipeline created by #{article} #{desc_source.to_s.tr('_', ' ').delete_suffix(' event')} event"
        value source.to_s.upcase, value: source, description: description
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineStatusEnum < BaseEnum
      STATUSES_DESCRIPTION = {
        created: 'Pipeline has been created.',
        waiting_for_resource: 'A resource (for example, a runner) that the pipeline requires to run is unavailable.',
        preparing: 'Pipeline is preparing to run.',
        waiting_for_callback: 'Pipeline is waiting for an external action.',
        pending: 'Pipeline has not started running yet.',
        running: 'Pipeline is running.',
        failed: 'At least one stage of the pipeline failed.',
        success: 'Pipeline completed successfully.',
        canceling: 'Pipeline is in the process of canceling.',
        canceled: 'Pipeline was canceled before completion.',
        skipped: 'Pipeline was skipped.',
        manual: 'Pipeline needs to be manually started.',
        scheduled: 'Pipeline is scheduled to run.'
      }.freeze

      STATUSES_DESCRIPTION.each do |state, description|
        value state.to_s.upcase,
          description: description,
          value: state.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_trigger_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineTriggerType < BaseObject
      graphql_name 'PipelineTrigger'

      present_using ::Ci::TriggerPresenter
      connection_type_class Types::CountableConnectionType

      authorize :manage_trigger

      field :can_access_project, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates if the pipeline trigger token has access to the project.',
        method: :can_access_project?

      field :description, GraphQL::Types::String,
        null: true,
        description: 'Description of the pipeline trigger token.'

      field :has_token_exposed, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates if the token is exposed.',
        method: :has_token_exposed?

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the pipeline trigger token.'

      field :last_used, Types::TimeType,
        null: true,
        description: 'Timestamp of the last usage of the pipeline trigger token.'

      field :expires_at, Types::TimeType,
        null: true,
        description: 'Timestamp of when the pipeline trigger token expires.'

      field :owner, Types::UserType,
        null: false,
        description: 'Owner of the pipeline trigger token.'

      field :token, GraphQL::Types::String,
        null: false,
        description: 'Value of the pipeline trigger token.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineType < BaseObject
      graphql_name 'Pipeline'

      implements PipelineInterface

      connection_type_class Types::CountableConnectionType

      authorize :read_pipeline
      present_using ::Ci::PipelinePresenter

      expose_permissions Types::PermissionTypes::Ci::Pipeline

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the pipeline.'

      field :iid, GraphQL::Types::String, null: false,
        description: 'Internal ID of the pipeline.'

      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the pipeline.'

      field :sha, GraphQL::Types::String, null: true,
        description: "SHA of the pipeline's commit." do
        argument :format,
          type: Types::ShaFormatEnum,
          required: false,
          description: 'Format of the SHA.'
      end

      field :before_sha, GraphQL::Types::String, null: true,
        description: 'Base SHA of the source branch.',
        calls_gitaly: true

      field :complete, GraphQL::Types::Boolean, null: false, method: :complete?,
        description: 'Indicates if a pipeline is complete.'

      field :status, PipelineStatusEnum, null: false,
        description: "Status of the pipeline (#{::Ci::Pipeline.all_state_names.compact.join(', ').upcase})"

      field :warnings, GraphQL::Types::Boolean, null: false, method: :has_warnings?,
        description: "Indicates if a pipeline has warnings."

      field :detailed_status, Types::Ci::DetailedStatusType, null: false,
        description: 'Detailed status of the pipeline.'

      field :config_source, PipelineConfigSourceEnum, null: true,
        description: "Configuration source of the pipeline (#{::Enums::Ci::Pipeline.config_sources.keys.join(', ').upcase})"

      field :duration, GraphQL::Types::Int, null: true,
        description: 'Duration of the pipeline in seconds.'

      field :queued_duration, Types::DurationType, null: true,
        description: 'How long the pipeline was queued before starting.'

      field :coverage, GraphQL::Types::Float, null: true,
        description: 'Coverage percentage.'

      field :created_at, Types::TimeType, null: false,
        description: "Timestamp of the pipeline's creation."

      field :updated_at, Types::TimeType, null: false,
        description: "Timestamp of the pipeline's last activity."

      field :started_at, Types::TimeType, null: true,
        description: 'Timestamp when the pipeline was started.'

      field :finished_at, Types::TimeType, null: true,
        description: "Timestamp of the pipeline's completion."

      field :committed_at, Types::TimeType, null: true,
        description: "Timestamp of the pipeline's commit."

      field :stages,
        type: Types::Ci::StageType.connection_type,
        null: true,
        authorize: :read_build,
        description: 'Stages of the pipeline.',
        extras: [:lookahead],
        resolver: Resolvers::Ci::PipelineStagesResolver

      field :user,
        type: 'Types::UserType',
        null: true,
        description: 'Pipeline user.'

      field :retryable, GraphQL::Types::Boolean,
        description: 'Specifies if a pipeline\'s jobs can be retried.',
        method: :retryable?,
        null: false

      field :cancelable, GraphQL::Types::Boolean,
        description: 'Specifies if a pipeline can be canceled.',
        method: :cancelable?,
        null: false

      field :jobs,
        ::Types::Ci::JobType.connection_type,
        null: true,
        authorize: :read_build,
        description: 'Jobs belonging to the pipeline.',
        resolver: ::Resolvers::Ci::JobsResolver

      field :job,
        type: ::Types::Ci::JobType,
        null: true,
        authorize: :read_build,
        description: 'Specific job in the pipeline, either by name or ID.' do
        argument :id,
          type: ::Types::GlobalIDType[::CommitStatus],
          required: false,
          description: 'ID of the job.'
        argument :name,
          type: ::GraphQL::Types::String,
          required: false,
          description: 'Name of the job.'
      end

      field :job_artifacts,
        null: true,
        description: 'Job artifacts of the pipeline.',
        resolver: ::Resolvers::Ci::PipelineJobArtifactsResolver

      field :source_job,
        type: Types::Ci::JobType,
        null: true,
        authorize: :read_build,
        description: 'Job where pipeline was triggered from.'

      field :downstream, Types::Ci::PipelineType.connection_type, null: true,
        description: 'Pipelines the pipeline will trigger.',
        method: :triggered_pipelines_with_preloads

      field :upstream, Types::Ci::PipelineType, null: true,
        description: 'Pipeline that triggered the pipeline.',
        method: :triggered_by_pipeline

      field :path, GraphQL::Types::String, null: true,
        description: "Relative path to the pipeline's page."

      field :commit, Types::Repositories::CommitType, null: true,
        description: "Git commit of the pipeline.",
        calls_gitaly: true

      field :commit_path, GraphQL::Types::String, null: true,
        description: 'Path to the commit that triggered the pipeline.'

      field :project, Types::ProjectType, null: true,
        description: 'Project the pipeline belongs to.'

      field :active, GraphQL::Types::Boolean, null: false, method: :active?,
        description: 'Indicates if the pipeline is active.'

      field :uses_needs, GraphQL::Types::Boolean, null: true,
        method: :uses_needs?,
        description: 'Indicates if the pipeline has jobs with `needs` dependencies.'

      field :test_report_summary,
        Types::Ci::TestReportSummaryType,
        null: false,
        description: 'Summary of the test report generated by the pipeline.',
        resolver: Resolvers::Ci::TestReportSummaryResolver

      field :test_suite,
        Types::Ci::TestSuiteType,
        null: true,
        description: 'A specific test suite in a pipeline test report.',
        resolver: Resolvers::Ci::TestSuiteResolver

      field :ref, GraphQL::Types::String, null: true,
        description: 'Reference to the branch from which the pipeline was triggered.'

      field :ref_path, GraphQL::Types::String, null: true,
        description: 'Reference path to the branch from which the pipeline was triggered.',
        method: :source_ref_path

      field :warning_messages, Types::Ci::PipelineMessageType.connection_type, null: true,
        description: 'Pipeline warning messages.'

      field :error_messages, Types::Ci::PipelineMessageType.connection_type, null: true,
        description: 'Pipeline error messages.'

      field :merge_request_event_type, Types::Ci::PipelineMergeRequestEventTypeEnum, null: true,
        description: "Event type of the pipeline associated with a merge request."

      field :total_jobs, GraphQL::Types::Int, null: false, method: :total_size, description: "Total number of jobs in the pipeline."

      field :failure_reason, GraphQL::Types::String, null: true, description: "Reason why the pipeline failed."

      field :triggered_by_path, GraphQL::Types::String, null: true, description: "Path that triggered the pipeline."

      field :source, GraphQL::Types::String, null: true, description: "Source of the pipeline."

      field :type, GraphQL::Types::String, null: false, description: "Type of the pipeline."

      field :child, GraphQL::Types::Boolean, null: false, method: :child?, description: "If the pipeline is a child or not."

      field :latest, GraphQL::Types::Boolean, null: false, method: :latest?, calls_gitaly: true, description: "If the pipeline is the latest one or not."

      field :ref_text, GraphQL::Types::String, null: false, description: "Reference text from the presenter.", calls_gitaly: true

      field :merge_request, Types::MergeRequestType, null: true, description: "MR which the Pipeline is attached to."

      field :stuck, GraphQL::Types::Boolean, method: :stuck?, null: false, description: "If the pipeline is stuck."

      field :yaml_errors, GraphQL::Types::Boolean, method: :yaml_errors?, null: false, description: "If the pipeline has YAML errors."

      field :yaml_error_messages, GraphQL::Types::String, method: :yaml_errors, null: true, description: "Pipeline YAML errors."

      field :trigger, GraphQL::Types::Boolean, method: :trigger?, null: false, description: "If the pipeline was created by a Trigger request."

      field :manual_variables, PipelineManualVariableType.connection_type, null: true, method: :variables, description: 'CI/CD variables added to a manual pipeline.'

      def commit
        BatchLoader::GraphQL.wrap(object.commit)
      end

      def error_messages
        BatchLoader::GraphQL.for(object).batch do |pipelines, loader|
          # rubocop: disable CodeReuse/ActiveRecord -- no need to bloat the Pipeline model, we only need this functionality for GraphQL
          messages = ::Ci::PipelineMessage.where(pipeline: pipelines, severity: :error)
          # rubocop: enable CodeReuse/ActiveRecord
          pipelines.each do |pipeline|
            loader.call(pipeline, messages.select { |m| m.pipeline_id == pipeline.id })
          end
        end
      end

      def detailed_status
        object.detailed_status(current_user)
      end

      def user
        Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.user_id).find
      end

      def commit_path
        ::Gitlab::Routing.url_helpers.project_commit_path(object.project, object.sha)
      end

      def warning_messages
        BatchLoader::GraphQL.for(object).batch do |pipelines, loader|
          # rubocop: disable CodeReuse/ActiveRecord -- context specific
          messages = ::Ci::PipelineMessage.where(pipeline: pipelines, severity: :warning)
          # rubocop: enable CodeReuse/ActiveRecord

          pipelines.each do |pipeline|
            loader.call(pipeline, messages.select { |m| m.pipeline_id == pipeline.id })
          end
        end
      end

      def job(id: nil, name: nil)
        raise ::Gitlab::Graphql::Errors::ArgumentError, 'One of id or name is required' unless id || name

        if id
          pipeline.statuses.id_in(id.model_id)
        else
          pipeline.latest_statuses.by_name(name)
        end.take # rubocop: disable CodeReuse/ActiveRecord
      end

      def sha(format: Types::ShaFormatEnum.enum[:long])
        return pipeline.short_sha if format == Types::ShaFormatEnum.enum[:short]

        pipeline.sha
      end

      alias_method :pipeline, :object
    end
  end
end

Types::Ci::PipelineType.prepend_mod_with('Types::Ci::PipelineType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/pipeline_variables_default_role_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class PipelineVariablesDefaultRoleTypeEnum < BaseEnum
      graphql_name 'PipelineVariablesDefaultRoleType'
      description 'Pipeline variables minimum override roles.'

      ProjectCiCdSetting::PIPELINE_VARIABLES_OVERRIDE_ROLES.keys.map(&:to_s).each do |role|
        value role.upcase, value: role, description: role.humanize
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/project_variable_connection_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class ProjectVariableConnectionType < GraphQL::Types::Relay::BaseConnection
      field :limit, GraphQL::Types::Int,
        null: false,
        description: 'Maximum amount of project CI/CD variables.'

      def limit
        ::Plan.default.actual_limits.project_ci_variables
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/project_variable_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class ProjectVariableType < BaseObject
      graphql_name 'CiProjectVariable'
      description 'CI/CD variables for a project.'

      connection_type_class Types::Ci::ProjectVariableConnectionType
      implements VariableInterface

      field :environment_scope, GraphQL::Types::String,
        null: true,
        description: 'Scope defining the environments that can use the variable.'

      field :protected, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is protected.'

      field :hidden, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is hidden.'

      field :masked, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is masked.'

      field :description, GraphQL::Types::String,
        null: true,
        description: 'Description of the variable.'

      def value
        ::Ci::VariableValue.new(object).evaluate
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/recent_failures_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class RecentFailuresType < BaseObject
      graphql_name 'RecentFailures'
      description 'Recent failure history of a test case.'

      connection_type_class Types::CountableConnectionType

      field :count, GraphQL::Types::Int, null: true,
        description: 'Number of times the test case has failed in the past 14 days.'

      field :base_branch, GraphQL::Types::String, null: true,
        description: 'Name of the base branch of the project.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerAccessLevelEnum < BaseEnum
      graphql_name 'CiRunnerAccessLevel'

      ::Ci::Runner.access_levels.keys.each do |type|
        value type.upcase,
          description: "A runner that is #{type.tr('_', ' ')}.",
          value: type
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_architecture_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class RunnerArchitectureType < BaseObject
      graphql_name 'RunnerArchitecture'

      field :download_location,
        GraphQL::Types::String,
        null: false,
        description: 'Download location for the runner for the platform architecture.'
      field :name, GraphQL::Types::String, null: false,
        description: 'Name of the runner platform architecture.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_countable_connection_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class RunnerCountableConnectionType < ::Types::CountableConnectionType
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end

Types::Ci::RunnerCountableConnectionType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_creation_method_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerCreationMethodEnum < BaseEnum
      graphql_name 'CiRunnerCreationMethod'

      value 'REGISTRATION_TOKEN',
        description: 'Applies to a runner that was created by a runner registration token.',
        value: 'registration_token'
      value 'AUTHENTICATED_USER',
        description: 'Applies to a runner that was created by an authenticated user.',
        value: 'authenticated_user'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_creation_state_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerCreationStateEnum < BaseEnum
      graphql_name 'CiRunnerCreationState'

      value 'STARTED',
        description: 'Applies to a runner that has been created, but is not yet registered and running.',
        value: 'started'
      value 'FINISHED',
        description: 'Applies to a runner that has been registered and has polled for CI/CD jobs at least once.',
        value: 'finished'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_job_execution_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerJobExecutionStatusEnum < BaseEnum
      graphql_name 'CiRunnerJobExecutionStatus'

      value 'IDLE',
        description: "Runner is idle.",
        value: :idle
      value 'ACTIVE',
        description: 'Runner is busy.',
        value: :active
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_manager_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerManagerType < BaseObject
      graphql_name 'CiRunnerManager'

      connection_type_class ::Types::CountableConnectionType

      authorize :read_runner_manager

      alias_method :runner_manager, :object

      # NOTE: instance runners are exposed by default to any authenticated user,
      # remember to protect any sensitive fields
      field :architecture_name, GraphQL::Types::String, null: true,
        description: 'Architecture provided by the runner manager.',
        method: :architecture
      field :contacted_at, Types::TimeType, null: true,
        description: 'Timestamp of last contact from the runner manager.'
      field :created_at, Types::TimeType, null: true,
        description: 'Timestamp of creation of the runner manager.'
      field :executor_name, GraphQL::Types::String, null: true,
        description: 'Executor last advertised by the runner.'
      field :id, ::Types::GlobalIDType[::Ci::RunnerManager], null: false,
        description: 'ID of the runner manager.'
      field :ip_address, GraphQL::Types::String, null: true,
        description: 'IP address of the runner manager.'
      field :job_execution_status,
        Types::Ci::RunnerJobExecutionStatusEnum,
        null: true,
        description: 'Job execution status of the runner manager.'
      field :platform_name, GraphQL::Types::String, null: true,
        description: 'Platform provided by the runner manager.',
        method: :platform
      field :revision, GraphQL::Types::String, null: true, description: 'Revision of the runner.'
      field :runner, RunnerType, null: true, description: 'Runner configuration for the runner manager.'
      field :status,
        Types::Ci::RunnerStatusEnum,
        null: false,
        description: 'Status of the runner manager.'
      field :system_id, GraphQL::Types::String,
        null: false,
        description: 'System ID associated with the runner manager.',
        method: :system_xid
      field :version, GraphQL::Types::String, null: true, description: 'Version of the runner.'

      def executor_name
        ::Ci::RunnerManager::EXECUTOR_TYPE_TO_NAMES[runner_manager.executor_type&.to_sym]
      end

      def job_execution_status
        BatchLoader::GraphQL.for(runner_manager.id).batch(key: :running_builds_exist) do |runner_manager_ids, loader|
          statuses = ::Ci::RunnerManager.id_in(runner_manager_ids).with_executing_builds.index_by(&:id)

          runner_manager_ids.each do |runner_manager_id|
            loader.call(runner_manager_id, statuses[runner_manager_id] ? :active : :idle)
          end
        end
      end
    end
  end
end

Types::Ci::RunnerManagerType.prepend_mod_with('Types::Ci::RunnerManagerType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_membership_filter_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerMembershipFilterEnum < BaseEnum
      graphql_name 'CiRunnerMembershipFilter'
      description 'Values for filtering runners in namespaces.'

      value 'DIRECT',
        description: "Include runners that have a direct relationship.",
        value: :direct

      value 'DESCENDANTS',
        description: "Include runners that have either a direct or inherited relationship. " \
          "These runners can be specific to a project or a group.",
        value: :descendants

      value 'ALL_AVAILABLE',
        description:
                       "Include all runners. This list includes runners for all projects in the group " \
          "and subgroups, as well as for the parent groups and instance.",
        value: :all_available,
        experiment: { milestone: '15.5' }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_platform_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class RunnerPlatformType < BaseObject
      graphql_name 'RunnerPlatform'

      field :architectures,
        Types::Ci::RunnerArchitectureType.connection_type,
        null: true,
        description: 'Runner architectures supported for the platform.'
      field :human_readable_name, GraphQL::Types::String, null: false,
        description: 'Human readable name of the runner platform.'
      field :name, GraphQL::Types::String, null: false,
        description: 'Name slug of the runner platform.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_setup_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class RunnerSetupType < BaseObject
      graphql_name 'RunnerSetup'

      field :install_instructions, GraphQL::Types::String, null: false,
        description: 'Instructions for installing the runner on the specified architecture.'
      field :register_instructions, GraphQL::Types::String, null: true,
        description: 'Instructions for registering the runner. The actual registration tokens are not included in the commands. Instead, a placeholder `$REGISTRATION_TOKEN` is shown.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerSortEnum < BaseEnum
      graphql_name 'CiRunnerSort'
      description 'Values for sorting runners'

      value 'CONTACTED_ASC', 'Ordered by contacted_at in ascending order.', value: :contacted_asc
      value 'CONTACTED_DESC', 'Ordered by contacted_at in descending order.', value: :contacted_desc
      value 'CREATED_ASC', 'Ordered by created_at in ascending order.', value: :created_at_asc
      value 'CREATED_DESC', 'Ordered by created_at in descending order.', value: :created_at_desc
      value 'TOKEN_EXPIRES_AT_ASC', 'Ordered by token_expires_at in ascending order.', value: :token_expires_at_asc
      value 'TOKEN_EXPIRES_AT_DESC', 'Ordered by token_expires_at in descending order.', value: :token_expires_at_desc
    end
  end
end

Types::Ci::RunnerSortEnum.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerStatusEnum < BaseEnum
      graphql_name 'CiRunnerStatus'

      value 'ONLINE',
        description: "Runner that contacted this instance within the last #{::Ci::Runner::ONLINE_CONTACT_TIMEOUT.inspect}.",
        value: :online

      value 'OFFLINE',
        description: "Runner that has not contacted this instance within the " \
          "last #{::Ci::Runner::ONLINE_CONTACT_TIMEOUT.inspect}. Will be considered `STALE` if offline for " \
          "more than #{::Ci::Runner::STALE_TIMEOUT.inspect}.",
        value: :offline

      value 'STALE',
        description: "Runner that has not contacted this instance within the last #{::Ci::Runner::STALE_TIMEOUT.inspect}.",
        value: :stale

      value 'NEVER_CONTACTED',
        description: 'Runner that has never contacted the instance.',
        value: :never_contacted
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerTypeEnum < BaseEnum
      graphql_name 'CiRunnerType'

      ::Ci::Runner::AVAILABLE_TYPES.each do |runner_type|
        value runner_type.upcase,
          description: "A runner that is #{runner_type.tr('_', ' ')}.",
          value: runner_type
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerType < BaseObject
      graphql_name 'CiRunner'

      edge_type_class(RunnerWebUrlEdge)
      connection_type_class RunnerCountableConnectionType

      authorize :read_runner
      present_using ::Ci::RunnerPresenter
      expose_permissions Types::PermissionTypes::Ci::Runner

      JOB_COUNT_LIMIT = 1000

      alias_method :runner, :object

      # NOTE: instance runners are exposed by default to any authenticated user,
      # remember to protect any sensitive fields
      field :access_level, ::Types::Ci::RunnerAccessLevelEnum, null: false,
        description: 'Access level of the runner.'
      field :active, GraphQL::Types::Boolean, null: false,
        description: "Indicates the runner is allowed to receive jobs.",
        deprecated: {
          reason: 'Use `paused`. ' \
            "This field is the inverse of `paused` and has no relationship to the runner's job execution status. " \
            "For more details, see `jobExecutionStatus`",
          milestone: '14.8'
        }
      field :admin_url, GraphQL::Types::String, null: true,
        description: 'Admin URL of the runner. Only available for administrators.'
      field :contacted_at, Types::TimeType, null: true,
        description: 'Timestamp of last contact from the runner.'
      field :created_at, Types::TimeType, null: true,
        description: 'Timestamp of creation of the runner.'
      field :created_by, Types::UserType, null: true,
        description: 'User that created the runner.',
        method: :creator
      field :creation_method, Types::Ci::RunnerCreationMethodEnum, null: true,
        method: :registration_type,
        description: 'Type of runner registration.',
        experiment: { milestone: '17.0' }
      field :creation_state, Types::Ci::RunnerCreationStateEnum, null: true,
        description: 'Runner creation state. Used to determine if a runner has been registered ' \
          'and has contacted the GitLab instance.'
      field :description, GraphQL::Types::String, null: true,
        description: 'Description of the runner.'
      field :edit_admin_url, GraphQL::Types::String, null: true,
        description: 'Admin form URL of the runner. Only available for administrators.'
      field :ephemeral_authentication_token, GraphQL::Types::String, null: true,
        description: 'Ephemeral authentication token used for runner manager registration. Only available for the creator of the runner for a limited time during registration.',
        authorize: :read_ephemeral_token,
        experiment: { milestone: '15.9' }
      field :ephemeral_register_url, GraphQL::Types::String, null: true,
        description: 'URL of the registration page of the runner manager. Only available for the creator of the runner for a limited time during registration.',
        experiment: { milestone: '15.11' }
      field :groups, null: true,
        resolver: ::Resolvers::Ci::RunnerGroupsResolver,
        description: 'Groups the runner is associated with. For group runners only.'
      field :id, ::Types::GlobalIDType[::Ci::Runner], null: false, description: 'ID of the runner.'
      field :job_count, GraphQL::Types::Int, null: true,
        description: "Number of jobs processed by the runner (limited to #{JOB_COUNT_LIMIT}, plus one to " \
          "indicate that more items exist).\n`jobCount` is an optimized version of `jobs { count }`, " \
          "and can be requested for multiple runners on the same request.",
        resolver: ::Resolvers::Ci::RunnerJobCountResolver
      field :job_execution_status,
        Types::Ci::RunnerJobExecutionStatusEnum,
        null: true,
        description: 'Job execution status of the runner.'
      field :jobs, ::Types::Ci::JobInterface.connection_type, null: true,
        description: 'Jobs assigned to the runner. This field can only be resolved for one runner in any single request.',
        authorize: :read_builds,
        resolver: ::Resolvers::Ci::RunnerJobsResolver
      field :locked, GraphQL::Types::Boolean, null: true,
        description: 'Indicates the runner is locked.'
      field :maintenance_note, GraphQL::Types::String, null: true,
        description: 'Runner\'s maintenance notes.'
      field :managers, ::Types::Ci::RunnerManagerType.connection_type, null: true,
        description: 'Runner managers associated with the runner configuration.',
        resolver: Resolvers::Ci::RunnerManagersResolver
      field :maximum_timeout, GraphQL::Types::Int, null: true,
        description: 'Maximum timeout (in seconds) for jobs processed by the runner.'
      field :owner_project, ::Types::Projects::ProjectInterface, null: true,
        description: 'Project that owns the runner. For project runners only.',
        resolver: ::Resolvers::Ci::RunnerOwnerProjectResolver
      field :paused, GraphQL::Types::Boolean, null: false,
        description: 'Indicates the runner is paused and not available to run jobs.'
      field :project_count, GraphQL::Types::Int, null: true,
        description: 'Number of projects that the runner is associated with.'
      field :projects,
        ::Types::ProjectType.connection_type,
        null: true,
        resolver: ::Resolvers::Ci::RunnerProjectsResolver,
        description: 'Find projects the runner is associated with. For project runners only.'
      field :register_admin_url, GraphQL::Types::String, null: true,
        description: 'URL of the temporary registration page of the runner. Only available before the runner is registered. Only available for administrators.'
      field :run_untagged, GraphQL::Types::Boolean, null: false,
        description: 'Indicates the runner is able to run untagged jobs.'
      field :runner_type, ::Types::Ci::RunnerTypeEnum, null: false,
        description: 'Type of the runner.'
      field :short_sha, GraphQL::Types::String, null: true,
        description: %q(First eight characters of the runner's token used to authenticate new job requests. Used as the runner's unique ID.)
      field :status,
        Types::Ci::RunnerStatusEnum,
        null: false,
        description: 'Status of the runner.'
      field :tag_list, [GraphQL::Types::String], null: true,
        description: 'Tags associated with the runner.'
      field :token_expires_at, Types::TimeType, null: true,
        description: 'Runner token expiration time.',
        authorize: :read_runner_sensitive_data

      markdown_field :maintenance_note_html, null: true

      def maintenance_note_html_resolver
        ::MarkupHelper.markdown(object.maintenance_note, context.to_h.dup)
      end

      def admin_url
        Gitlab::Routing.url_helpers.admin_runner_url(runner) if can_read_all_runners?
      end

      def edit_admin_url
        Gitlab::Routing.url_helpers.edit_admin_runner_url(runner) if can_admin_all_runners?
      end

      def ephemeral_register_url
        return unless context[:current_user]&.can?(:read_ephemeral_token, runner) && runner.registration_available?

        case runner.runner_type
        when 'instance_type'
          Gitlab::Routing.url_helpers.register_admin_runner_url(runner)
        when 'group_type'
          Gitlab::Routing.url_helpers.register_group_runner_url(runner.groups[0], runner)
        when 'project_type'
          Gitlab::Routing.url_helpers.register_project_runner_url(runner.projects[0], runner)
        end
      end

      def register_admin_url
        return unless can_admin_all_runners? && runner.registration_available?

        Gitlab::Routing.url_helpers.register_admin_runner_url(runner)
      end

      def ephemeral_authentication_token
        runner.token if runner.registration_available?
      end

      def project_count
        BatchLoader::GraphQL.for(runner.id).batch(key: :runner_project_count) do |ids, loader, args|
          counts = ::Ci::Runner.project_type
            .select(:id, 'COUNT(ci_runner_projects.id) as count')
            .left_outer_joins(:runner_projects)
            .id_in(ids)
            .group(:id) # rubocop: disable CodeReuse/ActiveRecord
            .index_by(&:id)

          ids.each { |id| loader.call(id, counts[id]&.count) }
        end
      end

      def job_execution_status
        BatchLoader::GraphQL.for(runner.id).batch(key: :running_builds_exist) do |runner_ids, loader|
          statuses = ::Ci::Runner.id_in(runner_ids).with_executing_builds.index_by(&:id)

          runner_ids.each do |runner_id|
            loader.call(runner_id, statuses[runner_id] ? :active : :idle)
          end
        end
      end

      private

      def can_admin_all_runners?
        context[:current_user]&.can_admin_all_resources?
      end

      def can_read_all_runners?
        context[:current_user]&.can?(:read_admin_cicd)
      end
    end
  end
end

Types::Ci::RunnerType.prepend_mod_with('Types::Ci::RunnerType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_upgrade_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerUpgradeStatusEnum < BaseEnum
      graphql_name 'CiRunnerUpgradeStatus'

      MODEL_STATUS_TO_GRAPHQL_TRANSLATIONS = {
        invalid_version: :invalid,
        unavailable: :not_available
      }.freeze

      ::Ci::RunnerVersion::STATUS_DESCRIPTIONS.each do |status, description|
        status_name_src = MODEL_STATUS_TO_GRAPHQL_TRANSLATIONS.fetch(status, status)

        value status_name_src.to_s.upcase, description: description, value: status
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/runner_web_url_edge.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class RunnerWebUrlEdge < ::Types::BaseEdge
      field :edit_url, GraphQL::Types::String, null: true,
        description: 'Web URL of the runner edit page. The value depends on where you put the field in the query. ' \
          'You can use it for projects or groups.',
        extras: [:parent]
      field :web_url, GraphQL::Types::String, null: true,
        description: 'Web URL of the runner. The value depends on where you put the field in the query. ' \
          'You can use it for projects or groups.',
        extras: [:parent]

      def initialize(node, connection)
        super

        @runner = node.node
      end

      # here parent is a Keyset::Connection
      def edit_url(parent:)
        runner_url(owner: parent.parent, url_type: :edit_url)
      end

      def web_url(parent:)
        runner_url(owner: parent.parent, url_type: :default)
      end

      private

      def runner_url(owner:, url_type: :default)
        case owner
        when ::Group
          return Gitlab::Routing.url_helpers.edit_group_runner_url(owner, @runner) if url_type == :edit_url

          Gitlab::Routing.url_helpers.group_runner_url(owner, @runner)
        when ::Project
          return Gitlab::Routing.url_helpers.edit_project_runner_url(owner, @runner) if url_type == :edit_url

          Gitlab::Routing.url_helpers.project_runner_url(owner, @runner)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/stage_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class StageType < BaseObject
      graphql_name 'CiStage'
      authorize :read_build

      field :detailed_status, Types::Ci::DetailedStatusType, null: true,
        description: 'Detailed status of the stage.'
      field :groups, type: Ci::GroupType.connection_type, null: true,
        extras: [:lookahead],
        description: 'Group of jobs for the stage.'
      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the stage.'
      field :jobs, Types::Ci::JobType.connection_type, null: true,
        description: 'Jobs for the stage.'
      field :name, type: GraphQL::Types::String, null: true,
        description: 'Name of the stage.'
      field :status, GraphQL::Types::String,
        null: true,
        description: 'Status of the pipeline stage.'

      def detailed_status
        object.detailed_status(current_user)
      end

      # Issues one query per pipeline
      def groups(lookahead:)
        key = ::Gitlab::Graphql::BatchKey.new(object, lookahead, object_name: :stage)

        BatchLoader::GraphQL.for(key).batch(default_value: []) do |keys, loader|
          by_pipeline = keys.group_by(&:pipeline)
          include_needs = keys.any? do |k|
            k.requires?(%i[nodes jobs nodes needs]) ||
              k.requires?(%i[nodes jobs nodes previousStageJobsOrNeeds])
          end

          by_pipeline.each do |pl, key_group|
            project = pl.project
            indexed = key_group.index_by(&:id)

            jobs_for_pipeline(pl, indexed.keys, include_needs).each do |stage_id, statuses|
              key = indexed[stage_id]
              groups = ::Ci::Group.fabricate(project, key.stage, statuses)

              loader.call(key, groups)
            end
          end
        end
      end

      def jobs
        GraphQL::Pagination::ActiveRecordRelationConnection.new(
          object.ordered_latest_statuses,
          max_page_size: Gitlab::CurrentSettings.current_application_settings.jobs_per_stage_page_size
        )
      end

      private

      # rubocop: disable CodeReuse/ActiveRecord
      def jobs_for_pipeline(pipeline, stage_ids, include_needs)
        jobs = pipeline.statuses.latest.where(stage_id: stage_ids)

        preloaded_relations = [:project, :metadata, :job_definition, :job_artifacts, :downstream_pipeline]
        preloaded_relations << :needs if include_needs

        Preloaders::CommitStatusPreloader.new(jobs).execute(preloaded_relations)

        jobs.group_by(&:stage_id)
      end
      # rubocop: enable CodeReuse/ActiveRecord
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/status_action_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class StatusActionType < BaseObject
      graphql_name 'StatusAction'

      field :button_title, GraphQL::Types::String, null: true,
        description: 'Title for the button, for example: Retry the job.'
      field :confirmation_message, GraphQL::Types::String, null: true,
        description: 'Custom confirmation message for a manual job.',
        experiment: { milestone: '17.0' }
      field :icon, GraphQL::Types::String, null: true,
        description: 'Icon used in the action button.'
      field :id, GraphQL::Types::String, null: false,
        description: 'ID for a status action.',
        extras: [:parent]
      field :method, GraphQL::Types::String, null: true,
        description: 'Method for the action, for example: :post.',
        resolver_method: :action_method
      field :path, GraphQL::Types::String, null: true,
        description: 'Path for the action.'
      field :title, GraphQL::Types::String, null: true,
        description: 'Title for the action, for example: Retry.'

      def id(parent:)
        # parent is a SimpleDelegator
        "#{parent.subject.class.name}-#{parent.id}"
      end

      def action_method
        object[:method]
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/template_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class TemplateType < BaseObject
      graphql_name 'CiTemplate'
      description 'GitLab CI/CD configuration template.'

      field :content, GraphQL::Types::String, null: false,
        description: 'Contents of the CI template.'
      field :name, GraphQL::Types::String, null: false,
        description: 'Name of the CI template.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/test_case_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class TestCaseStatusEnum < BaseEnum
      graphql_name 'TestCaseStatus'

      ::Gitlab::Ci::Reports::TestCase::STATUS_TYPES.each do |status|
        value status,
          description: "Test case that has a status of #{status}.",
          value: status
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/test_case_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class TestCaseType < BaseObject
      graphql_name 'TestCase'
      description 'Test case in pipeline test report.'

      connection_type_class Types::CountableConnectionType

      field :status,
        Types::Ci::TestCaseStatusEnum,
        null: true,
        description: "Status of the test case (#{::Gitlab::Ci::Reports::TestCase::STATUS_TYPES.join(', ')})."

      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the test case.'

      field :classname, GraphQL::Types::String, null: true,
        description: 'Classname of the test case.'

      field :execution_time, GraphQL::Types::Float, null: true,
        description: 'Test case execution time in seconds.'

      field :file, GraphQL::Types::String, null: true,
        description: 'Path to the file of the test case.'

      field :attachment_url, GraphQL::Types::String, null: true,
        description: 'URL of the test case attachment file.'

      field :system_output, GraphQL::Types::String, null: true,
        description: 'System output of the test case.'

      field :stack_trace, GraphQL::Types::String, null: true,
        description: 'Stack trace of the test case.'

      field :recent_failures,
        Types::Ci::RecentFailuresType,
        null: true,
        description: 'Recent failure history of the test case on the base branch.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/test_report_summary_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `PipelineType` that has its own authorization
    class TestReportSummaryType < BaseObject
      graphql_name 'TestReportSummary'
      description 'Test report for a pipeline'

      field :total, Types::Ci::TestReportTotalType, null: false,
        description: 'Total report statistics for a pipeline test report.'

      field :test_suites,
        Types::Ci::TestSuiteSummaryType.connection_type,
        null: false,
        description: 'Test suites belonging to a pipeline test report.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/test_report_total_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class TestReportTotalType < BaseObject
      graphql_name 'TestReportTotal'
      description 'Total test report statistics.'

      field :time, GraphQL::Types::Float, null: true,
        description: 'Total duration of the tests.'

      field :count, GraphQL::Types::Int, null: true,
        description: 'Total number of the test cases.'

      field :success, GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that succeeded.'

      field :failed, GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that failed.'

      field :skipped, GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that were skipped.'

      field :error, GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that had an error.'

      field :suite_error, GraphQL::Types::String, null: true,
        description: 'Test suite error message.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/test_suite_summary_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class TestSuiteSummaryType < BaseObject
      graphql_name 'TestSuiteSummary'
      description 'Test suite summary in a pipeline test report.'

      connection_type_class Types::CountableConnectionType

      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the test suite.'

      field :total_time, GraphQL::Types::Float, null: true,
        description: 'Total duration of the tests in the test suite.'

      field :total_count, GraphQL::Types::Int, null: true,
        description: 'Total number of the test cases in the test suite.'

      field :success_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of test cases that succeeded in the test suite.'

      field :failed_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of test cases that failed in the test suite.'

      field :skipped_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of test cases that were skipped in the test suite.'

      field :error_count, GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that had an error.'

      field :suite_error, GraphQL::Types::String, null: true,
        description: 'Test suite error message.'

      field :build_ids, [GraphQL::Types::ID], null: true,
        description: 'IDs of the builds used to run the test suite.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/test_suite_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    # rubocop: disable Graphql/AuthorizeTypes
    class TestSuiteType < BaseObject
      graphql_name 'TestSuite'
      description 'Test suite in a pipeline test report.'

      connection_type_class Types::CountableConnectionType

      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the test suite.'

      field :total_time, GraphQL::Types::Float, null: true,
        description: 'Total duration of the tests in the test suite.'

      field :total_count, GraphQL::Types::Int, null: true,
        description: 'Total number of the test cases in the test suite.'

      field :success_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of test cases that succeeded in the test suite.'

      field :failed_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Total number of test cases that failed in the test suite.'

      field :skipped_count,
        GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that were skipped in the test suite.'

      field :error_count, GraphQL::Types::Int, null: true,
        description: 'Total number of test cases that had an error.'

      field :suite_error, GraphQL::Types::String, null: true,
        description: 'Test suite error message.'

      field :test_cases, Types::Ci::TestCaseType.connection_type, null: true,
        description: 'Test cases in the test suite.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/variable_input_type.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class VariableInputType < BaseInputObject
      graphql_name 'CiVariableInput'
      description 'Attributes for defining a CI/CD variable.'

      argument :key, GraphQL::Types::String, description: 'Name of the variable.'
      argument :value, GraphQL::Types::String, description: 'Value of the variable.'
      argument :variable_type, Types::Ci::VariableTypeEnum, description: 'Type of variable.', required: false
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/variable_interface.rb =====
# frozen_string_literal: true

module Types
  module Ci
    module VariableInterface
      include Types::BaseInterface

      graphql_name 'CiVariable'

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the variable.'

      field :key, GraphQL::Types::String,
        null: true,
        description: 'Name of the variable.'

      field :raw, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the variable is raw.'

      field :value, GraphQL::Types::String,
        null: true,
        description: 'Value of the variable.'

      field :variable_type, ::Types::Ci::VariableTypeEnum,
        null: true,
        description: 'Type of the variable.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/variable_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class VariableSortEnum < BaseEnum
      graphql_name 'CiVariableSort'
      description 'Values for sorting variables'

      value 'KEY_ASC', 'Sorted by key in ascending order.', value: :key_asc
      value 'KEY_DESC', 'Sorted by key in descending order.', value: :key_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ci/variable_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Ci
    class VariableTypeEnum < BaseEnum
      graphql_name 'CiVariableType'

      ::Ci::Variable.variable_types.keys.each do |variable_type|
        value variable_type.upcase, value: variable_type, description: "#{variable_type.humanize} type."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/clusters/agent_activity_event_type.rb =====
# frozen_string_literal: true

module Types
  module Clusters
    class AgentActivityEventType < BaseObject
      graphql_name 'ClusterAgentActivityEvent'

      authorize :read_cluster_agent

      connection_type_class Types::CountableConnectionType

      field :recorded_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the event was recorded.'

      field :kind,
        GraphQL::Types::String,
        null: true,
        description: 'Type of event.'

      field :level,
        GraphQL::Types::String,
        null: true,
        description: 'Severity of the event.'

      field :user,
        Types::UserType,
        null: true,
        description: 'User associated with the event.'

      field :agent_token,
        Types::Clusters::AgentTokenType,
        null: true,
        description: 'Agent token associated with the event.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/clusters/agents/authorizations/ci_access_type.rb =====
# frozen_string_literal: true

module Types
  module Clusters
    module Agents
      module Authorizations
        class CiAccessType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
          graphql_name 'ClusterAgentAuthorizationCiAccess'

          field :agent, Types::Clusters::AgentType,
            description: 'Authorized cluster agent.',
            null: true

          field :config, GraphQL::Types::JSON, # rubocop:disable Graphql/JSONType
            description: 'Configuration for the authorized project.',
            null: true
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/clusters/agents/authorizations/user_access_type.rb =====
# frozen_string_literal: true

module Types
  module Clusters
    module Agents
      module Authorizations
        class UserAccessType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
          graphql_name 'ClusterAgentAuthorizationUserAccess'

          field :agent, Types::Clusters::AgentType,
            description: 'Authorized cluster agent.',
            null: true

          field :config, GraphQL::Types::JSON, # rubocop:disable Graphql/JSONType
            description: 'Configuration for the authorized project.',
            null: true
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/clusters/agent_token_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Clusters
    class AgentTokenStatusEnum < BaseEnum
      graphql_name 'AgentTokenStatus'
      description 'Agent token statuses'

      ::Clusters::AgentToken.statuses.keys.each do |status|
        value status.upcase, value: status, description: "#{status.titleize} agent token."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/clusters/agent_token_type.rb =====
# frozen_string_literal: true

module Types
  module Clusters
    class AgentTokenType < BaseObject
      graphql_name 'ClusterAgentToken'

      authorize :read_cluster_agent

      connection_type_class Types::CountableConnectionType

      field :cluster_agent,
        Types::Clusters::AgentType,
        description: 'Cluster agent the token is associated with.',
        null: true

      field :created_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the token was created.'

      field :created_by_user,
        Types::UserType,
        null: true,
        description: 'User who created the token.'

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of the token.'

      field :last_used_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the token was last used.'

      field :id,
        ::Types::GlobalIDType[::Clusters::AgentToken],
        null: false,
        description: 'Global ID of the token.'

      field :name,
        GraphQL::Types::String,
        null: true,
        description: 'Name given to the token.'

      field :status,
        Types::Clusters::AgentTokenStatusEnum,
        null: true,
        description: 'Current status of the token.'

      def cluster_agent
        Gitlab::Graphql::Loaders::BatchModelLoader.new(::Clusters::Agent, object.agent_id).find
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/clusters/agent_type.rb =====
# frozen_string_literal: true

module Types
  module Clusters
    class AgentType < BaseObject
      graphql_name 'ClusterAgent'

      authorize :read_cluster_agent

      connection_type_class Types::CountableConnectionType

      field :created_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the cluster agent was created.'

      field :created_by_user,
        Types::UserType,
        null: true,
        description: 'User object, containing information about the person who created the agent.'

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the cluster agent.'

      field :name,
        GraphQL::Types::String,
        null: true,
        description: 'Name of the cluster agent.'

      field :project, Types::ProjectType,
        description: 'Project the cluster agent is associated with.',
        null: true,
        authorize: :read_project

      field :tokens,
        description: 'Tokens associated with the cluster agent.',
        null: true,
        resolver: ::Resolvers::Clusters::AgentTokensResolver

      field :updated_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the cluster agent was updated.'

      field :web_path,
        GraphQL::Types::String,
        null: true,
        description: 'Web path of the cluster agent.'

      field :connections,
        Types::Kas::AgentConnectionType.connection_type,
        null: true,
        description: 'Active connections for the cluster agent',
        complexity: 5,
        resolver: ::Resolvers::Kas::AgentConnectionsResolver

      field :activity_events,
        Types::Clusters::AgentActivityEventType.connection_type,
        null: true,
        description: 'Recent activity for the cluster agent.',
        resolver: Resolvers::Clusters::AgentActivityEventsResolver

      field :user_access_authorizations,
        Clusters::Agents::Authorizations::UserAccessType,
        null: true,
        description: 'User access config for the cluster agent.'

      def project
        Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
      end

      def web_path
        ::Gitlab::Routing.url_helpers.project_cluster_agent_path(object.project, object.name)
      end
    end
  end
end

Types::Clusters::AgentType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/color_type.rb =====
# frozen_string_literal: true

module Types
  class ColorType < BaseScalar
    graphql_name 'Color'
    description <<~DESC
      Color represented as a hex code or named color.

      For example: "#fefefe".
    DESC

    def self.coerce_input(value, ctx)
      color = Gitlab::Color.of(value)
      raise GraphQL::CoercionError, 'Not a color' unless color.valid?

      color
    rescue ArgumentError => e
      raise GraphQL::CoercionError, e.message
    end

    def self.coerce_result(value, ctx)
      value.to_s
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_action_mode_enum.rb =====
# frozen_string_literal: true

module Types
  class CommitActionModeEnum < BaseEnum
    graphql_name 'CommitActionMode'
    description 'Mode of a commit action'

    value 'CREATE', description: 'Create command.', value: :create
    value 'DELETE', description: 'Delete command.', value: :delete
    value 'MOVE', description: 'Move command.', value: :move
    value 'UPDATE', description: 'Update command.', value: :update
    value 'CHMOD', description: 'Chmod command.', value: :chmod
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_action_type.rb =====
# frozen_string_literal: true

module Types
  class CommitActionType < BaseInputObject
    argument :action, type: Types::CommitActionModeEnum, required: true,
      description: 'Action to perform: create, delete, move, update, or chmod.'
    argument :content, type: GraphQL::Types::String, required: false,
      description: 'Content of the file.'
    argument :encoding, type: Types::CommitEncodingEnum, required: false,
      description: 'Encoding of the file. Default is text.'
    argument :execute_filemode, type: GraphQL::Types::Boolean, required: false,
      description: 'Enables/disables the execute flag on the file.'
    argument :file_path, type: GraphQL::Types::String, required: true,
      description: 'Full path to the file.'
    argument :last_commit_id, type: GraphQL::Types::String, required: false,
      description: 'Last known file commit ID.'
    argument :previous_path, type: GraphQL::Types::String, required: false,
      description: 'Original full path to the file being moved.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_encoding_enum.rb =====
# frozen_string_literal: true

module Types
  class CommitEncodingEnum < BaseEnum
    graphql_name 'CommitEncoding'

    value 'TEXT', description: 'Text encoding.', value: :text
    value 'BASE64', description: 'Base64 encoding.', value: :base64
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_references_type.rb =====
# frozen_string_literal: true

module Types
  class CommitReferencesType < BaseObject
    graphql_name 'CommitReferences'

    authorize :read_commit

    def self.field_for_tipping_refs(field_name, field_description)
      field field_name, ::Types::Projects::CommitParentNamesType,
        null: true,
        calls_gitaly: true,
        description: field_description do
          argument :limit, GraphQL::Types::Int,
            required: true,
            default_value: 100,
            description: 'Number of ref names to return.',
            validates: { numericality: { within: 1..1000 } }
        end
    end

    def self.field_for_containing_refs(field_name, field_description)
      field field_name, ::Types::Projects::CommitParentNamesType,
        null: true,
        calls_gitaly: true,
        description: field_description do
        argument :exclude_tipped, GraphQL::Types::Boolean,
          required: true,
          default_value: false,
          description: 'Exclude tipping refs. WARNING: This argument can be confusing, if there is a limit.
          for example set the limit to 5 and in the 5 out a total of 25 refs there is 2 tipped refs,
          then the method will only 3 refs, even though there is more.'
        # rubocop: disable GraphQL/ArgumentUniqueness
        argument :limit, GraphQL::Types::Int,
          required: true,
          default_value: 100,
          description: 'Number of ref names to return.',
          validates: { numericality: { within: 1..1000 } }
        # rubocop: enable GraphQL/ArgumentUniqueness
      end
    end

    field_for_tipping_refs :tipping_tags, "Get tag names tipping at a given commit."

    field_for_tipping_refs :tipping_branches, "Get branch names tipping at a given commit."

    field_for_containing_refs :containing_tags, "Get tag names containing a given commit."

    field_for_containing_refs :containing_branches, "Get branch names containing a given commit."

    def tipping_tags(limit:)
      { names: object.tipping_tags(limit: limit) }
    end

    def tipping_branches(limit:)
      { names: object.tipping_branches(limit: limit) }
    end

    def containing_tags(limit:, exclude_tipped:)
      { names: object.tags_containing(limit: limit, exclude_tipped: exclude_tipped) }
    end

    def containing_branches(limit:, exclude_tipped:)
      { names: object.branches_containing(limit: limit, exclude_tipped: exclude_tipped) }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_signature_interface.rb =====
# frozen_string_literal: true

module Types
  module CommitSignatureInterface
    include Types::BaseInterface

    graphql_name 'CommitSignature'

    description 'Represents signing information for a commit'

    field :verification_status, CommitSignatures::VerificationStatusEnum,
      null: true,
      description: 'Indicates verification status of the associated key or certificate.',
      calls_gitaly: true

    field :commit_sha, GraphQL::Types::String,
      null: true,
      description: 'SHA of the associated commit.'

    field :project, Types::ProjectType,
      null: true,
      description: 'Project of the associated commit.'

    orphan_types Types::CommitSignatures::GpgSignatureType,
      Types::CommitSignatures::X509SignatureType,
      Types::CommitSignatures::SshSignatureType

    def self.resolve_type(object, context)
      case object
      when ::CommitSignatures::GpgSignature
        Types::CommitSignatures::GpgSignatureType
      when ::CommitSignatures::X509CommitSignature
        Types::CommitSignatures::X509SignatureType
      when ::CommitSignatures::SshSignature
        Types::CommitSignatures::SshSignatureType
      else
        raise 'Unsupported commit signature type'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_signatures/gpg_signature_type.rb =====
# frozen_string_literal: true

module Types
  module CommitSignatures
    class GpgSignatureType < Types::BaseObject
      graphql_name 'GpgSignature'
      description 'GPG signature for a signed commit'

      implements Types::CommitSignatureInterface

      authorize :download_code

      field :user, Types::UserType, null: true,
        method: :signed_by_user,
        description: 'User associated with the key.'

      field :gpg_key_user_name, GraphQL::Types::String,
        null: true,
        description: 'User name associated with the GPG key.'

      field :gpg_key_user_email, GraphQL::Types::String,
        null: true,
        description: 'User email associated with the GPG key.'

      field :gpg_key_primary_keyid, GraphQL::Types::String,
        null: true,
        description: 'ID of the GPG key.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_signatures/ssh_signature_type.rb =====
# frozen_string_literal: true

module Types
  module CommitSignatures
    class SshSignatureType < Types::BaseObject
      graphql_name 'SshSignature'
      description 'SSH signature for a signed commit'

      implements Types::CommitSignatureInterface

      authorize :download_code

      field :user, Types::UserType,
        null: true,
        method: :signed_by_user,
        calls_gitaly: true,
        description: 'User associated with the key.'

      field :key, Types::KeyType,
        null: true,
        description: 'SSH key used for the signature.'

      field :key_fingerprint_sha256, String,
        null: true,
        description: 'Fingerprint of the key.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_signatures/verification_status_enum.rb =====
# frozen_string_literal: true

module Types
  module CommitSignatures
    class VerificationStatusEnum < BaseEnum
      graphql_name 'VerificationStatus'
      description 'Verification status of a GPG, X.509 or SSH signature for a commit.'

      ::Enums::CommitSignature.verification_statuses.each_key do |status|
        value status.to_s.upcase, value: status.to_s, description: "#{status} verification status."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/commit_signatures/x509_signature_type.rb =====
# frozen_string_literal: true

module Types
  module CommitSignatures
    class X509SignatureType < Types::BaseObject
      graphql_name 'X509Signature'
      description 'X.509 signature for a signed commit'

      implements Types::CommitSignatureInterface

      authorize :download_code

      field :user, Types::UserType, null: true,
        method: :signed_by_user,
        calls_gitaly: true,
        description: 'User associated with the key.'

      field :x509_certificate, Types::X509CertificateType,
        null: true,
        description: 'Certificate used for the signature.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_expiration_policy_cadence_enum.rb =====
# frozen_string_literal: true

module Types
  class ContainerExpirationPolicyCadenceEnum < BaseEnum
    OPTIONS_MAPPING = {
      '1d': 'EVERY_DAY',
      '7d': 'EVERY_WEEK',
      '14d': 'EVERY_TWO_WEEKS',
      '1month': 'EVERY_MONTH',
      '3month': 'EVERY_THREE_MONTHS'
    }.freeze

    ::ContainerExpirationPolicy.cadence_options.each do |option, description|
      value OPTIONS_MAPPING[option], description: description, value: option.to_s
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_expiration_policy_keep_enum.rb =====
# frozen_string_literal: true

module Types
  class ContainerExpirationPolicyKeepEnum < BaseEnum
    OPTIONS_MAPPING = {
      1 => 'ONE_TAG',
      5 => 'FIVE_TAGS',
      10 => 'TEN_TAGS',
      25 => 'TWENTY_FIVE_TAGS',
      50 => 'FIFTY_TAGS',
      100 => 'ONE_HUNDRED_TAGS'
    }.freeze

    ::ContainerExpirationPolicy.keep_n_options.each do |option, description|
      value OPTIONS_MAPPING[option], description: description, value: option
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_expiration_policy_older_than_enum.rb =====
# frozen_string_literal: true

module Types
  class ContainerExpirationPolicyOlderThanEnum < BaseEnum
    OPTIONS_MAPPING = {
      '7d': 'SEVEN_DAYS',
      '14d': 'FOURTEEN_DAYS',
      '30d': 'THIRTY_DAYS',
      '60d': 'SIXTY_DAYS',
      '90d': 'NINETY_DAYS'
    }.freeze

    ::ContainerExpirationPolicy.older_than_options.each do |option, description|
      value OPTIONS_MAPPING[option], description: description, value: option.to_s
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_expiration_policy_type.rb =====
# frozen_string_literal: true

module Types
  class ContainerExpirationPolicyType < BaseObject
    graphql_name 'ContainerExpirationPolicy'

    description 'A tag expiration policy designed to keep only the images that matter most'

    authorize :admin_container_image

    field :cadence, Types::ContainerExpirationPolicyCadenceEnum, null: false, description: 'This container expiration policy schedule.'
    field :created_at, Types::TimeType, null: false, description: 'Timestamp of when the container expiration policy was created.'
    field :enabled, GraphQL::Types::Boolean, null: false, description: 'Indicates whether the container expiration policy is enabled.'
    field :keep_n, Types::ContainerExpirationPolicyKeepEnum, null: true, description: 'Number of tags to retain.'
    field :name_regex, Types::UntrustedRegexp, null: true, description: 'Tags with names matching the regex pattern will expire.'
    field :name_regex_keep, Types::UntrustedRegexp, null: true, description: 'Tags with names matching the regex pattern will be preserved.'
    field :next_run_at, Types::TimeType, null: true, description: 'Next time that the container expiration policy will get executed.'
    field :older_than, Types::ContainerExpirationPolicyOlderThanEnum, null: true, description: 'Tags older than the given age will expire.'
    field :updated_at, Types::TimeType, null: false, description: 'Timestamp of when the container expiration policy was updated.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_cleanup_status_enum.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryCleanupStatusEnum < BaseEnum
      graphql_name 'ContainerRepositoryCleanupStatus'
      description 'Status of the tags cleanup of a container repository'

      value 'UNSCHEDULED', value: 'cleanup_unscheduled',
        description: 'Tags cleanup is not scheduled. This is the default state.'
      value 'SCHEDULED', value: 'cleanup_scheduled',
        description: 'Tags cleanup is scheduled and is going to be executed shortly.'
      value 'UNFINISHED', value: 'cleanup_unfinished',
        description: 'Tags cleanup has been partially executed. There are still remaining tags to delete.'
      value 'ONGOING', value: 'cleanup_ongoing', description: 'Tags cleanup is ongoing.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_details_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryDetailsType < Types::ContainerRegistry::ContainerRepositoryType # rubocop:disable Graphql/AuthorizeTypes -- authorization is inherited from the parent: ContainerRepositoryType
      graphql_name 'ContainerRepositoryDetails'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      description 'Details of a container repository'

      field :tags,
        Types::ContainerRegistry::ContainerRepositoryTagType.connection_type,
        null: true,
        description: 'Tags of the container repository.',
        max_page_size: 20,
        resolver: Resolvers::ContainerRepositoryTagsResolver,
        connection_extension: Gitlab::Graphql::Extensions::ExternallyPaginatedArrayExtension

      field :manifest, GraphQL::Types::String,
        null: true,
        description: 'An image manifest from the container repository.' do
        argument :reference, GraphQL::Types::String,
          required: true,
          description: 'Tag name or digest of the manifest.'
      end

      field :size,
        GraphQL::Types::Float,
        null: true,
        description:
          'Deduplicated size of the image repository in bytes. ' \
          'This is only available on GitLab.com for repositories created after `2021-11-04`.'

      field :last_published_at,
        Types::TimeType,
        null: true,
        description:
          'Timestamp when a repository tag was last created or updated. ' \
          'Only present for repositories that had tags created or updated after GitLab 16.11.'

      def size
        handling_errors { object.size }
      end

      def last_published_at
        handling_errors { object.last_published_at }
      end

      def manifest(reference:)
        handling_errors do
          manifest = object.image_manifest(reference)
          manifest.as_json if manifest
        end
      end

      private

      def handling_errors
        yield
      rescue Faraday::Error
        raise_resource_not_available_error!(
          "Can't connect to the container registry. " \
            'If this error persists, please review the troubleshooting documentation.'
        )
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_referrer_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryReferrerType < BaseObject
      graphql_name 'ContainerRepositoryReferrer'

      description 'A referrer for a container repository tag'

      authorize :read_container_image

      expose_permissions Types::PermissionTypes::ContainerRepositoryTag

      field :artifact_type, GraphQL::Types::String, description: 'Artifact type of the referrer.'
      field :digest, GraphQL::Types::String, description: 'Digest of the referrer.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositorySortEnum < SortEnum
      graphql_name 'ContainerRepositorySort'
      description 'Values for sorting container repositories'

      value 'NAME_ASC', 'Name by ascending order.', value: :name_asc
      value 'NAME_DESC', 'Name by descending order.', value: :name_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_status_enum.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryStatusEnum < BaseEnum
      graphql_name 'ContainerRepositoryStatus'
      description 'Status of a container repository'

      ::ContainerRepository.statuses.each_key do |status|
        value status.upcase, value: status, description: "#{status.titleize} status."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_tags_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryTagsSortEnum < BaseEnum
      graphql_name 'ContainerRepositoryTagSort'
      description 'Values for sorting tags'

      value 'NAME_ASC', 'Ordered by name in ascending order.', value: :name_asc
      value 'NAME_DESC', 'Ordered by name in descending order.', value: :name_desc
      value 'PUBLISHED_AT_ASC',
        'Ordered by published_at in ascending order. Only available for GitLab.com.', value: :published_at_asc
      value 'PUBLISHED_AT_DESC',
        'Ordered by published_at in descending order. Only available for GitLab.com.', value: :published_at_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_tag_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryTagType < BaseObject
      graphql_name 'ContainerRepositoryTag'

      description 'A tag from a container repository'

      authorize :read_container_image

      expose_permissions Types::PermissionTypes::ContainerRepositoryTag

      field :created_at, Types::TimeType, null: true, description: 'Timestamp when the tag was created.'
      field :digest, GraphQL::Types::String, null: true, description: 'Digest of the tag.'
      field :location, GraphQL::Types::String, null: false, description: 'URL of the tag.'
      field :media_type, GraphQL::Types::String, null: true, description: 'Media type of the tag.'
      field :name, GraphQL::Types::String, null: false, description: 'Name of the tag.'
      field :path, GraphQL::Types::String, null: false, description: 'Path of the tag.'
      field :published_at, Types::TimeType, null: true, description: 'Timestamp when the tag was published.'
      field :referrers, [Types::ContainerRegistry::ContainerRepositoryReferrerType], null: true,
        description: 'Referrers for the tag.'
      field :revision, GraphQL::Types::String, null: true, description: 'Revision of the tag.'
      field :short_revision, GraphQL::Types::String, null: true, description: 'Short revision of the tag.'
      field :total_size, GraphQL::Types::BigInt, null: true, description: 'Size of the tag.'

      field :protection,
        Types::ContainerRegistry::Protection::AccessLevelType,
        null: true,
        experiment: { milestone: '17.9' },
        method: :protection_rule,
        description: 'Minimum GitLab access level required to push and delete container image tags. ' \
          'If the value is `nil`, no minimum access level is enforced. ' \
          'Users with the Developer role or higher can push tags by default.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_repository_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerRepositoryType < BaseObject
      graphql_name 'ContainerRepository'

      include Gitlab::Graphql::Authorize::AuthorizeResource

      PROTECTION_RULE_EXISTS_BATCH_SIZE = 20

      description 'A container repository'

      authorize :read_container_image

      expose_permissions Types::PermissionTypes::ContainerRepository

      field :created_at, Types::TimeType, null: false,
        description: 'Timestamp when the container repository was created.'
      field :expiration_policy_cleanup_status, Types::ContainerRegistry::ContainerRepositoryCleanupStatusEnum,
        null: true,
        description: 'Tags cleanup status for the container repository.'
      field :expiration_policy_started_at, Types::TimeType, null: true, # rubocop:disable GraphQL/ExtractType -- maintain current type
        description: 'Timestamp when the cleanup done by the expiration policy was started on the container repository.'
      field :id, GraphQL::Types::ID, null: false, description: 'ID of the container repository.'
      field :last_cleanup_deleted_tags_count, GraphQL::Types::Int, null: true,
        description: 'Number of deleted tags from the last cleanup.'
      field :location, GraphQL::Types::String, null: false, description: 'URL of the container repository.'
      field :migration_state, GraphQL::Types::String,
        null: false,
        description: 'Migration state of the container repository.',
        deprecated: {
          reason:
            'Returns an empty string. This was used for the migration of GitLab.com, which is now complete. ' \
            'Not used by Self-managed instances',
          milestone: '17.0'
        }
      field :name, GraphQL::Types::String, null: false, description: 'Name of the container repository.'
      field :path, GraphQL::Types::String, null: false, description: 'Path of the container repository.'
      field :project, Types::ProjectType, null: false, description: 'Project of the container registry.'
      field :protection_rule_exists, GraphQL::Types::Boolean,
        null: false,
        description:
          'Whether any matching container protection rule exists for the container repository.'
      field :status, Types::ContainerRegistry::ContainerRepositoryStatusEnum, null: true,
        description: 'Status of the container repository.'
      field :tags_count, GraphQL::Types::Int, null: false, description: 'Number of tags associated with the image.'
      field :updated_at, Types::TimeType, null: false,
        description: 'Timestamp when the container repository was updated.'

      def project
        Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
      end

      def tags_count
        object.tags_count
      rescue Faraday::Error
        raise_resource_not_available_error!(
          'We are having trouble connecting to the container registry. ' \
            'If this error persists, please review the troubleshooting documentation.'
        )
      end

      # The migration has now completed and we are cleaning up the migration db columns.
      # For backward compatibility, we are keeping this field accessible.
      # This field will be removed in 18.0.
      def migration_state
        ''
      end

      def protection_rule_exists
        BatchLoader::GraphQL.for([object.project_id, object.path]).batch do |tuples, loader|
          tuples.each_slice(PROTECTION_RULE_EXISTS_BATCH_SIZE) do |projects_and_repository_paths|
            ::ContainerRegistry::Protection::Rule
              .for_push_exists_for_projects_and_repository_paths(projects_and_repository_paths)
              .each { |row| loader.call([row['project_id'], row['repository_path']], row['protected']) }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/container_tags_expiration_policy_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    class ContainerTagsExpirationPolicyType < BaseObject
      graphql_name 'ContainerTagsExpirationPolicy'

      description 'A tag expiration policy using regex patterns to control which images to keep or expire.'

      authorize :read_container_image

      field :cadence, Types::ContainerExpirationPolicyCadenceEnum,
        null: true,
        description: 'Schedule of the container expiration policy.',
        authorize: :admin_container_image

      field :created_at, Types::TimeType,
        null: true,
        description: 'Timestamp of when the container expiration policy was created.',
        authorize: :admin_container_image

      field :enabled, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates whether the container expiration policy is enabled.'

      field :keep_n, Types::ContainerExpirationPolicyKeepEnum,
        null: true,
        description: 'Number of tags to retain.',
        authorize: :admin_container_image

      field :name_regex, Types::UntrustedRegexp,
        null: true,
        description: 'Tags with names matching the regex pattern will expire.',
        authorize: :admin_container_image

      field :name_regex_keep, Types::UntrustedRegexp, # rubocop:disable GraphQL/ExtractType -- We don't want to extract this to a type, it's just a regex field
        null: true,
        description: 'Tags with names matching the regex pattern will be preserved.',
        authorize: :admin_container_image

      field :next_run_at, Types::TimeType,
        null: true,
        description: 'Next time that the container expiration policy will get executed.'

      field :older_than, Types::ContainerExpirationPolicyOlderThanEnum,
        null: true,
        description: 'Tags older than the given age will expire.',
        authorize: :admin_container_image

      field :updated_at, Types::TimeType,
        null: true,
        description: 'Timestamp of when the container expiration policy was updated.',
        authorize: :admin_container_image
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/protection/access_level_interface.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    module Protection
      module AccessLevelInterface
        include BaseInterface

        field :minimum_access_level_for_delete,
          Types::ContainerRegistry::Protection::TagRuleAccessLevelEnum,
          null: false,
          experiment: { milestone: '17.8' },
          description:
            'Minimum GitLab access level required to delete container image tags from the container repository. ' \
            'Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. '

        field :minimum_access_level_for_push,
          Types::ContainerRegistry::Protection::TagRuleAccessLevelEnum,
          null: false,
          experiment: { milestone: '17.8' },
          description:
            'Minimum GitLab access level required to push container image tags to the container repository. ' \
            'Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. '
      end
    end
  end
end

Types::ContainerRegistry::Protection::AccessLevelInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/protection/access_level_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    module Protection
      class AccessLevelType < ::Types::BaseObject # rubocop:disable Graphql/AuthorizeTypes -- it inherits the same authorization as the caller
        graphql_name 'ContainerProtectionAccessLevel'
        description 'Represents the most restrictive permissions for a container image tag'

        implements Types::ContainerRegistry::Protection::AccessLevelInterface
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/protection/rule_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    module Protection
      class RuleAccessLevelEnum < BaseEnum
        graphql_name 'ContainerProtectionRepositoryRuleAccessLevel'
        description 'Access level for a container repository protection rule resource'

        ::ContainerRegistry::Protection::Rule.minimum_access_level_for_pushes.each_key do |access_level_key|
          value access_level_key.upcase,
            value: access_level_key.to_s,
            description: "#{access_level_key.capitalize} access."
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/protection/rule_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    module Protection
      class RuleType < ::Types::BaseObject
        graphql_name 'ContainerProtectionRepositoryRule'
        description 'A container repository protection rule designed to prevent users with a certain ' \
          'access level or lower from altering the container registry.'

        authorize :admin_container_image

        field :id,
          ::Types::GlobalIDType[::ContainerRegistry::Protection::Rule],
          null: false,
          description: 'ID of the container repository protection rule.'

        field :repository_path_pattern,
          GraphQL::Types::String,
          null: false,
          description:
            'Container repository path pattern protected by the protection rule. ' \
            'Must start with the project’s full path. For example: `my-project/*-prod-*`. ' \
            'Wildcard character `*` is allowed anywhere after the project’s full path.'

        field :minimum_access_level_for_delete,
          Types::ContainerRegistry::Protection::RuleAccessLevelEnum,
          null: true,
          description:
            'Minimum GitLab access level required to delete container images from the container repository. ' \
            'Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. ' \
            'If the value is `nil`, the default minimum access level is `DEVELOPER`.'

        field :minimum_access_level_for_push,
          Types::ContainerRegistry::Protection::RuleAccessLevelEnum,
          null: true,
          description:
            'Minimum GitLab access level required to push container images to the container repository. ' \
            'Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. ' \
            'If the value is `nil`, the default minimum access level is `DEVELOPER`.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/protection/tag_rule_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    module Protection
      class TagRuleAccessLevelEnum < BaseEnum
        graphql_name 'ContainerProtectionTagRuleAccessLevel'
        description 'Access level of a container registry tag protection rule resource'

        ::ContainerRegistry::Protection::TagRule::ACCESS_LEVELS.each_key do |access_level_key|
          access_level_key = access_level_key.to_s

          value access_level_key.upcase,
            value: access_level_key,
            experiment: { milestone: '17.8' },
            description: "#{access_level_key.capitalize} access."
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/container_registry/protection/tag_rule_type.rb =====
# frozen_string_literal: true

module Types
  module ContainerRegistry
    module Protection
      class TagRuleType < ::Types::BaseObject
        graphql_name 'ContainerProtectionTagRule'
        description 'A container repository tag protection rule designed to prevent users with a certain ' \
          'access level or lower from altering the container registry.'

        implements Types::ContainerRegistry::Protection::AccessLevelInterface

        authorize :admin_container_image

        expose_permissions Types::PermissionTypes::ContainerRegistry::Protection::TagRule

        field :id,
          ::Types::GlobalIDType[::ContainerRegistry::Protection::TagRule],
          null: false,
          experiment: { milestone: '17.8' },
          description: 'ID of the container repository tag protection rule.'

        field :tag_name_pattern,
          GraphQL::Types::String,
          null: false,
          experiment: { milestone: '17.8' },
          description:
            'The pattern that matches container image tags to protect. ' \
            'For example, `v1.*`. Wildcard character `*` allowed.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/countable_connection_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class CountableConnectionType < GraphQL::Types::Relay::BaseConnection
    field :count, GraphQL::Types::Int, null: false,
      description: 'Total count of collection.'

    def count
      relation = object.items

      # sometimes relation is an Array
      relation = relation.without_order if relation.respond_to?(:reorder)

      if relation.try(:group_values).present?
        relation.size.keys.size
      else
        relation.size
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/current_user_todos.rb =====
# frozen_string_literal: true

# Interface to expose todos for the current_user on the `object`
module Types
  module CurrentUserTodos
    include BaseInterface

    field_class Types::BaseField

    field :current_user_todos, Types::TodoType.connection_type,
      description: 'To-do items for the current user.',
      null: false do
      argument :state, Types::TodoStateEnum,
        description: 'State of the to-do items.',
        required: false
    end

    def current_user_todos(state: nil)
      state ||= %i[done pending] # TodosFinder treats a `nil` state param as `pending`
      target_type_name = unpresented.try(:todoable_target_type_name) || unpresented.class.name
      key = [state, target_type_name]

      BatchLoader::GraphQL.for(unpresented).batch(default_value: [], key: key) do |targets, loader, args|
        state, klass_name = args[:key]

        targets_by_id = targets.index_by(&:id)
        ids = targets_by_id.keys

        results = TodosFinder.new(users: current_user, state: state, type: klass_name, target_id: ids).execute

        by_target_id = results.group_by(&:target_id)

        by_target_id.each do |target_id, todos|
          target = targets_by_id[target_id]
          todos.each { _1.target = target } # prevent extra loads
          loader.call(target, todos)
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/current_user_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop:disable Graphql/AuthorizeTypes -- This is not necessary because the superclass declares the authorization
  class CurrentUserType < ::Types::UserType
    graphql_name 'CurrentUser'
    description 'The currently authenticated GitLab user.'

    field :assignee_or_reviewer_merge_requests,
      resolver: Resolvers::MergeRequests::AssigneeOrReviewerMergeRequestsResolver,
      description: 'Merge requests the current user is an assignee or a reviewer of.' \
        'Ignored if `merge_request_dashboard` feature flag is disabled.',
      experiment: { milestone: '17.4' }

    field :recently_viewed_issues,
      resolver: Resolvers::Users::RecentlyViewedIssuesResolver,
      description: 'Most-recently viewed issues for the current user.',
      experiment: { milestone: '17.9' }

    field :recently_viewed_merge_requests,
      resolver: Resolvers::Users::RecentlyViewedMergeRequestsResolver,
      description: 'Most-recently viewed merge requests for the current user.',
      experiment: { milestone: '17.10' }

    field :recently_viewed_items, # rubocop:disable GraphQL/ExtractType -- This is the extract type
      [Types::Users::RecentlyViewedItemType],
      null: true,
      description: 'Most-recently viewed items for the current user.',
      resolver: Resolvers::Users::RecentlyViewedItemsResolver

    field :work_items,
      null: true,
      resolver: Resolvers::WorkItems::UserWorkItemsResolver,
      description: 'Find work items visible to the current user.',
      experiment: { milestone: '17.10' }

    field :work_item_preferences, # rubocop:disable GraphQL/ExtractType -- fields with different contexts
      resolver: ::Resolvers::WorkItems::UserPreferenceResolver,
      null: true,
      experiment: { milestone: '17.10' },
      description: 'User preferences for the given work item type and namespace.'

    field :activity,
      Users::ActivityStreamType,
      description: 'Recent user activity.',
      experiment: { milestone: '17.10' }

    field :runners,
      Types::Ci::RunnerType.connection_type,
      null: true,
      resolver: Resolvers::Ci::UserRunnersResolver,
      experiment: { milestone: '18.3' },
      description: 'List all runners the current user manages.'

    def activity
      object if Feature.enabled?(:activity_stream_graphql, current_user)
    end
  end
  # rubocop:enable Graphql/AuthorizeTypes
end

::Types::CurrentUserType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/custom_emoji_type.rb =====
# frozen_string_literal: true

module Types
  class CustomEmojiType < BaseObject
    graphql_name 'CustomEmoji'
    description 'A custom emoji uploaded by user'

    authorize :read_custom_emoji

    connection_type_class Types::CountableConnectionType

    expose_permissions Types::PermissionTypes::CustomEmoji

    field :id, ::Types::GlobalIDType[::CustomEmoji],
      null: false,
      description: 'ID of the emoji.'

    field :name, GraphQL::Types::String,
      null: false,
      description: 'Name of the emoji.'

    field :url, GraphQL::Types::String,
      null: false,
      description: 'Link to file of the emoji.'

    field :external, GraphQL::Types::Boolean,
      null: false,
      description: 'Whether the emoji is an external link.'

    field :created_at, Types::TimeType,
      null: false,
      description: 'Timestamp of when the custom emoji was created.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/contact_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class ContactSortEnum < SortEnum
      graphql_name 'ContactSort'
      description 'Values for sorting contacts'

      sortable_fields = ['First name', 'Last name', 'Email', 'Phone', 'Description', 'Organization']

      sortable_fields.each do |field|
        value "#{field.upcase.tr(' ', '_')}_ASC",
          value: { field: field.downcase.tr(' ', '_'), direction: :asc },
          description: "#{field} in ascending order."
        value "#{field.upcase.tr(' ', '_')}_DESC",
          value: { field: field.downcase.tr(' ', '_'), direction: :desc },
          description: "#{field} in descending order."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/contact_state_counts_type.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class ContactStateCountsType < Types::BaseObject
      graphql_name 'ContactStateCounts'
      description 'Represents the total number of contacts for the represented states.'

      authorize :read_crm_contact

      def self.available_contact_states
        @available_contact_states ||= ::CustomerRelations::Contact.states.keys.push('all')
      end

      available_contact_states.each do |state|
        field state,
          GraphQL::Types::Int,
          null: true,
          description: "Number of contacts with state `#{state.upcase}`"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/contact_state_enum.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class ContactStateEnum < BaseEnum
      graphql_name 'CustomerRelationsContactState'

      value 'all',
        description: "All available contacts.",
        value: :all

      value 'active',
        description: "Active contacts.",
        value: :active

      value 'inactive',
        description: "Inactive contacts.",
        value: :inactive
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/contact_type.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class ContactType < BaseObject
      graphql_name 'CustomerRelationsContact'

      authorize :read_crm_contact

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'Internal ID of the contact.'

      field :organization, Types::CustomerRelations::OrganizationType,
        null: true,
        description: "Organization of the contact."

      field :first_name,
        GraphQL::Types::String,
        null: false,
        description: 'First name of the contact.'

      field :last_name,
        GraphQL::Types::String,
        null: false,
        description: 'Last name of the contact.'

      field :phone,
        GraphQL::Types::String,
        null: true,
        description: 'Phone number of the contact.'

      field :email,
        GraphQL::Types::String,
        null: true,
        description: 'Email address of the contact.'

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of or notes for the contact.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the contact was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the contact was last updated.'

      field :active,
        GraphQL::Types::Boolean,
        null: false,
        description: 'State of the contact.', method: :active?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/organization_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class OrganizationSortEnum < SortEnum
      graphql_name 'OrganizationSort'
      description 'Values for sorting organizations'

      sortable_fields = ['Name', 'Description', 'Default Rate']

      sortable_fields.each do |field|
        value "#{field.upcase.tr(' ', '_')}_ASC",
          value: { field: field.downcase.tr(' ', '_'), direction: :asc },
          description: "#{field} in ascending order."
        value "#{field.upcase.tr(' ', '_')}_DESC",
          value: { field: field.downcase.tr(' ', '_'), direction: :desc },
          description: "#{field} in descending order."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/organization_state_counts_type.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    # `object` is a hash. Authorization is performed by OrganizationStateCountsResolver
    class OrganizationStateCountsType < Types::BaseObject # rubocop:disable Graphql/AuthorizeTypes
      graphql_name 'OrganizationStateCounts'
      description 'Represents the total number of organizations for the represented states.'

      AVAILABLE_STATES = ::CustomerRelations::Organization.states.keys.push('all').freeze

      AVAILABLE_STATES.each do |state|
        field state,
          GraphQL::Types::Int,
          null: true,
          description: "Number of organizations with state `#{state.upcase}`"
      end

      def all
        object.values.sum
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/organization_state_enum.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class OrganizationStateEnum < BaseEnum
      graphql_name 'CustomerRelationsOrganizationState'

      value 'all',
        description: "All available organizations.",
        value: :all

      value 'active',
        description: "Active organizations.",
        value: :active

      value 'inactive',
        description: "Inactive organizations.",
        value: :inactive
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/customer_relations/organization_type.rb =====
# frozen_string_literal: true

module Types
  module CustomerRelations
    class OrganizationType < BaseObject
      graphql_name 'CustomerRelationsOrganization'

      authorize :read_crm_organization

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'Internal ID of the organization.'

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the organization.'

      field :default_rate,
        GraphQL::Types::Float,
        null: true,
        description: 'Standard billing rate for the organization.'

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of or notes for the organization.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the organization was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the organization was last updated.'

      field :active,
        GraphQL::Types::Boolean,
        null: false,
        description: 'State of the organization.', method: :active?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/data_transfer/base_type.rb =====
# frozen_string_literal: true

module Types
  module DataTransfer
    class BaseType < BaseObject
      authorize

      field :egress_nodes, type: Types::DataTransfer::EgressNodeType.connection_type,
        description: 'Data nodes.',
        null: true # disallow null once data_transfer_monitoring feature flag is rolled-out! https://gitlab.com/gitlab-org/gitlab/-/issues/397693
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/data_transfer/egress_node_type.rb =====
# frozen_string_literal: true

module Types
  module DataTransfer
    class EgressNodeType < BaseObject
      authorize

      field :date, GraphQL::Types::String,
        description: 'First day of the node range. There is one node per month.',
        null: false

      field :total_egress, GraphQL::Types::BigInt,
        description: 'Total egress for that project in that period of time.',
        null: false

      field :repository_egress, GraphQL::Types::BigInt,
        description: 'Repository egress for that project in that period of time.',
        null: false

      field :artifacts_egress, GraphQL::Types::BigInt,
        description: 'Artifacts egress for that project in that period of time.',
        null: false

      field :packages_egress, GraphQL::Types::BigInt,
        description: 'Packages egress for that project in that period of time.',
        null: false

      field :registry_egress, GraphQL::Types::BigInt,
        description: 'Registry egress for that project in that period of time.',
        null: false
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/data_transfer/group_data_transfer_type.rb =====
# frozen_string_literal: true

module Types
  module DataTransfer
    class GroupDataTransferType < BaseType
      graphql_name 'GroupDataTransfer'
      authorize
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/data_transfer/project_data_transfer_type.rb =====
# frozen_string_literal: true

module Types
  module DataTransfer
    class ProjectDataTransferType < BaseType
      graphql_name 'ProjectDataTransfer'
      authorize

      field :total_egress, GraphQL::Types::BigInt,
        description: 'Total egress for that project in that period of time.',
        null: true, # disallow null once data_transfer_monitoring feature flag is rolled-out! https://gitlab.com/gitlab-org/gitlab/-/issues/397693
        extras: [:parent]

      def total_egress(parent:)
        return unless Feature.enabled?(:data_transfer_monitoring, parent.group)

        object[:egress_nodes].sum('repository_egress + artifacts_egress + packages_egress + registry_egress')
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/data_visualization_palette/color_enum.rb =====
# frozen_string_literal: true

module Types
  module DataVisualizationPalette
    class ColorEnum < BaseEnum
      graphql_name 'DataVisualizationColorEnum'
      description 'Color of the data visualization palette'

      Enums::DataVisualizationPalette.colors.keys.each do |unit|
        value unit.upcase, value: unit, description: "#{unit.to_s.titleize} color"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/data_visualization_palette/weight_enum.rb =====
# frozen_string_literal: true

module Types
  module DataVisualizationPalette
    class WeightEnum < BaseEnum
      graphql_name 'DataVisualizationWeightEnum'
      description 'Weight of the data visualization palette'

      ::Enums::DataVisualizationPalette.weights.keys.each do |unit|
        value "weight_#{unit}".upcase, value: unit, description: "#{unit.to_s.titleize} weight"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/date_type.rb =====
# frozen_string_literal: true

module Types
  class DateType < BaseScalar
    graphql_name 'Date'
    description 'Date represented in ISO 8601'

    def self.coerce_input(value, ctx)
      return if value.nil?

      Date.iso8601(value)
    rescue ArgumentError, TypeError => e
      raise GraphQL::CoercionError, e.message
    end

    def self.coerce_result(value, ctx)
      return if value.nil?

      value.to_date.iso8601
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/dependency_proxy/blob_type.rb =====
# frozen_string_literal: true

module Types
  class DependencyProxy::BlobType < BaseObject
    graphql_name 'DependencyProxyBlob'

    description 'Dependency proxy blob'

    authorize :read_dependency_proxy

    field :created_at, Types::TimeType, null: false, description: 'Date of creation.'
    field :file_name, GraphQL::Types::String, null: false, description: 'Name of the blob.'
    field :size, GraphQL::Types::String, null: false, description: 'Size of the blob file.'
    field :updated_at, Types::TimeType, null: false, description: 'Date of most recent update.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/dependency_proxy/group_setting_type.rb =====
# frozen_string_literal: true

module Types
  class DependencyProxy::GroupSettingType < BaseObject
    graphql_name 'DependencyProxySetting'

    description 'Group-level Dependency Proxy settings'

    authorize :admin_dependency_proxy

    field :enabled, GraphQL::Types::Boolean, null: false, description: 'Indicates whether the dependency proxy is enabled for the group.'
    field :identity, GraphQL::Types::String, null: true,
      description: 'Identity credential used to authenticate with Docker Hub when pulling images. ' \
        'Can be a username (for password or personal access token (PAT)) or organization name (for organization access token (OAT)).'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/dependency_proxy/image_ttl_group_policy_type.rb =====
# frozen_string_literal: true

module Types
  class DependencyProxy::ImageTtlGroupPolicyType < BaseObject
    graphql_name 'DependencyProxyImageTtlGroupPolicy'

    description 'Group-level Dependency Proxy TTL policy settings'

    authorize :admin_dependency_proxy

    field :created_at, Types::TimeType, null: true, description: 'Timestamp of creation.'
    field :enabled, GraphQL::Types::Boolean, null: false, description: 'Indicates whether the policy is enabled or disabled.'
    field :ttl, GraphQL::Types::Int, null: true, description: 'Number of days to retain a cached image file.'
    field :updated_at, Types::TimeType, null: true, description: 'Timestamp of the most recent update.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/dependency_proxy/manifest_type_enum.rb =====
# frozen_string_literal: true

module Types
  class DependencyProxy::ManifestTypeEnum < BaseEnum
    graphql_name 'DependencyProxyManifestStatus'

    ::DependencyProxy::Manifest.statuses.keys.each do |status|
      value status.upcase, description: "Dependency proxy manifest has a status of #{status}.", value: status
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/dependency_proxy/manifest_type.rb =====
# frozen_string_literal: true

module Types
  class DependencyProxy::ManifestType < BaseObject
    graphql_name 'DependencyProxyManifest'

    description 'Dependency proxy manifest'

    authorize :read_dependency_proxy

    field :created_at, Types::TimeType, null: false, description: 'Date of creation.'
    field :digest, GraphQL::Types::String, null: false, description: 'Digest of the manifest.'
    field :file_name, GraphQL::Types::String, null: false, description: 'Name of the manifest.'
    field :id, ::Types::GlobalIDType[::DependencyProxy::Manifest], null: false, description: 'ID of the manifest.'
    field :image_name, GraphQL::Types::String, null: false, description: 'Name of the image.'
    field :size, GraphQL::Types::String, null: false, description: 'Size of the manifest file.'
    field :status,
      Types::DependencyProxy::ManifestTypeEnum,
      null: false,
      description: "Status of the manifest (#{::DependencyProxy::Manifest.statuses.keys.join(', ')})"
    field :updated_at, Types::TimeType, null: false, description: 'Date of most recent update.'

    def image_name
      object.file_name.chomp(File.extname(object.file_name))
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/deployments_order_by_input_type.rb =====
# frozen_string_literal: true

module Types
  class DeploymentsOrderByInputType < BaseInputObject
    graphql_name 'DeploymentsOrderByInput'
    description 'Values for ordering deployments by a specific field'

    argument :created_at,
      Types::SortDirectionEnum,
      required: false,
      description: 'Order by Created time.'

    argument :finished_at,
      Types::SortDirectionEnum,
      required: false,
      description: 'Order by Finished time.'

    def prepare
      raise GraphQL::ExecutionError, 'orderBy parameter must contain one key-value pair.' unless to_h.size == 1

      super
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/deployment_status_enum.rb =====
# frozen_string_literal: true

module Types
  class DeploymentStatusEnum < BaseEnum
    graphql_name 'DeploymentStatus'
    description 'All deployment statuses.'

    ::Deployment.statuses.each_key do |status|
      value status.upcase,
        description: "A deployment that is #{status.tr('_', ' ')}.",
        value: status
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/deployment_tag_type.rb =====
# frozen_string_literal: true

module Types
  # DeploymentTagType is a hash, authorized by the deployment
  # rubocop:disable Graphql/AuthorizeTypes
  class DeploymentTagType < BaseObject
    graphql_name 'DeploymentTag'
    description 'Tags for a given deployment'

    field :name,
      GraphQL::Types::String,
      description: 'Name of the git tag.'

    field :path,
      GraphQL::Types::String,
      description: 'Path for the tag.'

    field :web_path,
      GraphQL::Types::String,
      description: 'Web path for the tag.'
  end
  # rubocop:enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/deployment_tier_enum.rb =====
# frozen_string_literal: true

module Types
  class DeploymentTierEnum < BaseEnum
    graphql_name 'DeploymentTier'
    description 'All environment deployment tiers.'

    value 'PRODUCTION', description: 'Production.', value: :production
    value 'STAGING', description: 'Staging.', value: :staging
    value 'TESTING', description: 'Testing.', value: :testing
    value 'DEVELOPMENT', description: 'Development.', value: :development
    value 'OTHER', description: 'Other.', value: :other
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/deployment_type.rb =====
# frozen_string_literal: true

module Types
  class DeploymentType < BaseObject
    graphql_name 'Deployment'
    description 'The deployment of an environment'

    present_using ::Deployments::DeploymentPresenter

    authorize :read_deployment

    expose_permissions Types::PermissionTypes::Deployment

    field :id,
      GraphQL::Types::ID,
      description: 'Global ID of the deployment.'

    field :iid,
      GraphQL::Types::String,
      description: 'Project-level internal ID of the deployment.'

    field :ref,
      GraphQL::Types::String,
      description: 'Git-Ref that the deployment ran on.'

    field :ref_path,
      GraphQL::Types::String,
      description: 'Path to the Git-Ref that the deployment ran on.'

    field :tag,
      GraphQL::Types::Boolean,
      description: 'True or false if the deployment ran on a Git-tag.'

    field :sha,
      GraphQL::Types::String,
      description: 'Git-SHA that the deployment ran on.'

    field :created_at,
      Types::TimeType,
      description: 'When the deployment record was created.'

    field :updated_at,
      Types::TimeType,
      description: 'When the deployment record was updated.'

    field :finished_at,
      Types::TimeType,
      description: 'When the deployment finished.'

    field :status,
      Types::DeploymentStatusEnum,
      description: 'Status of the deployment.'

    field :commit,
      Types::Repositories::CommitType,
      description: 'Commit details of the deployment.',
      calls_gitaly: true

    field :job,
      Types::Ci::JobType,
      authorize: :read_build,
      description: 'Pipeline job of the deployment.'

    field :triggerer,
      Types::UserType,
      description: 'User who executed the deployment.',
      method: :deployed_by

    field :tags,
      [Types::DeploymentTagType],
      description: 'Git tags that contain this deployment. ' \
        'This field can only be resolved for two deployments in any single request.',
      calls_gitaly: true do
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 2
    end

    field :web_path,
      GraphQL::Types::String, null: true,
      description: 'Web path to the deployment page.'
  end
end

Types::DeploymentType.prepend_mod_with('Types::DeploymentType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/deprecated_mutations.rb =====
# frozen_string_literal: true

module Types
  module DeprecatedMutations
    extend ActiveSupport::Concern

    prepended do
      mount_aliased_mutation 'WorkItemExport', Mutations::WorkItems::CSV::Export,
        deprecated: { reason: 'Use WorkItemsCsvExport', milestone: '18.0' }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/description_version_type.rb =====
# frozen_string_literal: true

module Types
  class DescriptionVersionType < BaseObject
    graphql_name 'DescriptionVersion'

    authorize :read_issuable

    field :id, ::Types::GlobalIDType[::DescriptionVersion],
      null: false,
      description: 'ID of the description version.'

    field :description, GraphQL::Types::String,
      null: true,
      description: 'Content of the given description version.'
  end
end

Types::DescriptionVersionType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/design_at_version_type.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    class DesignAtVersionType < BaseObject
      graphql_name 'DesignAtVersion'

      description 'A design pinned to a specific version. ' \
        'The image field reflects the design as of the associated version'

      authorize :read_design

      delegate :design, :version, to: :object
      delegate :issue, :filename, :full_path, :diff_refs, to: :design

      implements ::Types::DesignManagement::DesignFields

      field :version,
        Types::DesignManagement::VersionType,
        null: false,
        description: 'Version the design-at-versions is pinned to.'

      field :design,
        Types::DesignManagement::DesignType,
        null: false,
        description: 'Underlying design.'

      def cached_stateful_version(_parent)
        version
      end

      def notes_count
        design.user_notes_count
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/design_collection_copy_state_enum.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    class DesignCollectionCopyStateEnum < BaseEnum
      graphql_name 'DesignCollectionCopyState'
      description 'Copy state of a DesignCollection'

      DESCRIPTION_VARIANTS = {
        in_progress: 'is being copied',
        error: 'encountered an error during a copy',
        ready: 'has no copy in progress'
      }.freeze

      def self.description_variant(copy_state)
        DESCRIPTION_VARIANTS[copy_state.to_sym] ||
          (raise ArgumentError, "Unknown copy state: #{copy_state}")
      end

      ::DesignManagement::DesignCollection.state_machines[:copy_state].states.keys.each do |copy_state|
        value copy_state.upcase,
          value: copy_state.to_s,
          description: "The DesignCollection #{description_variant(copy_state)}"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/design_collection_type.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    class DesignCollectionType < ::Types::BaseObject
      graphql_name 'DesignCollection'
      description 'A collection of designs'

      authorize :read_design

      field :issue, Types::IssueType, null: false,
        description: 'Issue associated with the design collection.'
      field :project, Types::ProjectType, null: false,
        description: 'Project associated with the design collection.'

      field :designs,
        Types::DesignManagement::DesignType.connection_type,
        null: false,
        resolver: Resolvers::DesignManagement::DesignsResolver,
        description: 'All designs for the design collection.',
        complexity: 5

      field :versions,
        Types::DesignManagement::VersionType.connection_type,
        resolver: Resolvers::DesignManagement::VersionsResolver,
        description: 'All versions related to all designs, ordered newest first.'

      field :version,
        Types::DesignManagement::VersionType,
        resolver: Resolvers::DesignManagement::VersionsResolver.single,
        description: 'A specific version.'

      field :design_at_version, ::Types::DesignManagement::DesignAtVersionType,
        null: true,
        resolver: ::Resolvers::DesignManagement::DesignAtVersionResolver,
        description: 'Find a design as of a version.'

      field :design, ::Types::DesignManagement::DesignType,
        null: true,
        resolver: ::Resolvers::DesignManagement::DesignResolver,
        description: 'Find a specific design.'

      field :copy_state, ::Types::DesignManagement::DesignCollectionCopyStateEnum,
        null: true,
        description: 'Copy state of the design collection.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/design_fields.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    module DesignFields
      include BaseInterface

      field_class Types::BaseField

      field :id, GraphQL::Types::ID, description: 'ID of the design.', null: false
      field :project, Types::ProjectType, null: false, description: 'Project the design belongs to.'
      field :issue, Types::IssueType, null: false, description: 'Issue the design belongs to.'
      field :filename, GraphQL::Types::String, null: false, description: 'Filename of the design.'
      field :full_path, GraphQL::Types::ID, null: false, description: 'Full path to the design file.'
      field :image, GraphQL::Types::String, null: false, extras: [:parent], description: 'URL of the full-sized image.'
      field :image_v432x230,
        GraphQL::Types::String,
        null: true,
        extras: [:parent],
        description: 'The URL of the design resized to fit within the bounds of 432x230. ' \
          'This will be `null` if the image has not been generated'
      field :diff_refs, Types::DiffRefsType,
        null: false,
        calls_gitaly: true,
        extras: [:parent],
        description: 'Diff refs for the design.'
      field :event, Types::DesignManagement::DesignVersionEventEnum,
        null: false,
        extras: [:parent],
        description: 'How the design was changed in the current version.'
      field :notes_count,
        GraphQL::Types::Int,
        null: false,
        method: :user_notes_count,
        description: 'Total count of user-created notes for the design.'

      def diff_refs(parent:)
        version = cached_stateful_version(parent)
        version.diff_refs
      end

      def image(parent:)
        sha = cached_stateful_version(parent).sha

        Gitlab::UrlBuilder.build(design, ref: sha)
      end

      def image_v432x230(parent:)
        Gitlab::Graphql::Lazy.with_value(lazy_action(parent)) do |action|
          # A `nil` return value indicates that the image has not been processed
          next unless action&.image_v432x230&.file

          Gitlab::UrlBuilder.build(action.design, ref: action.version.sha, size: :v432x230)
        end
      end

      def event(parent:)
        version = cached_stateful_version(parent)

        action = cached_actions_for_version(version)[design.id]

        action&.event || ::Types::DesignManagement::DesignVersionEventEnum::NONE
      end

      def cached_actions_for_version(version)
        Gitlab::SafeRequestStore.fetch(['DesignFields', 'actions_for_version', version.id]) do
          version.actions.index_by(&:design_id)
        end
      end

      def project
        ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::Project, design.project_id).find
      end

      def issue
        ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::Issue, design.issue_id).find
      end

      private

      def lazy_action(parent)
        version = cached_stateful_version(parent)

        BatchLoader::GraphQL.for([version, design]).batch do |ids, loader|
          by_version = ids.group_by(&:first).transform_values { _1.map(&:second) }
          designs_by_id = ids.map(&:second).index_by(&:id)

          by_version.each do |v, designs|
            actions = ::DesignManagement::Action.most_recent.up_to_version(v).by_design(designs).with_version
            actions.each do |action|
              action.design = designs_by_id[action.design_id] # eliminate duplicate load
              loader.call([v, action.design], action)
            end
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/design_type.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    class DesignType < BaseObject
      graphql_name 'Design'
      description 'A single design'

      authorize :read_design

      alias_method :design, :object

      implements Types::Notes::NoteableInterface
      implements Types::DesignManagement::DesignFields
      implements Types::CurrentUserTodos
      implements Types::TodoableInterface

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of the design.'

      field :web_url,
        GraphQL::Types::String,
        null: false,
        description: 'URL of the design.'

      field :versions,
        Types::DesignManagement::VersionType.connection_type,
        resolver: Resolvers::DesignManagement::VersionsResolver,
        description: "All versions related to this design ordered newest first."

      field :imported,
        GraphQL::Types::Boolean,
        null: false,
        method: :imported?,
        description: 'Indicates whether the design was imported.'

      field :imported_from,
        Types::Import::ImportSourceEnum,
        null: false,
        description: 'Import source of the design.'

      markdown_field :description_html, null: true

      # Returns a `DesignManagement::Version` for this query based on the
      # `atVersion` argument passed to a parent node if present, or otherwise
      # the most recent `Version` for the issue.
      def cached_stateful_version(parent_node)
        version_gid = context[:at_version_argument] # See: DesignsResolver

        # Caching is scoped to an `issue_id` to allow us to cache the
        # most recent `Version` for an issue
        Gitlab::SafeRequestStore.fetch([request_cache_base_key, 'stateful_version', object.issue_id, version_gid]) do
          if version_gid
            GitlabSchema.object_from_id(version_gid, expected_type: ::DesignManagement::Version)&.sync
          else
            object.issue.design_versions.most_recent
          end
        end
      end

      def request_cache_base_key
        self.class.name
      end

      def web_url
        Gitlab::UrlBuilder.build(object)
      end

      def name
        object.filename
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/design_version_event_enum.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    class DesignVersionEventEnum < BaseEnum
      graphql_name 'DesignVersionEvent'
      description 'Mutation event of a design within a version'

      NONE = 'NONE'

      value NONE, 'No change.'

      ::DesignManagement::Action.events.keys.each do |event_name|
        value event_name.upcase, value: event_name, description: "A #{event_name} event"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management_type.rb =====
# frozen_string_literal: true

# rubocop: disable Graphql/AuthorizeTypes
module Types
  class DesignManagementType < BaseObject
    graphql_name 'DesignManagement'

    field :version, ::Types::DesignManagement::VersionType,
      null: true,
      resolver: ::Resolvers::DesignManagement::VersionResolver,
      description: 'Find a version.'

    field :design_at_version, ::Types::DesignManagement::DesignAtVersionType,
      null: true,
      resolver: ::Resolvers::DesignManagement::DesignAtVersionResolver,
      description: 'Find a design as of a version.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/design_management/version_type.rb =====
# frozen_string_literal: true

module Types
  module DesignManagement
    class VersionType < ::Types::BaseObject
      # Just `Version` might be a bit to general to expose globally so adding
      # a `Design` prefix to specify the class exposed in GraphQL
      graphql_name 'DesignVersion'

      description 'A specific version in which designs were added, modified or deleted'

      authorize :read_design

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the design version.'
      field :sha, GraphQL::Types::ID, null: false,
        description: 'SHA of the design version.'

      field :designs,
        ::Types::DesignManagement::DesignType.connection_type,
        null: false,
        description: 'All designs that were changed in the version.'

      field :designs_at_version,
        ::Types::DesignManagement::DesignAtVersionType.connection_type,
        null: false,
        description: 'All designs that are visible at this version, as of this version.',
        resolver: ::Resolvers::DesignManagement::Version::DesignsAtVersionResolver

      field :design_at_version,
        ::Types::DesignManagement::DesignAtVersionType,
        null: false,
        description: 'A particular design as of this version, provided it is visible at this version.',
        resolver: ::Resolvers::DesignManagement::Version::DesignsAtVersionResolver.single

      field :author, Types::UserType, null: false, description: 'Author of the version.'
      field :created_at, Types::TimeType, null: false,
        description: 'Timestamp of when the version was created.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/diff_paths_input_type.rb =====
# frozen_string_literal: true

module Types
  class DiffPathsInputType < BaseInputObject
    argument :new_path, GraphQL::Types::String, required: false,
      description: 'Path of the file on the HEAD SHA.'
    argument :old_path, GraphQL::Types::String, required: false,
      description: 'Path of the file on the start SHA.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/diff_refs_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # Types that use DiffRefsType should have their own authorization
  class DiffRefsType < BaseObject
    graphql_name 'DiffRefs'

    field :base_sha, GraphQL::Types::String, null: true,
      description: 'Merge base of the branch the comment was made on.'
    field :head_sha, GraphQL::Types::String, null: false,
      description: 'SHA of the HEAD at the time the comment was made.'
    field :start_sha, GraphQL::Types::String, null: false,
      description: 'SHA of the branch being compared against.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/diff_stats_summary_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # Types that use DiffStatsType should have their own authorization
  class DiffStatsSummaryType < BaseObject
    graphql_name 'DiffStatsSummary'

    description 'Aggregated summary of changes'

    field :additions, GraphQL::Types::Int, null: false,
      description: 'Number of lines added.'
    field :changes, GraphQL::Types::Int, null: false,
      description: 'Number of lines changed.'
    field :deletions, GraphQL::Types::Int, null: false,
      description: 'Number of lines deleted.'
    field :file_count, GraphQL::Types::Int, null: false,
      description: 'Number of files changed.'

    def changes
      object[:additions] + object[:deletions]
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/diff_stats_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # Types that use DiffStatsType should have their own authorization
  class DiffStatsType < BaseObject
    graphql_name 'DiffStats'

    description 'Changes to a single file'

    field :additions, GraphQL::Types::Int, null: false,
      description: 'Number of lines added to the file.'
    field :deletions, GraphQL::Types::Int, null: false,
      description: 'Number of lines deleted from the file.'
    field :path, GraphQL::Types::String, null: false,
      description: 'File path, relative to repository root.'

    def path
      object.path.dup.force_encoding('UTF-8')
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/diff_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class DiffType < BaseObject
    graphql_name 'Diff'

    field :a_mode, GraphQL::Types::String, null: true,
      description: 'Old file mode of the file.'
    field :b_mode, GraphQL::Types::String, null: true,
      description: 'New file mode of the file.'
    field :deleted_file, GraphQL::Types::String, null: true,
      description: 'Indicates if the file has been removed. '
    field :diff, GraphQL::Types::String, null: true,
      description: 'Diff representation of the changes made to the file.'
    field :new_file, GraphQL::Types::String, null: true,
      description: 'Indicates if the file has just been added. '
    field :new_path, GraphQL::Types::String, null: true,
      description: 'New path of the file.'
    field :old_path, GraphQL::Types::String, null: true,
      description: 'Old path of the file.'
    field :renamed_file, GraphQL::Types::String, null: true,
      description: 'Indicates if the file has been renamed.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/duration_type.rb =====
# frozen_string_literal: true

module Types
  class DurationType < BaseScalar
    graphql_name 'Duration'
    description <<~DESC
      Duration between two instants, represented as a fractional number of seconds.

      For example: 12.3334
    DESC

    def self.coerce_input(value, ctx)
      case value
      when Float
        value
      when Integer
        value.to_f
      when NilClass
        raise GraphQL::CoercionError, 'Cannot be nil'
      else
        raise GraphQL::CoercionError, "Expected number: got #{value.class}"
      end
    end

    def self.coerce_result(value, ctx)
      value.to_f
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/environments/auto_stop_setting_enum.rb =====
# frozen_string_literal: true

module Types
  module Environments
    class AutoStopSettingEnum < BaseEnum
      graphql_name 'AutoStopSetting'
      description 'Auto stop setting.'

      ::Environment.auto_stop_settings.each_key do |key|
        value key.upcase, value: key, description: key.titleize
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/environment_type.rb =====
# frozen_string_literal: true

module Types
  class EnvironmentType < BaseObject
    graphql_name 'Environment'
    description 'Describes where code is deployed for a project'

    present_using ::EnvironmentPresenter

    authorize :read_environment

    expose_permissions Types::PermissionTypes::Environment,
      description: 'Permissions for the current user on the resource. ' \
        'This field can only be resolved for one environment in any single request.' do
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
    end

    field :name, GraphQL::Types::String, null: false,
      description: 'Human-readable name of the environment.'

    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the environment.'

    field :state, GraphQL::Types::String, null: false,
      description: 'State of the environment, for example: available/stopped.'

    field :path, GraphQL::Types::String, null: false,
      description: 'Path to the environment.'

    field :slug, GraphQL::Types::String,
      description: 'Slug of the environment.'

    field :external_url, GraphQL::Types::String, null: true,
      description: 'External URL of the environment.'

    field :description, GraphQL::Types::String, null: true,
      description: 'Description of the environment.'

    field :kubernetes_namespace, GraphQL::Types::String, null: true,
      description: 'Kubernetes namespace of the environment.'

    field :flux_resource_path, GraphQL::Types::String, null: true,
      description: 'Flux resource path of the environment.'

    field :created_at, Types::TimeType,
      description: 'When the environment was created.'

    field :updated_at, Types::TimeType,
      description: 'When the environment was updated.'

    field :auto_stop_at, Types::TimeType,
      description: 'When the environment is going to be stopped automatically.'

    field :auto_delete_at, Types::TimeType,
      description: 'When the environment is going to be deleted automatically.'

    field :tier, Types::DeploymentTierEnum,
      description: 'Deployment tier of the environment.'

    field :environment_type, GraphQL::Types::String,
      description: 'Folder name of the environment.'

    field :deployments_display_count, GraphQL::Types::String, null: true,
      description: 'Number of deployments in the environment for display. ' \
        'Returns the precise number up to 999, and "999+" for counts exceeding this limit.'

    field :latest_opened_most_severe_alert,
      Types::AlertManagement::AlertType,
      null: true,
      description: 'Most severe open alert for the environment. If multiple alerts have equal severity, the most recent is returned.'

    field :deployments,
      Types::DeploymentType.connection_type,
      null: true,
      description: 'Deployments of the environment. This field can only be resolved for one environment in any single request.',
      resolver: Resolvers::DeploymentsResolver do
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
    end

    field :last_deployment,
      Types::DeploymentType,
      description: 'Last deployment of the environment.',
      resolver: Resolvers::Environments::LastDeploymentResolver

    field :deploy_freezes,
      [Types::Ci::FreezePeriodType],
      null: true,
      description: 'Deployment freeze periods of the environment.'

    field :cluster_agent,
      Types::Clusters::AgentType,
      description: 'Cluster agent of the environment.',
      null: true do
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
    end

    field :auto_stop_setting, Types::Environments::AutoStopSettingEnum,
      description: 'Auto stop setting of the environment.'

    markdown_field :description_html, null: true

    def tier
      object.tier.to_sym
    end
  end
end

Types::EnvironmentType.prepend_mod_with('Types::EnvironmentType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_detailed_error_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    class SentryDetailedErrorType < ::Types::BaseObject
      graphql_name 'SentryDetailedError'
      description 'A Sentry error'

      present_using SentryErrorPresenter

      authorize :read_sentry_issue

      field :count, GraphQL::Types::Int,
        null: false,
        description: 'Count of occurrences.'
      field :culprit, GraphQL::Types::String,
        null: false,
        description: 'Culprit of the error.'
      field :external_base_url, GraphQL::Types::String,
        null: false,
        description: 'External Base URL of the Sentry Instance.'
      field :external_url, GraphQL::Types::String,
        null: false,
        description: 'External URL of the error.'
      field :first_release_last_commit, GraphQL::Types::String,
        null: true,
        description: 'Commit the error was first seen.'
      field :first_release_short_version, GraphQL::Types::String,
        null: true,
        description: 'Release short version the error was first seen.'
      field :first_release_version, GraphQL::Types::String,
        null: true,
        description: 'Release version the error was first seen.'
      field :first_seen, Types::TimeType,
        null: false,
        description: 'Timestamp when the error was first seen.'
      field :frequency, [Types::ErrorTracking::SentryErrorFrequencyType],
        null: false,
        description: 'Last 24hr stats of the error.'
      field :gitlab_commit, GraphQL::Types::String,
        null: true,
        description: 'GitLab commit SHA attributed to the Error based on the release version.'
      field :gitlab_commit_path, GraphQL::Types::String,
        null: true,
        description: 'Path to the GitLab page for the GitLab commit attributed to the error.'
      field :gitlab_issue_path, GraphQL::Types::String,
        method: :gitlab_issue,
        null: true,
        description: 'URL of GitLab Issue.'
      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID (global ID) of the error.'
      field :integrated, GraphQL::Types::Boolean,
        null: true,
        description: 'Error tracking backend.'
      field :last_release_last_commit, GraphQL::Types::String,
        null: true,
        description: 'Commit the error was last seen.'
      field :last_release_short_version, GraphQL::Types::String,
        null: true,
        description: 'Release short version the error was last seen.'
      field :last_release_version, GraphQL::Types::String,
        null: true,
        description: 'Release version the error was last seen.'
      field :last_seen, Types::TimeType,
        null: false,
        description: 'Timestamp when the error was last seen.'
      field :message, GraphQL::Types::String,
        null: true,
        description: 'Sentry metadata message of the error.'
      field :sentry_id, GraphQL::Types::String,
        method: :id,
        null: false,
        description: 'ID (Sentry ID) of the error.'
      field :sentry_project_id, GraphQL::Types::ID,
        method: :project_id,
        null: false,
        description: 'ID of the project (Sentry project).'
      field :sentry_project_name, GraphQL::Types::String,
        method: :project_name,
        null: false,
        description: 'Name of the project affected by the error.'
      field :sentry_project_slug, GraphQL::Types::String,
        method: :project_slug,
        null: false,
        description: 'Slug of the project affected by the error.'
      field :short_id, GraphQL::Types::String,
        null: false,
        description: 'Short ID (Sentry ID) of the error.'
      field :status, Types::ErrorTracking::SentryErrorStatusEnum,
        null: false,
        description: 'Status of the error.'
      field :tags, Types::ErrorTracking::SentryErrorTagsType,
        null: false,
        description: 'Tags associated with the Sentry Error.'
      field :title, GraphQL::Types::String,
        null: false,
        description: 'Title of the error.'
      field :type, GraphQL::Types::String,
        null: false,
        description: 'Type of the error.'
      field :user_count, GraphQL::Types::Int,
        null: false,
        description: 'Count of users affected by the error.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_collection_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    class SentryErrorCollectionType < ::Types::BaseObject
      graphql_name 'SentryErrorCollection'
      description 'An object containing a collection of Sentry errors, and a detailed error'

      authorize :read_sentry_issue

      field :detailed_error,
        description: 'Detailed version of a Sentry error on the project.',
        resolver: Resolvers::ErrorTracking::SentryDetailedErrorResolver
      field :error_stack_trace,
        description: 'Stack Trace of Sentry Error.',
        resolver: Resolvers::ErrorTracking::SentryErrorStackTraceResolver
      field :errors,
        description: "Collection of Sentry Errors.",
        resolver: Resolvers::ErrorTracking::SentryErrorsResolver,
        connection_extension: Gitlab::Graphql::Extensions::ExternallyPaginatedArrayExtension
      field :external_url,
        GraphQL::Types::String,
        null: true,
        description: "External URL for Sentry."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_frequency_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    # rubocop: disable Graphql/AuthorizeTypes
    class SentryErrorFrequencyType < ::Types::BaseObject
      graphql_name 'SentryErrorFrequency'

      field :count, GraphQL::Types::Int,
        null: false,
        description: "Count of errors received since the previously recorded time."
      field :time, Types::TimeType,
        null: false,
        description: "Time the error frequency stats were recorded."
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_stack_trace_context_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    # rubocop: disable Graphql/AuthorizeTypes
    class SentryErrorStackTraceContextType < ::Types::BaseObject
      graphql_name 'SentryErrorStackTraceContext'
      description 'An object context for a Sentry error stack trace'

      field :code,
        GraphQL::Types::String,
        null: false,
        description: 'Code number of the context.'
      field :line,
        GraphQL::Types::Int,
        null: false,
        description: 'Line number of the context.'

      def line
        object[0]
      end

      def code
        object[1]
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_stack_trace_entry_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    # rubocop: disable Graphql/AuthorizeTypes
    class SentryErrorStackTraceEntryType < ::Types::BaseObject
      graphql_name 'SentryErrorStackTraceEntry'
      description 'An object containing a stack trace entry for a Sentry error'

      field :col, GraphQL::Types::String,
        null: true,
        description: 'Function in which the Sentry error occurred.', hash_key: "colNo"
      field :file_name, GraphQL::Types::String,
        null: true,
        description: 'File in which the Sentry error occurred.', hash_key: "filename"
      field :function, GraphQL::Types::String,
        null: true,
        description: 'Function in which the Sentry error occurred.', hash_key: "function"
      field :line, GraphQL::Types::String,
        null: true,
        description: 'Function in which the Sentry error occurred.', hash_key: "lineNo"
      field :trace_context, [Types::ErrorTracking::SentryErrorStackTraceContextType],
        null: true,
        description: 'Context of the Sentry error.'

      def trace_context
        object['context']
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_stack_trace_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    class SentryErrorStackTraceType < ::Types::BaseObject
      graphql_name 'SentryErrorStackTrace'
      description 'An object containing a stack trace entry for a Sentry error'

      authorize :read_sentry_issue

      field :date_received, GraphQL::Types::String,
        null: false,
        description: 'Time the stack trace was received by Sentry.'
      field :issue_id, GraphQL::Types::String,
        null: false,
        description: 'ID of the Sentry error.'
      field :stack_trace_entries, [Types::ErrorTracking::SentryErrorStackTraceEntryType],
        null: false,
        description: 'Stack trace entries for the Sentry error.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_status_enum.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    class SentryErrorStatusEnum < ::Types::BaseEnum
      graphql_name 'SentryErrorStatus'
      description 'State of a Sentry error'

      value 'RESOLVED', value: 'resolved', description: 'Error has been resolved.'
      value 'RESOLVED_IN_NEXT_RELEASE', value: 'resolvedInNextRelease', description: 'Error has been ignored until next release.'
      value 'UNRESOLVED', value: 'unresolved', description: 'Error is unresolved.'
      value 'IGNORED', value: 'ignored', description: 'Error has been ignored.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_tags_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    # rubocop: disable Graphql/AuthorizeTypes
    class SentryErrorTagsType < ::Types::BaseObject
      graphql_name 'SentryErrorTags'
      description 'State of a Sentry error'

      field :level, GraphQL::Types::String,
        null: true,
        description: "Severity level of the Sentry Error."
      field :logger, GraphQL::Types::String,
        null: true,
        description: "Logger of the Sentry Error."
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/error_tracking/sentry_error_type.rb =====
# frozen_string_literal: true

module Types
  module ErrorTracking
    # rubocop: disable Graphql/AuthorizeTypes
    class SentryErrorType < ::Types::BaseObject
      graphql_name 'SentryError'
      description 'A Sentry error. A simplified version of SentryDetailedError'

      present_using SentryErrorPresenter

      field :count, GraphQL::Types::Int,
        null: false,
        description: 'Count of occurrences.'
      field :culprit, GraphQL::Types::String,
        null: false,
        description: 'Culprit of the error.'
      field :external_url, GraphQL::Types::String,
        null: false,
        description: 'External URL of the error.'
      field :first_seen, Types::TimeType,
        null: false,
        description: 'Timestamp when the error was first seen.'
      field :frequency, [Types::ErrorTracking::SentryErrorFrequencyType],
        null: false,
        description: 'Last 24hr stats of the error.'
      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID (global ID) of the error.'
      field :last_seen, Types::TimeType,
        null: false,
        description: 'Timestamp when the error was last seen.'
      field :message, GraphQL::Types::String,
        null: true,
        description: 'Sentry metadata message of the error.'
      field :sentry_id, GraphQL::Types::String,
        method: :id,
        null: false,
        description: 'ID (Sentry ID) of the error.'
      field :sentry_project_id, GraphQL::Types::ID,
        method: :project_id,
        null: false,
        description: 'ID of the project (Sentry project).'
      field :sentry_project_name, GraphQL::Types::String,
        method: :project_name,
        null: false,
        description: 'Name of the project affected by the error.'
      field :sentry_project_slug, GraphQL::Types::String,
        method: :project_slug,
        null: false,
        description: 'Slug of the project affected by the error.'
      field :short_id, GraphQL::Types::String,
        null: false,
        description: 'Short ID (Sentry ID) of the error.'
      field :status, Types::ErrorTracking::SentryErrorStatusEnum,
        null: false,
        description: 'Status of the error.'
      field :title, GraphQL::Types::String,
        null: false,
        description: 'Title of the error.'
      field :type, GraphQL::Types::String,
        null: false,
        description: 'Type of the error.'
      field :user_count, GraphQL::Types::Int,
        null: false,
        description: 'Count of users affected by the error.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/eventable_type.rb =====
# frozen_string_literal: true

module Types
  module EventableType
    include Types::BaseInterface

    field :events, Types::EventType.connection_type, null: true, description: 'List of events associated with the object.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/event_action_enum.rb =====
# frozen_string_literal: true

module Types
  class EventActionEnum < BaseEnum
    graphql_name 'EventAction'
    description 'Event action'

    ::Event.actions.keys.each do |target_type|
      value target_type.upcase, value: target_type, description: "#{target_type.titleize} action"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/event_type.rb =====
# frozen_string_literal: true

module Types
  class EventType < BaseObject
    graphql_name 'Event'
    description 'Representing an event'

    present_using EventPresenter

    authorize :read_event

    field :id, GraphQL::Types::ID,
      description: 'ID of the event.',
      null: false

    field :author, Types::UserType,
      description: 'Author of the event.',
      null: false

    field :action, Types::EventActionEnum,
      description: 'Action of the event.',
      null: false

    field :created_at, Types::TimeType,
      description: 'When the event was created.',
      null: false

    field :updated_at, Types::TimeType,
      description: 'When the event was updated.',
      null: false

    field :project, Types::ProjectType,
      description: 'Project of the event.',
      null: true

    field :target, Types::Users::EventTargetType,
      description: 'Target of the event.',
      calls_gitaly: true

    def author
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.author_id).find
    end

    def project
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
    end

    def target
      # If we don't have target info, bail
      return unless object.target_type && object.target_id

      Gitlab::Graphql::Loaders::BatchModelLoader.new(target_type_class, object.target_id).find
    end

    private

    def target_type_class
      klass = object.target_type&.safe_constantize
      klass if klass.is_a?(Class)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/evidence_type.rb =====
# frozen_string_literal: true

module Types
  class EvidenceType < BaseObject
    graphql_name 'ReleaseEvidence'
    description 'Evidence for a release'

    authorize :read_release_evidence

    present_using Releases::EvidencePresenter

    field :collected_at, Types::TimeType, null: true,
      description: 'Timestamp when the evidence was collected.'
    field :filepath, GraphQL::Types::String, null: true,
      description: 'URL from where the evidence can be downloaded.'
    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the evidence.'
    field :sha, GraphQL::Types::String, null: true,
      description: 'SHA1 ID of the evidence hash.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/extensions_marketplace_opt_in_status_enum.rb =====
# frozen_string_literal: true

module Types
  class ExtensionsMarketplaceOptInStatusEnum < BaseEnum
    graphql_name 'ExtensionsMarketplaceOptInStatus'
    description 'Values for status of the Web IDE Extension Marketplace opt-in for the user'

    UserPreference.extensions_marketplace_opt_in_statuses.each_key do |field|
      value field.upcase, value: field, description: "Web IDE Extension Marketplace opt-in status: #{field.upcase}."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/global_id_type.rb =====
# frozen_string_literal: true

module Types
  class GlobalIDType < BaseScalar
    graphql_name 'GlobalID'
    description <<~DESC
      A global identifier.

      A global identifier represents an object uniquely across the application.
      An example of a global identifier is `"gid://gitlab/User/1"`.

      `gid://gitlab` stands for the root name.
      `User` is the name of the ActiveRecord class of the record.
      `1` is the record id as per the id in the db table.

      Global identifiers are encoded as strings.
    DESC

    # @param value [GID]
    # @return [String]
    def self.coerce_result(value, _ctx)
      ::Gitlab::GlobalId.as_global_id(value).to_s
    end

    # @param value [String]
    # @return [GID]
    def self.coerce_input(value, _ctx)
      return if value.nil?

      gid = GlobalID.parse(value)
      raise GraphQL::CoercionError, "#{value.inspect} is not a valid Global ID" if gid.nil?
      raise GraphQL::CoercionError, "#{value.inspect} is not a Gitlab Global ID" unless gid.app == GlobalID.app

      gid
    end

    # Construct a restricted type, that can only be inhabited by an ID of
    # a given model class.
    def self.[](model_class)
      @id_types ||= {
        # WorkItem has a special class as we want to allow IssueID
        # on WorkItemID while we transition into work items
        ::WorkItem => ::Types::WorkItemIdType
      }

      @id_types[model_class] ||= Class.new(self) do
        model_name = model_class.name

        graphql_name model_name_to_graphql_name(model_name)
        description <<~MD.strip
          A `#{graphql_name}` is a global ID. It is encoded as a string.

          An example `#{graphql_name}` is: `"#{::Gitlab::GlobalId.build(model_name: model_name, id: 1)}"`.
          #{
            if deprecation = Gitlab::GlobalId::Deprecations.deprecation_by(model_name)
              "The older format `\"#{::Gitlab::GlobalId.build(model_name: deprecation.old_name, id: 1)}\"` was deprecated in #{deprecation.milestone}."
            end}

        MD

        define_singleton_method(:to_s) do
          graphql_name
        end

        define_singleton_method(:inspect) do
          graphql_name
        end

        define_singleton_method(:as) do |new_name|
          if @renamed && graphql_name != new_name
            raise "Conflicting names for ID of #{model_name}: " \
              "#{graphql_name} and #{new_name}"
          end

          @renamed = true
          graphql_name(new_name)
          self
        end

        define_singleton_method(:coerce_result) do |gid, ctx|
          global_id = ::Gitlab::GlobalId.as_global_id(gid, model_name: model_name)

          next global_id.to_s if suitable?(global_id)

          raise GraphQL::CoercionError, "Expected a #{model_name} ID, got #{global_id}"
        end

        define_singleton_method(:suitable?) do |gid|
          # an argument can be nil, so allow it here
          next true if gid.nil?

          gid.model_name.safe_constantize.present? &&
            gid.model_class.ancestors.include?(model_class)
        end

        define_singleton_method(:coerce_input) do |string, ctx|
          gid = super(string, ctx)
          next gid if suitable?(gid)

          raise GraphQL::CoercionError, "#{string.inspect} does not represent an instance of #{model_name}"
        end
      end
    end

    def self.model_name_to_graphql_name(model_name)
      "#{model_name.gsub(/::/, '')}ID"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/grafana_integration_type.rb =====
# frozen_string_literal: true

module Types
  class GrafanaIntegrationType < ::Types::BaseObject
    graphql_name 'GrafanaIntegration'

    authorize :admin_operations

    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of the issue\'s creation.'
    field :enabled, GraphQL::Types::Boolean, null: false,
      description: 'Indicates whether Grafana integration is enabled.'
    field :grafana_url, GraphQL::Types::String, null: false,
      description: 'URL for the Grafana host for the Grafana integration.'
    field :id, GraphQL::Types::ID, null: false,
      description: 'Internal ID of the Grafana integration.'
    field :updated_at, Types::TimeType, null: false,
      description: 'Timestamp of the issue\'s last activity.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/group_invitation_type.rb =====
# frozen_string_literal: true

module Types
  class GroupInvitationType < BaseObject
    graphql_name 'GroupInvitation'
    description 'Represents a Group Invitation'

    expose_permissions Types::PermissionTypes::Members::GroupMember
    authorize :admin_group

    implements InvitationInterface

    field :group, Types::GroupType, null: true,
      description: 'Group that a User is invited to.'

    def group
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Group, object.source_id).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/group_member_relation_enum.rb =====
# frozen_string_literal: true

module Types
  class GroupMemberRelationEnum < BaseEnum
    graphql_name 'GroupMemberRelation'
    description 'Group member relation'

    ::GroupMembersFinder::RELATIONS.each do |member_relation|
      value member_relation.to_s.upcase, value: member_relation, description: "#{::GroupMembersFinder::RELATIONS_DESCRIPTIONS[member_relation]}."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/group_member_type.rb =====
# frozen_string_literal: true

module Types
  class GroupMemberType < BaseObject
    graphql_name 'GroupMember'
    description 'Represents a Group Membership'

    expose_permissions Types::PermissionTypes::Members::GroupMember
    authorize :read_group

    implements MemberInterface

    field :group, Types::GroupType, null: true,
      description: 'Group that a user is a member of.'

    field :notification_email,
      resolver: Resolvers::GroupMembers::NotificationEmailResolver,
      description: "Group notification email for user. Only available for admins."

    def group
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Group, object.source_id).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/group_release_sort_enum.rb =====
# frozen_string_literal: true

module Types
  # Not inheriting from Types::SortEnum since we only want
  # to implement a subset of the sort values it defines.
  class GroupReleaseSortEnum < BaseEnum
    graphql_name 'GroupReleaseSort'
    description 'Values for sorting releases belonging to a group'

    # Borrowed from Types::ReleaseSortEnum and Types::SortEnum
    # These values/descriptions should stay in-sync as much as possible.
    value 'RELEASED_AT_DESC', 'Released at by descending order.', value: :released_at_desc
    value 'RELEASED_AT_ASC', 'Released at by ascending order.', value: :released_at_asc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/group_type.rb =====
# frozen_string_literal: true

module Types
  class GroupType < NamespaceType
    graphql_name 'Group'

    include ::Namespaces::DeletableHelper

    implements ::Types::Namespaces::GroupInterface

    connection_type_class Types::CountableConnectionType

    authorize :read_group

    expose_permissions Types::PermissionTypes::Group

    field :web_url,
      type: GraphQL::Types::String,
      null: false,
      description: 'Web URL of the group.'

    field :organization_edit_path, GraphQL::Types::String,
      null: true,
      description: 'Path for editing group at the organization level.',
      experiment: { milestone: '17.1' }

    field :avatar_url,
      type: GraphQL::Types::String,
      null: true,
      description: 'Avatar URL of the group.'

    field :created_at, Types::TimeType,
      null: true,
      description: 'Timestamp of the group creation.'

    field :updated_at, Types::TimeType,
      null: true,
      description: 'Timestamp of when the group was last updated.'

    field :custom_emoji,
      type: Types::CustomEmojiType.connection_type,
      null: true,
      resolver: Resolvers::CustomEmojiResolver,
      description: 'Custom emoji in this namespace.'

    field :share_with_group_lock,
      type: GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if sharing a project with another group within the group is prevented.'

    field :project_creation_level,
      type: GraphQL::Types::String,
      null: true,
      method: :project_creation_level_str,
      description: 'Permission level required to create projects in the group.'

    field :subgroup_creation_level,
      type: GraphQL::Types::String,
      null: true,
      method: :subgroup_creation_level_str,
      description: 'Permission level required to create subgroups within the group.'

    field :require_two_factor_authentication,
      type: GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if all users in the group are required to set up two-factor authentication.'

    field :two_factor_grace_period,
      type: GraphQL::Types::Int,
      null: true,
      description: 'Time before two-factor authentication is enforced.'

    field :auto_devops_enabled,
      type: GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates whether Auto DevOps is enabled for all projects within the group.'

    field :emails_disabled,
      type: GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if a group has email notifications disabled.'

    field :emails_enabled,
      type: GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if a group has email notifications enabled.'

    field :max_access_level, Types::AccessLevelType,
      null: false,
      description: 'Maximum access level of the current user in the group.'

    field :mentions_disabled,
      type: GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if a group is disabled from getting mentioned.'

    field :parent,
      type: GroupType,
      null: true,
      description: 'Parent group.'

    field :issues,
      Types::IssueType.connection_type,
      null: true,
      description: 'Issues for projects in this group.',
      resolver: Resolvers::GroupIssuesResolver

    field :merge_requests,
      Types::MergeRequestType.connection_type,
      null: true,
      description: 'Merge requests for projects in this group.',
      resolver: Resolvers::GroupMergeRequestsResolver

    field :environment_scopes,
      Types::Ci::GroupEnvironmentScopeType.connection_type,
      description: 'Environment scopes of the group.',
      null: true,
      authorize: :admin_cicd_variables,
      resolver: Resolvers::GroupEnvironmentScopesResolver

    field :milestones,
      description: 'Milestones of the group.',
      extras: [:lookahead],
      resolver: Resolvers::GroupMilestonesResolver

    field :boards,
      Types::BoardType.connection_type,
      null: true,
      description: 'Boards of the group.',
      max_page_size: 2000,
      resolver: Resolvers::BoardsResolver

    field :recent_issue_boards,
      Types::BoardType.connection_type,
      null: true,
      description: 'List of recently visited boards of the group. Maximum size is 4.',
      resolver: Resolvers::RecentBoardsResolver

    field :board,
      Types::BoardType,
      null: true,
      description: 'A single board of the group.',
      resolver: Resolvers::BoardResolver

    field :label,
      Types::LabelType,
      null: true,
      description: 'Label available on the group.' do
      argument :title,
        type: GraphQL::Types::String,
        required: true,
        description: 'Title of the label.'
    end

    field :group_members,
      description: 'A membership of a user within this group.',
      resolver: Resolvers::GroupMembersResolver

    field :container_repositories,
      Types::ContainerRegistry::ContainerRepositoryType.connection_type,
      null: true,
      description: 'Container repositories of the group.',
      resolver: Resolvers::ContainerRepositoriesResolver,
      authorize: :read_container_image

    field :container_repositories_count,
      type: GraphQL::Types::Int,
      null: false,
      description: 'Number of container repositories in the group.'

    field :packages,
      description: 'Packages of the group. This field can only be resolved for one group in any single request.',
      resolver: Resolvers::GroupPackagesResolver

    field :dependency_proxy_setting,
      Types::DependencyProxy::GroupSettingType,
      null: true,
      description: 'Dependency Proxy settings for the group.'

    field :dependency_proxy_manifests,
      Types::DependencyProxy::ManifestType.connection_type,
      null: true,
      description: 'Dependency Proxy manifests.'

    field :dependency_proxy_blobs,
      Types::DependencyProxy::BlobType.connection_type,
      null: true,
      description: 'Dependency Proxy blobs.'

    field :dependency_proxy_image_count,
      GraphQL::Types::Int,
      null: false,
      description: 'Number of dependency proxy images cached in the group.'

    field :dependency_proxy_blob_count,
      GraphQL::Types::Int,
      null: false,
      description: 'Number of dependency proxy blobs cached in the group.'

    field :dependency_proxy_total_size,
      GraphQL::Types::String,
      null: false,
      description: 'Total size of the dependency proxy cached images.'

    field :dependency_proxy_total_size_in_bytes,
      GraphQL::Types::Int,
      null: false,
      deprecated: { reason: 'Use `dependencyProxyTotalSizeBytes`', milestone: '16.1' },
      description: 'Total size of the dependency proxy cached images in bytes.'

    field :dependency_proxy_total_size_bytes,
      GraphQL::Types::BigInt,
      null: false,
      description: 'Total size of the dependency proxy cached images in bytes, encoded as a string.'

    field :dependency_proxy_image_prefix,
      GraphQL::Types::String,
      null: false,
      description: 'Prefix for pulling images when using the dependency proxy.'

    field :dependency_proxy_image_ttl_policy,
      Types::DependencyProxy::ImageTtlGroupPolicyType,
      null: true,
      description: 'Dependency proxy TTL policy for the group.'

    field :labels,
      Types::LabelType.connection_type,
      null: true,
      description: 'Labels available on this group.',
      resolver: Resolvers::GroupLabelsResolver

    field :timelogs, ::Types::TimelogType.connection_type, null: false,
      description: 'Time logged on issues and merge requests in the group and its subgroups.',
      extras: [:lookahead],
      complexity: 5,
      resolver: ::Resolvers::TimelogResolver

    field :descendant_groups, Types::GroupType.connection_type,
      null: true,
      description: 'List of descendant groups of this group.',
      complexity: 5,
      resolver: Resolvers::NestedGroupsResolver

    field :descendant_groups_count,
      GraphQL::Types::Int,
      null: false,
      description: 'Count of direct descendant groups of the group.'

    field :group_members_count,
      GraphQL::Types::Int,
      null: false,
      description: 'Count of direct members of the group.'

    field :projects_count,
      GraphQL::Types::Int,
      null: false,
      description: 'Count of direct projects in the group.'

    field :pipeline_analytics, Types::Ci::AnalyticsType,
      null: true,
      description: 'Pipeline analytics.',
      resolver: Resolvers::Ci::PipelineAnalyticsResolver

    field :ci_variables,
      Types::Ci::GroupVariableType.connection_type,
      null: true,
      description: "List of the group's CI/CD variables.",
      authorize: :admin_cicd_variables,
      resolver: Resolvers::Ci::VariablesResolver

    field :runners, Types::Ci::RunnerType.connection_type,
      null: true,
      resolver: Resolvers::Ci::GroupRunnersResolver,
      description: "Find runners visible to the current user."

    field :organizations, Types::CustomerRelations::OrganizationType.connection_type,
      null: true,
      description: "Find organizations of this group.",
      resolver: Resolvers::Crm::OrganizationsResolver

    field :organization_state_counts,
      Types::CustomerRelations::OrganizationStateCountsType,
      null: true,
      description: 'Counts of organizations by status for the group.',
      resolver: Resolvers::Crm::OrganizationStateCountsResolver

    field :contacts, Types::CustomerRelations::ContactType.connection_type,
      null: true,
      description: "Find contacts of this group.",
      resolver: Resolvers::Crm::ContactsResolver

    field :contact_state_counts,
      Types::CustomerRelations::ContactStateCountsType,
      null: true,
      description: 'Counts of contacts by state for the group.',
      resolver: Resolvers::Crm::ContactStateCountsResolver

    field :work_item_types, Types::WorkItems::TypeType.connection_type,
      resolver: Resolvers::WorkItems::TypesResolver,
      description: 'Work item types available to the group.'

    field :releases,
      Types::ReleaseType.connection_type,
      null: true,
      description: 'Releases belonging to projects in the group.',
      resolver: Resolvers::GroupReleasesResolver

    field :data_transfer, Types::DataTransfer::GroupDataTransferType,
      null: true,
      resolver: Resolvers::DataTransfer::GroupDataTransferResolver,
      description: 'Data transfer data point for a specific period. This is mocked data under a development feature flag.'

    field :work_items,
      null: true,
      description: 'Work items that belong to the namespace.',
      experiment: { milestone: '16.3' },
      resolver: ::Resolvers::Namespaces::WorkItemsResolver

    field :work_item, Types::WorkItemType,
      resolver: Resolvers::Namespaces::WorkItemResolver,
      experiment: { milestone: '16.4' },
      description: 'Find a work item by IID directly associated with the group.'

    field :work_item_state_counts,
      Types::WorkItemStateCountsType,
      null: true,
      experiment: { milestone: '16.7' },
      description: 'Counts of work items by state for the namespace.',
      resolver: Resolvers::Namespaces::WorkItemStateCountsResolver

    field :autocomplete_users,
      null: true,
      resolver: Resolvers::AutocompleteUsersResolver,
      description: 'Search users for autocompletion'

    field :lock_math_rendering_limits_enabled,
      GraphQL::Types::Boolean,
      null: true,
      method: :lock_math_rendering_limits_enabled?,
      description: 'Indicates if math rendering limits are locked for all descendant groups.'

    field :math_rendering_limits_enabled,
      GraphQL::Types::Boolean,
      null: true,
      method: :math_rendering_limits_enabled?,
      description: 'Indicates if math rendering limits are used for the group.'

    field :is_linked_to_subscription,
      GraphQL::Types::Boolean,
      null: true,
      method: :linked_to_subscription?,
      description: 'Indicates if group is linked to a subscription.'

    field :cluster_agents,
      ::Types::Clusters::AgentType.connection_type,
      extras: [:lookahead],
      null: true,
      description: 'Cluster agents associated with projects in the group and its subgroups.',
      resolver: ::Resolvers::Clusters::AgentsResolver

    field :archived, GraphQL::Types::Boolean,
      description: 'Indicates the archived status of the group.',
      experiment: { milestone: '18.3' },
      method: :self_or_ancestors_archived?

    field :marked_for_deletion, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if group or any ancestor is scheduled to be deleted.',
      method: :scheduled_for_deletion_in_hierarchy_chain?,
      experiment: { milestone: '18.2' }

    field :marked_for_deletion_on, ::Types::TimeType,
      null: true,
      description: 'Date when group was scheduled to be deleted.',
      experiment: { milestone: '16.11' }

    field :permanent_deletion_date, GraphQL::Types::String,
      null: true,
      description: "For groups pending deletion, returns the group's scheduled deletion date. " \
        'For groups not pending deletion, returns a theoretical date based on current settings ' \
        'if marked for deletion today.',
      experiment: { milestone: '16.11' }

    field :is_self_deletion_in_progress, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if group deletion is in progress.',
      method: :self_deletion_in_progress?,
      experiment: { milestone: '18.2' }

    field :is_self_deletion_scheduled, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if group deletion is scheduled.',
      method: :self_deletion_scheduled?,
      experiment: { milestone: '18.2' }

    field :project_statistics, Types::Namespaces::ProjectStatisticsType,
      method: :itself,
      null: true,
      description: 'Statistics of the projects in the group. Only available from [Query.groups](#querygroups).',
      experiment: { milestone: '18.2' }

    def label(title:)
      BatchLoader::GraphQL.for(title).batch(key: group) do |titles, loader, args|
        LabelsFinder
          .new(current_user, group: args[:key], title: titles)
          .execute
          .each { |label| loader.call(label.title, label) }
      end
    end

    def avatar_url
      object.avatar_url(only_path: false)
    end

    def parent
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Group, object.parent_id).find
    end

    def container_repositories_count
      group.container_repositories.size
    end

    def dependency_proxy_manifests
      group.dependency_proxy_manifests.order_id_desc
    end

    def dependency_proxy_image_count
      group.dependency_proxy_manifests.size
    end

    def dependency_proxy_blob_count
      group.dependency_proxy_blobs.size
    end

    def dependency_proxy_total_size
      ActiveSupport::NumberHelper.number_to_human_size(
        dependency_proxy_total_size_in_bytes
      )
    end

    def dependency_proxy_total_size_in_bytes
      dependency_proxy_total_size_bytes
    end

    def dependency_proxy_total_size_bytes
      group.dependency_proxy_manifests.sum(:size) + group.dependency_proxy_blobs.sum(:size)
    end

    def dependency_proxy_setting
      group.dependency_proxy_setting || group.create_dependency_proxy_setting
    end

    def descendant_groups_count
      BatchLoader::GraphQL.for(object.id).batch do |group_ids, loader|
        descendants_counts = Group.id_in(group_ids).descendant_groups_counts
        descendants_counts.each { |group_id, count| loader.call(group_id, count) }
      end
    end

    def emails_disabled
      !group.emails_enabled?
    end

    def projects_count
      BatchLoader::GraphQL.for(object.id).batch do |group_ids, loader|
        projects_counts = Group.id_in(group_ids).projects_counts
        projects_counts.each { |group_id, count| loader.call(group_id, count) }
      end
    end

    def group_members_count
      BatchLoader::GraphQL.for(object.id).batch do |group_ids, loader|
        members_counts = Group.id_in(group_ids).group_members_counts
        members_counts.each { |group_id, count| loader.call(group_id, count) }
      end
    end

    def max_access_level
      return Gitlab::Access::NO_ACCESS if current_user.nil?

      BatchLoader::GraphQL.for(object.id).batch do |group_ids, loader|
        current_user.max_member_access_for_group_ids(group_ids).each do |group_id, max_access_level|
          loader.call(group_id, max_access_level)
        end
      end
    end

    def organization_edit_path
      return if group.organization.nil?

      ::Gitlab::Routing.url_helpers.edit_groups_organization_path(
        group.organization,
        id: group.to_param
      )
    end

    def marked_for_deletion_on
      group.marked_for_deletion_on
    end

    def permanent_deletion_date
      permanent_deletion_date_formatted(group) || permanent_deletion_date_formatted
    end

    private

    def group
      object.respond_to?(:sync) ? object.sync : object
    end
  end
end

Types::GroupType.prepend_mod_with('Types::GroupType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ide_type.rb =====
# frozen_string_literal: true

module Types
  class IdeType < BaseObject
    graphql_name 'Ide'
    description 'IDE settings and feature flags.'

    authorize :read_user

    field :code_suggestions_enabled, GraphQL::Types::Boolean, null: false,
      description: 'Indicates whether AI assisted code suggestions are enabled.'

    def code_suggestions_enabled
      object.can?(:access_code_suggestions)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/import/import_source_enum.rb =====
# frozen_string_literal: true

module Types
  module Import
    class ImportSourceEnum < BaseEnum
      graphql_name 'ImportSource'
      description 'Import source'
      class << self
        private

        def import_source_description(import_source)
          return "Not imported" if import_source == :none

          import_source.to_s.titleize
        end
      end

      ::Import::HasImportSource::IMPORT_SOURCES.each_key do |import_source|
        value import_source.upcase, value: import_source.to_s, description: import_source_description(import_source)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/import/source_user_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Import
    class SourceUserSortEnum < BaseEnum
      graphql_name 'SourceUserSort'
      description 'Values for sorting the mapping of users on source instance to users on destination instance.'

      value 'STATUS_ASC', 'Status of the mapping by ascending order.', value: :status_asc
      value 'STATUS_DESC', 'Status of the mapping by descending order.', value: :status_desc
      value 'SOURCE_NAME_ASC', 'Instance source name by ascending order.', value: :source_name_asc
      value 'SOURCE_NAME_DESC', 'Instance source name by descending order.', value: :source_name_desc
      value 'ID_ASC', 'ID of the source user by ascending order.', value: :id_asc
      value 'ID_DESC', 'ID of the source user by descending order.', value: :id_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/import/source_user_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Import
    class SourceUserStatusEnum < BaseEnum
      graphql_name 'ImportSourceUserStatus'

      ::Import::SourceUser.state_machines[:status].states.each do |state|
        value state.name.upcase,
          description: "An import source user mapping that is #{state.human_name}.",
          value: state.value
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/import/source_user_type.rb =====
# frozen_string_literal: true

module Types
  module Import
    class SourceUserType < BaseObject
      graphql_name 'ImportSourceUser'

      authorize :admin_import_source_user

      field :id,
        Types::GlobalIDType[::Import::SourceUser],
        null: false,
        description: 'Global ID of the mapping of a user on source instance to a user on destination instance.'

      field :placeholder_user,
        Types::UserType,
        null: true,
        description: 'Placeholder user associated with the import source user.'

      field :reassign_to_user,
        Types::UserType,
        null: true,
        description: 'User that contributions are reassigned to.'

      field :reassigned_by_user,
        Types::UserType,
        null: true,
        description: 'User that did the reassignment.'

      # rubocop:disable GraphQL/ExtractType -- no need to extract allowed types into a separate field
      field :source_user_identifier,
        GraphQL::Types::String,
        null: false,
        description: 'ID of the user in the source instance.'

      field :source_username,
        GraphQL::Types::String,
        null: true,
        description: 'Username of user in the source instance.'

      field :source_name,
        GraphQL::Types::String,
        null: true,
        description: 'Name of user in the source instance.'

      field :source_hostname,
        GraphQL::Types::String,
        null: false,
        description: 'Source instance hostname.'
      # rubocop:enable GraphQL/ExtractType

      field :import_type,
        Types::Import::ImportSourceEnum,
        null: false,
        description: 'Name of the importer.'

      field :status,
        Types::Import::SourceUserStatusEnum,
        null: false,
        description: 'Status of the mapping.'

      field :reassignment_error,
        GraphQL::Types::String,
        description: 'Error message if reassignment failed.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp of when the source user was created.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/incident_management/escalation_status_enum.rb =====
# frozen_string_literal: true

module Types
  module IncidentManagement
    class EscalationStatusEnum < BaseEnum
      graphql_name 'IssueEscalationStatus'
      description 'Issue escalation status values'

      ::IncidentManagement::IssuableEscalationStatus.status_names.each do |status|
        value status.to_s.upcase, value: status, description: "#{::IncidentManagement::IssuableEscalationStatus::STATUS_DESCRIPTIONS[status]}."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/incident_management/timeline_event_tag_type.rb =====
# frozen_string_literal: true

module Types
  module IncidentManagement
    class TimelineEventTagType < BaseObject
      graphql_name 'TimelineEventTagType'

      description 'Describes a tag on an incident management timeline event.'

      authorize :read_incident_management_timeline_event_tag

      field :id,
        Types::GlobalIDType[::IncidentManagement::TimelineEventTag],
        null: false,
        description: 'ID of the timeline event tag.'

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the timeline event tag.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/incident_management/timeline_event_type.rb =====
# frozen_string_literal: true

module Types
  module IncidentManagement
    class TimelineEventType < BaseObject
      graphql_name 'TimelineEventType'
      description 'Describes an incident management timeline event'

      authorize :read_incident_management_timeline_event

      field :id,
        Types::GlobalIDType[::IncidentManagement::TimelineEvent],
        null: false,
        description: 'ID of the timeline event.'

      field :author,
        Types::UserType,
        null: true,
        description: 'User that created the timeline event.'

      field :updated_by_user,
        Types::UserType,
        null: true,
        description: 'User that updated the timeline event.'

      field :incident,
        Types::IssueType,
        null: false,
        description: 'Incident of the timeline event.'

      field :note,
        GraphQL::Types::String,
        null: true,
        description: 'Text note of the timeline event.'

      field :promoted_from_note,
        Types::Notes::NoteType,
        null: true,
        description: 'Note from which the timeline event was created.'

      field :editable,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates the timeline event is editable.'

      field :action,
        GraphQL::Types::String,
        null: false,
        description: 'Indicates the timeline event icon.'

      field :occurred_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp when the event occurred.'

      field :timeline_event_tags,
        ::Types::IncidentManagement::TimelineEventTagType.connection_type,
        null: true,
        description: 'Tags for the incident timeline event.',
        extras: [:lookahead],
        resolver: Resolvers::IncidentManagement::TimelineEventTagsResolver

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp when the event created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp when the event updated.'

      markdown_field :note_html, null: true, description: 'HTML note of the timeline event.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/integrations/exclusion_type.rb =====
# frozen_string_literal: true

module Types
  module Integrations
    class ExclusionType < BaseObject
      graphql_name 'IntegrationExclusion'
      description 'An integration to override the level settings of instance specific integrations.'
      authorize :admin_all_resources

      field :group, ::Types::GroupType,
        description: 'Group that has been excluded from the instance specific integration.'
      field :project, ::Types::ProjectType,
        description: 'Project that has been excluded from the instance specific integration.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/integrations/integration_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Integrations
    class IntegrationTypeEnum < BaseEnum
      graphql_name 'IntegrationType'
      description 'Integration Names'

      value 'BEYOND_IDENTITY', description: 'Beyond Identity.', value: 'beyond_identity'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/invitation_interface.rb =====
# frozen_string_literal: true

module Types
  module InvitationInterface
    include BaseInterface

    field :email, GraphQL::Types::String, null: false,
      description: 'Email of the member to invite.'

    field :access_level, Types::AccessLevelType, null: true,
      description: 'GitLab::Access level.'

    field :created_by, Types::UserType, null: true,
      description: 'User that authorized membership.'

    field :created_at, Types::TimeType, null: true,
      description: 'Date and time the membership was created.'

    field :updated_at, Types::TimeType, null: true,
      description: 'Date and time the membership was last updated.'

    field :expires_at, Types::TimeType, null: true,
      description: 'Date and time the membership expires.'

    field :user, Types::UserType, null: true,
      description: 'User that is associated with the member object.'

    definition_methods do
      def resolve_type(object, context)
        case object
        when GroupMember
          Types::GroupInvitationType
        when ProjectMember
          Types::ProjectInvitationType
        else
          raise ::Gitlab::Graphql::Errors::BaseError, "Unknown member type #{object.class.name}"
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuable_searchable_field_enum.rb =====
# frozen_string_literal: true

module Types
  class IssuableSearchableFieldEnum < BaseEnum
    graphql_name 'IssuableSearchableField'
    description 'Fields to perform the search in'

    Issuable::SEARCHABLE_FIELDS.each do |field|
      value field.upcase, value: field, description: "Search in #{field} field."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuable_severity_enum.rb =====
# frozen_string_literal: true

module Types
  class IssuableSeverityEnum < BaseEnum
    graphql_name 'IssuableSeverity'
    description 'Incident severity'

    ::IssuableSeverity.severities.keys.each do |severity|
      value severity.upcase, value: severity, description: "#{severity.titleize} severity"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuables/labels/search_field_list_enum.rb =====
# frozen_string_literal: true

module Types
  module Issuables
    module Labels
      class SearchFieldListEnum < BaseEnum
        graphql_name 'LabelSearchFieldList'
        description 'List of fields where the provided searchTerm should be looked up'

        value 'TITLE', 'Search in the label title.', value: :title
        value 'DESCRIPTION', 'Search in the label description.', value: :description
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuable_sort_enum.rb =====
# frozen_string_literal: true

module Types
  class IssuableSortEnum < SortEnum
    graphql_name 'IssuableSort'
    description 'Values for sorting issuables'

    value 'PRIORITY_ASC', 'Priority by ascending order.', value: :priority_asc
    value 'PRIORITY_DESC', 'Priority by descending order.', value: :priority_desc
    value 'LABEL_PRIORITY_ASC', 'Label priority by ascending order.', value: :label_priority_asc
    value 'LABEL_PRIORITY_DESC', 'Label priority by descending order.', value: :label_priority_desc
    value 'MILESTONE_DUE_ASC', 'Milestone due date by ascending order.', value: :milestone_due_asc
    value 'MILESTONE_DUE_DESC', 'Milestone due date by descending order.', value: :milestone_due_desc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuables/subscription_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Issuables
    class SubscriptionStatusEnum < BaseEnum
      graphql_name 'SubscriptionStatus'
      description 'Status of the subscription to an issuable.'

      value 'EXPLICITLY_SUBSCRIBED', 'User is explicitly subscribed to the issuable.',
        value: :explicitly_subscribed

      value 'EXPLICITLY_UNSUBSCRIBED', 'User is explicitly unsubscribed from the issuable.',
        value: :explicitly_unsubscribed
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuable_state_enum.rb =====
# frozen_string_literal: true

# DO NOT use this ENUM with issues. We need to define a new enum in places where we
# need to filter by state. locked is not a valid state filter for issues. More info in
# https://gitlab.com/gitlab-org/gitlab/-/issues/420667#note_1605900474
module Types
  class IssuableStateEnum < BaseEnum
    graphql_name 'IssuableState'
    description 'State of a GitLab issue or merge request'

    INVALID_LOCKED_MESSAGE = 'locked is not a valid state filter for issues.'

    value 'opened', description: 'In open state.'
    value 'closed', description: 'In closed state.'
    value 'locked', description: 'Discussion has been locked.'
    value 'all', description: 'All available.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuable_subscription_event_enum.rb =====
# frozen_string_literal: true

module Types
  class IssuableSubscriptionEventEnum < BaseEnum
    graphql_name 'IssuableSubscriptionEvent'
    description 'Values for subscribing and unsubscribing from issuables'

    value 'SUBSCRIBE', 'Subscribe to an issuable.', value: 'subscribe'
    value 'UNSUBSCRIBE', 'Unsubscribe from an issuable.', value: 'unsubscribe'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issuable_type.rb =====
# frozen_string_literal: true

module Types
  class IssuableType < BaseUnion
    graphql_name 'Issuable'
    description 'Represents an issuable.'

    possible_types Types::IssueType, Types::MergeRequestType, Types::WorkItemType

    def self.resolve_type(object, context)
      case object
      when WorkItem
        Types::WorkItemType
      when Issue
        Types::IssueType
      when MergeRequest
        Types::MergeRequestType
      else
        raise 'Unsupported issuable type'
      end
    end
  end
end

Types::IssuableType.prepend_mod_with('Types::IssuableType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_connection_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class IssueConnectionType < CountableConnectionType
  end
end

Types::IssueConnectionType.prepend_mod_with('Types::IssueConnectionType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issues/negated_issue_filter_input_type.rb =====
# frozen_string_literal: true

module Types
  module Issues
    class NegatedIssueFilterInputType < BaseInputObject
      graphql_name 'NegatedIssueFilterInput'

      argument :assignee_id, GraphQL::Types::String,
        required: false,
        description: 'ID of a user not assigned to the issues.'
      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Usernames of users not assigned to the issue.'
      argument :author_username, [GraphQL::Types::String],
        required: false,
        description: "Username of a user who didn't author the issue."
      argument :iids, [GraphQL::Types::String],
        required: false,
        description: 'List of IIDs of issues to exclude. For example, `[1, 2]`.'
      argument :label_name, [GraphQL::Types::String],
        required: false,
        description: 'Labels not applied to the issue.'
      argument :milestone_title, [GraphQL::Types::String],
        required: false,
        description: 'Milestone not applied to the issue.'
      argument :milestone_wildcard_id, ::Types::NegatedMilestoneWildcardIdEnum,
        required: false,
        description: 'Filter by negated milestone wildcard values.'
      argument :my_reaction_emoji, GraphQL::Types::String,
        required: false,
        description: 'Filter by reaction emoji applied by the current user.'
      argument :release_tag, [GraphQL::Types::String],
        required: false,
        description: "Release tag not associated with the issue's milestone. Ignored when parent is a group."
      argument :types, [Types::IssueTypeEnum],
        as: :issue_types,
        description: 'Filters out issues by the given issue types.',
        required: false

      validates mutually_exclusive: [:milestone_title, :milestone_wildcard_id]
    end
  end
end

Types::Issues::NegatedIssueFilterInputType.prepend_mod_with('Types::Issues::NegatedIssueFilterInputType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_sort_enum.rb =====
# frozen_string_literal: true

module Types
  class IssueSortEnum < IssuableSortEnum
    graphql_name 'IssueSort'
    description 'Values for sorting issues'

    value 'DUE_DATE_ASC', 'Due date by ascending order.', value: :due_date_asc
    value 'DUE_DATE_DESC', 'Due date by descending order.', value: :due_date_desc
    value 'RELATIVE_POSITION_ASC', 'Relative position by ascending order.', value: :relative_position_asc
    value 'SEVERITY_ASC', 'Severity from less critical to more critical.', value: :severity_asc
    value 'SEVERITY_DESC', 'Severity from more critical to less critical.', value: :severity_desc
    value 'TITLE_ASC', 'Title by ascending order.', value: :title_asc
    value 'TITLE_DESC', 'Title by descending order.', value: :title_desc
    value 'POPULARITY_ASC', 'Number of upvotes (awarded "thumbs up" emoji) by ascending order.', value: :popularity_asc
    value 'POPULARITY_DESC', 'Number of upvotes (awarded "thumbs up" emoji) by descending order.', value: :popularity_desc
    value 'ESCALATION_STATUS_ASC', 'Status from triggered to resolved.', value: :escalation_status_asc
    value 'ESCALATION_STATUS_DESC', 'Status from resolved to triggered.', value: :escalation_status_desc
    value 'CLOSED_AT_ASC', 'Closed time by ascending order.', value: :closed_at_asc
    value 'CLOSED_AT_DESC', 'Closed time by descending order.', value: :closed_at_desc
  end
end

Types::IssueSortEnum.prepend_mod_with('Types::IssueSortEnum')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_state_enum.rb =====
# frozen_string_literal: true

module Types
  class IssueStateEnum < IssuableStateEnum
    graphql_name 'IssueState'
    description 'State of a GitLab issue'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_state_event_enum.rb =====
# frozen_string_literal: true

module Types
  class IssueStateEventEnum < BaseEnum
    graphql_name 'IssueStateEvent'
    description 'Values for issue state events'

    value 'REOPEN', 'Reopens the issue.', value: 'reopen'
    value 'CLOSE', 'Closes the issue.', value: 'close'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_status_counts_type.rb =====
# frozen_string_literal: true

module Types
  class IssueStatusCountsType < BaseObject
    graphql_name 'IssueStatusCountsType'
    description 'Represents total number of issues for the represented statuses'

    authorize :read_issue

    def self.available_issue_states
      @available_issue_states ||= Issue.available_states.keys.push('all')
    end

    ::Gitlab::IssuablesCountForState::STATES.each do |state|
      next unless available_issue_states.include?(state.downcase)

      field state,
        GraphQL::Types::Int,
        null: true,
        description: "Number of issues with status #{state.upcase} for the project"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issues/unioned_issue_filter_input_type.rb =====
# frozen_string_literal: true

module Types
  module Issues
    class UnionedIssueFilterInputType < BaseInputObject
      graphql_name 'UnionedIssueFilterInput'

      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Filters issues that are assigned to at least one of the given users.'
      argument :author_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Filters issues that are authored by one of the given users.'
      argument :label_names, [GraphQL::Types::String],
        required: false,
        description: 'Filters issues that have at least one of the given labels.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_type_enum.rb =====
# frozen_string_literal: true

module Types
  class IssueTypeEnum < BaseEnum
    graphql_name 'IssueType'
    description 'Issue type'

    ::WorkItems::Type.allowed_types_for_issues.each do |issue_type|
      value issue_type.upcase, value: issue_type, description: "#{issue_type.titleize} issue type"
    end

    value 'OBJECTIVE', value: 'objective',
      description: 'Objective issue type. Available only when feature flag `okrs_mvc` is enabled.',
      experiment: { milestone: '15.6' }

    value 'KEY_RESULT', value: 'key_result',
      description: 'Key Result issue type. Available only when feature flag `okrs_mvc` is enabled.',
      experiment: { milestone: '15.7' }
    value 'EPIC', value: 'epic',
      description: 'Epic issue type. ' \
        'Available only when feature epics is available.',
      experiment: { milestone: '16.7' }
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/issue_type.rb =====
# frozen_string_literal: true

module Types
  class IssueType < BaseObject
    graphql_name 'Issue'

    connection_type_class Types::IssueConnectionType

    implements Types::Notes::NoteableInterface
    implements Types::CurrentUserTodos
    implements Types::TodoableInterface

    authorize :read_issue

    expose_permissions Types::PermissionTypes::Issue

    present_using IssuePresenter

    field :description, GraphQL::Types::String, null: true,
      description: 'Description of the issue.'
    field :id, GraphQL::Types::ID, null: false,
      description: "ID of the issue."
    field :iid, GraphQL::Types::String, null: false,
      description: "Internal ID of the issue."
    field :state, IssueStateEnum, null: false,
      description: 'State of the issue.'
    field :title, GraphQL::Types::String, null: false,
      description: 'Title of the issue.'

    field :reference, GraphQL::Types::String, null: false,
      description: 'Internal reference of the issue. Returned in shortened format by default.',
      method: :to_reference do
      argument :full, GraphQL::Types::Boolean, required: false, default_value: false,
        description: 'Boolean option specifying whether the reference should be returned in full.'
    end

    field :author, Types::UserType, null: false,
      description: 'User that created the issue.'

    field :assignees, Types::UserType.connection_type, null: true,
      description: 'Assignees of the issue.'

    field :updated_by, Types::UserType, null: true,
      description: 'User that last updated the issue.'

    field :labels, Types::LabelType.connection_type,
      null: true,
      description: 'Labels of the issue.',
      resolver: Resolvers::BulkLabelsResolver
    field :milestone, Types::MilestoneType, null: true,
      description: 'Milestone of the issue.'

    field :confidential, GraphQL::Types::Boolean, null: false,
      description: 'Indicates the issue is confidential.'
    field :discussion_locked, GraphQL::Types::Boolean, null: false,
      description: 'Indicates discussion is locked on the issue.'
    field :downvotes, GraphQL::Types::Int,
      null: false,
      description: 'Number of downvotes the issue has received.',
      resolver: Resolvers::DownVotesCountResolver
    field :due_date, Types::TimeType, null: true,
      description: 'Due date of the issue.'
    field :hidden, GraphQL::Types::Boolean, null: true,
      description: 'Indicates the issue is hidden because the author has been banned.', method: :hidden?
    field :merge_requests_count, GraphQL::Types::Int, null: false,
      description: 'Number of merge requests that close the issue on merge.',
      resolver: Resolvers::MergeRequestsCountResolver

    field :related_merge_requests, Types::MergeRequestType.connection_type,
      null: true,
      resolver: ::Resolvers::MergeRequests::IssueRelatedResolver,
      description: 'Merge requests related to the issue. This field can only be resolved for one issue in any single request.' do
        extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
      end

    field :relative_position, GraphQL::Types::Int, null: true,
      description: 'Relative position of the issue (used for positioning in epic tree and issue boards).'
    field :upvotes, GraphQL::Types::Int,
      null: false,
      description: 'Number of upvotes the issue has received.',
      resolver: Resolvers::UpVotesCountResolver

    field :user_discussions_count, GraphQL::Types::Int, null: false,
      description: 'Number of user discussions in the issue.',
      resolver: Resolvers::UserDiscussionsCountResolver
    field :user_notes_count, GraphQL::Types::Int, null: false,
      description: 'Number of user notes of the issue.',
      resolver: Resolvers::UserNotesCountResolver
    field :web_path, GraphQL::Types::String, null: false, method: :issue_path,
      description: 'Web path of the issue.'
    field :web_url, GraphQL::Types::String, null: false,
      description: 'Web URL of the issue.'

    field :emails_disabled, GraphQL::Types::Boolean, null: false,
      method: :parent_emails_disabled?,
      description: 'Indicates if the parent project or group has email notifications disabled: `true` if email notifications are disabled.',
      deprecated: { reason: 'Use `emails_enabled`', milestone: '16.3' }

    field :emails_enabled, GraphQL::Types::Boolean, null: false,
      method: :parent_emails_enabled?,
      description: 'Indicates if the parent project or group has email notifications disabled: `false` if email notifications are disabled.'

    field :human_time_estimate, GraphQL::Types::String, null: true,
      description: 'Human-readable time estimate of the issue.'
    field :human_total_time_spent, GraphQL::Types::String, null: true,
      description: 'Human-readable total time reported as spent on the issue.'
    field :participants, Types::UserType.connection_type, null: true, complexity: 5,
      description: 'List of participants in the issue.',
      resolver: Resolvers::Users::ParticipantsResolver
    field :subscribed, GraphQL::Types::Boolean, method: :subscribed?, null: false, complexity: 5,
      description: 'Indicates the currently logged in user is subscribed to the issue.'
    field :time_estimate, GraphQL::Types::Int, null: false,
      description: 'Time estimate of the issue.'
    field :total_time_spent, GraphQL::Types::Int, null: false,
      description: 'Total time (in seconds) reported as spent on the issue.'

    field :closed_at, Types::TimeType, null: true,
      description: 'Timestamp of when the issue was closed.'

    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of when the issue was created.'
    field :updated_at, Types::TimeType, null: false,
      description: 'Timestamp of when the issue was last updated.'

    field :task_completion_status, Types::TaskCompletionStatus, null: false,
      description: 'Task completion status of the issue.'

    field :design_collection, Types::DesignManagement::DesignCollectionType, null: true,
      description: 'Collection of design images associated with the issue.'

    field :type, Types::IssueTypeEnum, null: true,
      method: :issue_type,
      description: 'Type of the issue.'

    field :alert_management_alert,
      Types::AlertManagement::AlertType,
      null: true,
      description: 'Alert associated to the issue.',
      deprecated: { reason: 'Use `alert_management_alerts`', milestone: '15.6' }

    field :alert_management_alerts,
      Types::AlertManagement::AlertType.connection_type,
      null: true,
      description: 'Alert Management alerts associated to this issue.',
      extras: [:lookahead],
      resolver: Resolvers::AlertManagement::AlertResolver

    field :severity, Types::IssuableSeverityEnum, null: true,
      description: 'Severity level of the incident.'

    field :moved, GraphQL::Types::Boolean, method: :moved?, null: true,
      description: 'Indicates if issue got moved from other project.'

    field :moved_to, Types::IssueType, null: true,
      description: 'Updated Issue after it got moved to another project.'

    field :closed_as_duplicate_of, Types::IssueType, null: true,
      description: 'Issue the issue was closed as a duplicate of.'

    field :create_note_email, GraphQL::Types::String, null: true,
      description: 'User specific email address for the issue.'

    field :timelogs, Types::TimelogType.connection_type, null: false,
      description: 'Timelogs on the issue.'

    field :project_id, GraphQL::Types::Int, null: true,
      description: 'ID of the issue project.'

    field :customer_relations_contacts, Types::CustomerRelations::ContactType.connection_type, null: true,
      description: 'Customer relations contacts of the issue.'

    field :escalation_status, Types::IncidentManagement::EscalationStatusEnum, null: true,
      description: 'Escalation status of the issue.'

    field :external_author, GraphQL::Types::String, null: true, description: 'Email address of non-GitLab user reporting the issue. For guests, the email address is obfuscated.'

    field :linked_work_items, ::Types::WorkItems::LinkedItemType.connection_type,
      null: true, complexity: 5, resolver: Resolvers::WorkItems::LinkedItemsResolver,
      description: 'Work items linked to the issue.', extras: [:lookahead],
      experiment: { milestone: '17.8' }

    markdown_field :title_html, null: true
    markdown_field :description_html, null: true

    def author
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.author_id).find
    end

    def updated_by
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.updated_by_id).find
    end

    def milestone
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Milestone, object.milestone_id).find
    end

    def moved_to
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Issue, object.moved_to_id).find
    end

    def closed_as_duplicate_of
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Issue, object.duplicated_to_id).find
    end

    def discussion_locked
      !!object.discussion_locked
    end

    def create_note_email
      object.creatable_note_email_address(context[:current_user])
    end

    def escalation_status
      object.supports_escalation? ? object.escalation_status&.status_name : nil
    end
  end
end

Types::IssueType.prepend_mod_with('Types::IssueType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/jira_import_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # Authorization is at project level for owners or admins
  class JiraImportType < BaseObject
    graphql_name 'JiraImport'

    field :created_at, Types::TimeType, null: true,
      description: 'Timestamp of when the Jira import was created.'
    field :failed_to_import_count, GraphQL::Types::Int, null: false,
      description: 'Count of issues that failed to import.'
    field :imported_issues_count, GraphQL::Types::Int, null: false,
      description: 'Count of issues that were successfully imported.'
    field :jira_project_key, GraphQL::Types::String, null: false,
      description: 'Project key for the imported Jira project.'
    field :scheduled_at, Types::TimeType, null: true,
      description: 'Timestamp of when the Jira import was scheduled.'
    field :scheduled_by, Types::UserType, null: true,
      description: 'User that started the Jira import.'
    field :total_issue_count, GraphQL::Types::Int, null: false,
      description: 'Total count of issues that were attempted to import.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/jira_users_mapping_input_type.rb =====
# frozen_string_literal: true

module Types
  class JiraUsersMappingInputType < BaseInputObject
    graphql_name 'JiraUsersMappingInputType'

    argument :gitlab_id,
      GraphQL::Types::Int,
      required: false,
      description: 'ID of the GitLab user.'
    argument :jira_account_id,
      GraphQL::Types::String,
      required: true,
      description: 'Jira account ID of the user.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/jira_user_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # Authorization is at project level for owners or admins on mutation level
  class JiraUserType < BaseObject
    graphql_name 'JiraUser'

    field :gitlab_id, GraphQL::Types::Int, null: true,
      description: 'ID of the matched GitLab user.'
    field :gitlab_name, GraphQL::Types::String, null: true,
      description: 'Name of the matched GitLab user.'
    field :gitlab_username, GraphQL::Types::String, null: true,
      description: 'Username of the matched GitLab user.'
    field :jira_account_id, GraphQL::Types::String, null: false,
      description: 'Account ID of the Jira user.'
    field :jira_display_name, GraphQL::Types::String, null: false,
      description: 'Display name of the Jira user.'
    field :jira_email,
      GraphQL::Types::String,
      null: true,
      description: 'Email of the Jira user, returned only for users with public emails.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/kas/agent_configuration_type.rb =====
# frozen_string_literal: true

module Types
  module Kas
    # rubocop: disable Graphql/AuthorizeTypes
    class AgentConfigurationType < BaseObject
      graphql_name 'AgentConfiguration'
      description 'Configuration details for an Agent'

      field :agent_name,
        GraphQL::Types::String,
        null: true,
        description: 'Name of the agent.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/kas/agent_connection_type.rb =====
# frozen_string_literal: true

module Types
  module Kas
    # rubocop: disable Graphql/AuthorizeTypes
    class AgentConnectionType < BaseObject
      graphql_name 'ConnectedAgent'
      description 'Connection details for an Agent'

      field :connected_at,
        Types::TimeType,
        null: true,
        description: 'When the connection was established.'

      field :connection_id,
        GraphQL::Types::BigInt,
        null: true,
        description: 'ID of the connection.'

      field :metadata,
        Types::Kas::AgentMetadataType,
        method: :agent_meta,
        null: true,
        description: 'Information about the Agent.'

      field :warnings,
        [Types::Kas::AgentWarningType],
        null: true,
        description: 'Agent warnings list.'

      def connected_at
        Time.at(object.connected_at.seconds)
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/kas/agent_metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Kas
    # rubocop: disable Graphql/AuthorizeTypes
    class AgentMetadataType < BaseObject
      graphql_name 'AgentMetadata'
      description 'Information about a connected Agent'

      field :version,
        GraphQL::Types::String,
        null: true,
        description: 'Agent version tag.'

      field :commit,
        GraphQL::Types::String,
        method: :commit_id,
        null: true,
        description: 'Agent version commit.'

      field :pod_namespace,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace of the pod running the Agent.'

      field :pod_name,
        GraphQL::Types::String,
        null: true,
        description: 'Name of the pod running the Agent.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/kas/agent_version_warning_type.rb =====
# frozen_string_literal: true

module Types
  module Kas
    # rubocop: disable Graphql/AuthorizeTypes -- authorization is performed outside
    class AgentVersionWarningType < BaseObject
      graphql_name 'AgentVersionWarning'
      description 'Version-related warning for a connected Agent'

      field :message,
        GraphQL::Types::String,
        null: true,
        description: 'Warning message related to the version.'

      field :type,
        GraphQL::Types::String,
        null: true,
        description: 'Warning type related to the version.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/kas/agent_warning_type.rb =====
# frozen_string_literal: true

require_relative 'agent_version_warning_type'

module Types
  module Kas
    # rubocop: disable Graphql/AuthorizeTypes -- authorization is performed outside
    class AgentWarningType < BaseObject
      graphql_name 'AgentWarning'
      description 'Warning object for a connected Agent'

      field :version,
        Types::Kas::AgentVersionWarningType,
        null: true,
        description: 'Agent warning related to the version.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/key_type.rb =====
# frozen_string_literal: true

module Types
  class KeyType < Types::BaseObject # rubocop:disable Graphql/AuthorizeTypes
    graphql_name 'Key'
    description 'Represents an SSH key.'

    implements Types::TodoableInterface

    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of when the key was created.'
    field :expires_at, Types::TimeType, null: false,
      description: "Timestamp of when the key expires. It's null if it never expires."
    field :id, GraphQL::Types::ID, null: false, description: 'ID of the key.'
    field :key, GraphQL::Types::String, null: false, method: :publishable_key,
      description: 'Public key of the key pair.'
    field :title, GraphQL::Types::String, null: false, description: 'Title of the key.'

    def web_url
      Gitlab::UrlBuilder.build(object)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/label_interface.rb =====
# frozen_string_literal: true

module Types
  module LabelInterface # rubocop:disable Gitlab/BoundedContexts -- existing Label modules/classes are not bounded
    include BaseInterface

    field :color, GraphQL::Types::String, null: false,
      description: 'Background color of the label.'
    field :created_at, Types::TimeType, null: false,
      description: 'When the label was created.'
    field :description,
      GraphQL::Types::String,
      null: true,
      description: 'Description of the label (Markdown rendered as HTML for caching).'
    field :text_color, GraphQL::Types::String, null: false,
      description: 'Text color of the label.'
    field :title, GraphQL::Types::String, null: false,
      description: 'Content of the label.'
    field :updated_at, Types::TimeType, null: false,
      description: 'When the label was last updated.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/label_type.rb =====
# frozen_string_literal: true

module Types
  class LabelType < BaseObject
    graphql_name 'Label'

    implements LabelInterface

    connection_type_class Types::CountableConnectionType

    authorize :read_label

    field :id, Types::GlobalIDType[::Label],
      null: false,
      description: 'Global ID of the label.'

    field :archived, GraphQL::Types::Boolean, null: false, description: 'Indicates the label is archived.'

    field :lock_on_merge, GraphQL::Types::Boolean, null: false,
      description: 'Indicates this label is locked for merge requests ' \
        'that have been merged.'

    markdown_field :description_html, null: true
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/limited_countable_connection_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class LimitedCountableConnectionType < GraphQL::Types::Relay::BaseConnection
    COUNT_LIMIT = 1000
    COUNT_DESCRIPTION = "Limited count of collection. Returns limit + 1 for counts greater than the limit."

    field :count, GraphQL::Types::Int, null: false, description: COUNT_DESCRIPTION do
      argument :limit, GraphQL::Types::Int,
        required: false, default_value: COUNT_LIMIT,
        validates: { numericality: { greater_than: 0, less_than_or_equal_to: COUNT_LIMIT } },
        description: "Limit value to be applied to the count query. Default is 1000."
    end

    def count(limit:)
      relation = object.items

      if relation.respond_to?(:page)
        relation.page.total_count_with_limit(:all, limit: limit)
      else
        [relation.size, limit.next].min
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/member_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  class MemberAccessLevelEnum < BaseEnum
    graphql_name 'MemberAccessLevel'
    description 'Access level of a group or project member'

    def self.descriptions
      Gitlab::Access.option_descriptions
    end

    Gitlab::Access.options_with_owner.each do |key, value|
      value key.upcase, value: value, description: descriptions[value]
    end
  end
end

Types::MemberAccessLevelEnum.prepend_mod_with('Types::MemberAccessLevelEnum')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/member_interface.rb =====
# frozen_string_literal: true

module Types
  module MemberInterface
    include BaseInterface

    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the member.'

    field :access_level, Types::AccessLevelType, null: true,
      description: 'GitLab::Access level.'

    field :created_by, Types::UserType, null: true,
      description: 'User that authorized membership.'

    field :created_at, Types::TimeType, null: true,
      description: 'Date and time the membership was created.'

    field :updated_at, Types::TimeType, null: true,
      description: 'Date and time the membership was last updated.'

    field :expires_at, Types::TimeType, null: true,
      description: 'Date and time the membership expires.'

    field :user, Types::UserType, null: true,
      description: 'User that is associated with the member object.'

    field :merge_request_interaction, Types::UserMergeRequestInteractionType,
      null: true,
      description: 'Find a merge request.' do
      argument :id, ::Types::GlobalIDType[::MergeRequest], required: true, description: 'Global ID of the merge request.'
    end

    definition_methods do
      def resolve_type(object, context)
        case object
        when GroupMember
          Types::GroupMemberType
        when ProjectMember
          Types::ProjectMemberType
        else
          raise ::Gitlab::Graphql::Errors::BaseError, "Unknown member type #{object.class.name}"
        end
      end
    end

    def merge_request_interaction(id: nil)
      Gitlab::Graphql::Lazy.with_value(GitlabSchema.object_from_id(id, expected_class: ::MergeRequest)) do |merge_request|
        ::Users::MergeRequestInteraction.new(user: object.user, merge_request: merge_request) if merge_request
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/member_sort_enum.rb =====
# frozen_string_literal: true

module Types
  class MemberSortEnum < SortEnum
    graphql_name 'MemberSort'
    description 'Values for sorting members'

    value 'ACCESS_LEVEL_ASC', 'Access level ascending order.', value: :access_level_asc
    value 'ACCESS_LEVEL_DESC', 'Access level descending order.', value: :access_level_desc
    value 'USER_FULL_NAME_ASC', "User's full name ascending order.", value: :name_asc
    value 'USER_FULL_NAME_DESC', "User's full name descending order.", value: :name_desc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_request_connection_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class MergeRequestConnectionType < Types::CountableConnectionType
    field :total_time_to_merge,
      GraphQL::Types::Float,
      null: true,
      description: 'Total sum of time to merge, in seconds, for the collection of merge requests.'

    def total_time_to_merge
      object.items.without_order.total_time_to_merge
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_request_review_state_enum.rb =====
# frozen_string_literal: true

module Types
  class MergeRequestReviewStateEnum < BaseEnum
    graphql_name 'MergeRequestReviewState'
    description 'State of a review of a GitLab merge request.'

    value 'UNREVIEWED', value: 'unreviewed',
      description: 'Awaiting review from merge request reviewer.'
    value 'REVIEWED', value: 'reviewed',
      description: 'Merge request reviewer has reviewed.'
    value 'REQUESTED_CHANGES', value: 'requested_changes',
      description: 'Merge request reviewer has requested changes.'
    value 'APPROVED', value: 'approved',
      description: 'Merge request reviewer has approved the changes.'
    value 'UNAPPROVED', value: 'unapproved',
      description: 'Merge request reviewer removed their approval of the changes.'
    value 'REVIEW_STARTED', value: 'review_started',
      description: 'Merge request reviewer has started a review.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/assignee_type.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class AssigneeType < ::Types::UserType
      graphql_name 'MergeRequestAssignee'
      description 'A user assigned to a merge request.'

      include ::Types::MergeRequests::InteractsWithMergeRequest

      authorize :read_user
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/author_type.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class AuthorType < ::Types::UserType
      graphql_name 'MergeRequestAuthor'
      description 'The author of the merge request.'

      include ::Types::MergeRequests::InteractsWithMergeRequest

      authorize :read_user
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/dashboard_list_type_enum.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class DashboardListTypeEnum < BaseEnum
      graphql_name 'MergeRequestsDashboardListType'
      description 'Values for merge request dashboard list type'

      value 'ACTION_BASED', 'Action based list rendering.', value: 'action_based'
      value 'ROLE_BASED', 'Role based list rendering.', value: 'role_based'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/detailed_merge_status_enum.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class DetailedMergeStatusEnum < BaseEnum
      graphql_name 'DetailedMergeStatus'
      description 'Detailed representation of whether a GitLab merge request can be merged.'

      value 'UNCHECKED',
        value: :unchecked,
        description: 'Merge status has not been checked.'
      value 'CHECKING',
        value: :checking,
        description: 'Currently checking for mergeability.'
      value 'MERGEABLE',
        value: :mergeable,
        description: 'Branch can be merged.'
      value 'COMMITS_STATUS',
        value: :commits_status,
        description: 'Source branch exists and contains commits.'
      value 'CI_MUST_PASS',
        value: :ci_must_pass,
        description: 'Pipeline must succeed before merging.'
      value 'CI_STILL_RUNNING',
        value: :ci_still_running,
        description: 'Pipeline is still running.'
      value 'DISCUSSIONS_NOT_RESOLVED',
        value: :discussions_not_resolved,
        description: 'Discussions must be resolved before merging.'
      value 'DRAFT_STATUS',
        value: :draft_status,
        description: 'Merge request must not be draft before merging.'
      value 'NOT_OPEN',
        value: :not_open,
        description: 'Merge request must be open before merging.'
      value 'NOT_APPROVED',
        value: :not_approved,
        description: 'Merge request must be approved before merging.'
      value 'BLOCKED_STATUS',
        value: :merge_request_blocked,
        description: 'Merge request dependencies must be merged.'
      value 'EXTERNAL_STATUS_CHECKS',
        value: :status_checks_must_pass,
        description: 'Status checks must pass.'
      value 'PREPARING',
        value: :preparing,
        description: 'Merge request diff is being created.'
      value 'JIRA_ASSOCIATION',
        value: :jira_association_missing,
        description: 'Either the title or description must reference a Jira issue.'
      value 'CONFLICT',
        value: :conflict,
        description: 'There are conflicts between the source and target branches.'
      value 'NEED_REBASE',
        value: :need_rebase,
        description: 'Merge request needs to be rebased.'
      value 'APPROVALS_SYNCING',
        value: :approvals_syncing,
        description: 'Merge request approvals currently syncing.'
      value 'LOCKED_PATHS',
        value: :locked_paths,
        description: 'Merge request includes locked paths.'
      value 'LOCKED_LFS_FILES',
        value: :locked_lfs_files,
        description: 'Merge request includes locked LFS files.'
      value 'MERGE_TIME',
        value: :merge_time,
        description: 'Merge request may not be merged until after the specified time.'
      value 'SECURITY_POLICIES_VIOLATIONS',
        value: :security_policy_violations,
        description: 'All policy rules must be satisfied.'
      value 'TITLE_NOT_MATCHING',
        value: :title_regex,
        description: 'Merge request title does not match required regex.'
    end
  end
end

Types::MergeRequests::DetailedMergeStatusEnum.prepend_mod_with('Types::MergeRequests::DetailedMergeStatusEnum')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/interacts_with_merge_request.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    module InteractsWithMergeRequest
      extend ActiveSupport::Concern

      included do
        field :merge_request_interaction,
          type: ::Types::UserMergeRequestInteractionType,
          null: true,
          extras: [:parent],
          description: "Details of the user's interactions with the merge request."
      end

      def merge_request_interaction(parent:, id: nil)
        # need the connection parent if called from a connection node:
        parent = parent.parent if parent.try(:field)&.connection?
        ::Users::MergeRequestInteraction.new(user: object, merge_request: parent, current_user: current_user)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/mergeability_check_identifier_enum.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class MergeabilityCheckIdentifierEnum < BaseEnum
      graphql_name 'MergeabilityCheckIdentifier'
      description 'Representation of mergeability check identifier.'

      MergeRequest.all_mergeability_checks.each do |check_class|
        identifier = check_class.identifier.to_s

        value identifier.upcase,
          value: identifier,
          description: check_class.description
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/mergeability_check_status_enum.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class MergeabilityCheckStatusEnum < BaseEnum
      graphql_name 'MergeabilityCheckStatus'
      description 'Representation of whether a mergeability check passed, checking, failed or is inactive.'

      value 'SUCCESS',
        value: 'success',
        description: 'Mergeability check has passed.'

      value 'CHECKING',
        value: 'checking',
        description: 'Mergeability check is being checked.'

      value 'FAILED',
        value: 'failed',
        description: 'Mergeability check has failed. The merge request cannot be merged.'

      value 'INACTIVE',
        value: 'inactive',
        description: 'Mergeability check is disabled via settings.'

      value 'WARNING',
        value: 'warning',
        description: 'Mergeability check has passed with a warning.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/mergeability_check_type.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class MergeabilityCheckType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
      graphql_name 'MergeRequestMergeabilityCheck'
      description 'Mergeability check of the merge request.'

      field :identifier,
        ::Types::MergeRequests::MergeabilityCheckIdentifierEnum,
        null: false,
        description: 'Identifier of the mergeability check.'

      field :status,
        ::Types::MergeRequests::MergeabilityCheckStatusEnum,
        null: false,
        description: 'Status of the mergeability check.'

      def status
        object.status.to_s
      end

      def identifier
        object.identifier.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/merge_status_enum.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class MergeStatusEnum < BaseEnum
      graphql_name 'MergeStatus'
      description 'Representation of whether a GitLab merge request can be merged.'

      value 'UNCHECKED',
        value: 'unchecked',
        description: 'Merge status has not been checked.'
      value 'CHECKING',
        value: 'checking',
        description: 'Currently checking for mergeability.'
      value 'CAN_BE_MERGED',
        value: 'can_be_merged',
        description: 'There are no conflicts between the source and target branches.'
      value 'CANNOT_BE_MERGED',
        value: 'cannot_be_merged',
        description: 'There are conflicts between the source and target branches.'
      value 'CANNOT_BE_MERGED_RECHECK',
        value: 'cannot_be_merged_recheck',
        description: 'Currently unchecked. The previous state was `CANNOT_BE_MERGED`.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_request_sort_enum.rb =====
# frozen_string_literal: true

module Types
  class MergeRequestSortEnum < IssuableSortEnum
    graphql_name 'MergeRequestSort'
    description 'Values for sorting merge requests'

    value 'MERGED_AT_ASC', 'Merge time by ascending order.', value: :merged_at_asc
    value 'MERGED_AT_DESC', 'Merge time by descending order.', value: :merged_at_desc
    value 'CLOSED_AT_ASC', 'Closed time by ascending order.', value: :closed_at_asc
    value 'CLOSED_AT_DESC', 'Closed time by descending order.', value: :closed_at_desc
    value 'TITLE_ASC', 'Title by ascending order.', value: :title_asc
    value 'TITLE_DESC', 'Title by descending order.', value: :title_desc
    value 'POPULARITY_ASC', 'Number of upvotes (awarded "thumbs up" emoji) by ascending order.', value: :popularity_asc
    value 'POPULARITY_DESC', 'Number of upvotes (awarded "thumbs up" emoji) by descending order.',
      value: :popularity_desc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/participant_type.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class ParticipantType < ::Types::UserType
      graphql_name 'MergeRequestParticipant'
      description 'A user participating in a merge request.'

      include ::Types::MergeRequests::InteractsWithMergeRequest

      authorize :read_user
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/reviewer_type.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class ReviewerType < ::Types::UserType
      graphql_name 'MergeRequestReviewer'
      description 'A user assigned to a merge request as a reviewer.'

      include ::Types::MergeRequests::InteractsWithMergeRequest

      authorize :read_user
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_request_state_enum.rb =====
# frozen_string_literal: true

module Types
  class MergeRequestStateEnum < IssuableStateEnum
    graphql_name 'MergeRequestState'
    description 'State of a GitLab merge request'

    value 'merged', description: 'Merge request has been merged.'
    value 'opened', description: 'Opened merge request.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_request_state_event_enum.rb =====
# frozen_string_literal: true

module Types
  class MergeRequestStateEventEnum < BaseEnum
    graphql_name 'MergeRequestNewState'
    description 'New state to apply to a merge request.'

    value 'OPEN',
      value: 'reopen',
      description: 'Open the merge request if it is closed.'

    value 'CLOSED',
      value: 'close',
      description: 'Close the merge request if it is open.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_requests/unioned_merge_request_filter_input_type.rb =====
# frozen_string_literal: true

module Types
  module MergeRequests
    class UnionedMergeRequestFilterInputType < BaseInputObject
      graphql_name 'UnionedMergeRequestFilterInput'

      argument :reviewer_wildcard, ::Types::ReviewerWildcardIdEnum,
        required: false,
        description: 'Filter by reviewer presence.',
        experiment: { milestone: '17.11' }

      argument :only_reviewer_username, GraphQL::Types::String,
        required: false,
        experiment: { milestone: '17.11' },
        description: <<~DESC
          Filters merge requests that have no reviewer OR only reviewer. Only compatible with reviewerWildcard.
        DESC

      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Filters MRs that are assigned to at least one of the given users.'

      argument :review_states, [::Types::MergeRequestReviewStateEnum],
        required: false,
        description: 'Filters merge requests that have been reviewed. Only compatible with reviewerWildcard.',
        experiment: { milestone: '18.0' }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_request_type.rb =====
# frozen_string_literal: true

module Types
  class MergeRequestType < BaseObject
    graphql_name 'MergeRequest'

    connection_type_class Types::MergeRequestConnectionType

    implements Types::Notes::NoteableInterface
    implements Types::CurrentUserTodos
    implements Types::TodoableInterface

    authorize :read_merge_request

    expose_permissions Types::PermissionTypes::MergeRequest

    present_using MergeRequestPresenter

    field :closed_at, Types::TimeType, null: true, complexity: 5,
      description: 'Timestamp of when the merge request was closed, null if not closed.'
    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of when the merge request was created.'
    field :description, GraphQL::Types::String, null: true,
      description: 'Description of the merge request (Markdown rendered as HTML for caching).'
    field :diff_head_sha, GraphQL::Types::String, null: true, calls_gitaly: true,
      description: 'Diff head SHA of the merge request.'
    field :diff_refs, Types::DiffRefsType, null: true,
      description: 'References of the base SHA, the head SHA, and the start SHA for the merge request.'
    field :diff_stats, [Types::DiffStatsType], null: true, calls_gitaly: true,
      description: 'Details about which files were changed in the merge request.' do
      argument :path, GraphQL::Types::String, required: false, description: 'Specific file path.'
    end
    field :draft, GraphQL::Types::Boolean, method: :draft?, null: false,
      description: 'Indicates if the merge request is a draft.'
    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the merge request.'
    field :iid, GraphQL::Types::String, null: false,
      description: 'Internal ID of the merge request.'
    field :merge_when_pipeline_succeeds, GraphQL::Types::Boolean, null: true,
      description: 'Indicates if the merge has been set to auto-merge.',
      deprecated: { reason: :renamed, replacement: 'MergeRequest.autoMergeEnabled', milestone: '17.11' }
    field :merged_at, Types::TimeType, null: true, complexity: 5,
      description: 'Timestamp of when the merge request was merged, null if not merged.'
    field :project, Types::ProjectType, null: false,
      description: 'Alias for target_project.'
    field :project_id, GraphQL::Types::Int, null: false, method: :target_project_id,
      description: 'ID of the merge request project.'
    field :source_branch, GraphQL::Types::String, null: false,
      description: 'Source branch of the merge request.'
    field :source_branch_protected, GraphQL::Types::Boolean, null: false, calls_gitaly: true,
      description: 'Indicates if the source branch is protected.'
    field :source_project, Types::ProjectType, null: true,
      description: 'Source project of the merge request.'
    field :source_project_id, GraphQL::Types::Int, null: true,
      description: 'ID of the merge request source project.'
    field :state, MergeRequestStateEnum, null: false,
      description: 'State of the merge request.'
    field :target_branch, GraphQL::Types::String, null: false,
      description: 'Target branch of the merge request.'
    field :target_branch_path, GraphQL::Types::String, method: :target_branch_commits_path, null: true,
      calls_gitaly: true,
      description: 'Path to the target branch of the merge request.'
    field :target_project, Types::ProjectType, null: false,
      description: 'Target project of the merge request.'
    field :target_project_id, GraphQL::Types::Int, null: false,
      description: 'ID of the merge request target project.'
    field :title, GraphQL::Types::String, null: false,
      description: 'Title of the merge request.'
    field :updated_at, Types::TimeType, null: false,
      description: 'Timestamp of when the merge request was last updated.'

    field :allow_collaboration, GraphQL::Types::Boolean, null: true,
      description: 'Indicates if members of the target project can push to the fork.'
    field :default_merge_commit_message, GraphQL::Types::String, null: true, calls_gitaly: true,
      description: 'Default merge commit message of the merge request.'
    field :default_squash_commit_message, GraphQL::Types::String, null: true, calls_gitaly: true,
      description: 'Default squash commit message of the merge request.'
    field :diff_stats_summary, Types::DiffStatsSummaryType, null: true, calls_gitaly: true,
      description: 'Summary of which files were changed in the merge request.'
    field :diverged_from_target_branch, GraphQL::Types::Boolean,
      null: false, calls_gitaly: true,
      method: :diverged_from_target_branch?,
      description: 'Indicates if the source branch is behind the target branch.'

    field :downvotes, GraphQL::Types::Int,
      null: false,
      description: 'Number of downvotes for the merge request.',
      resolver: Resolvers::DownVotesCountResolver

    field :force_remove_source_branch, GraphQL::Types::Boolean, method: :force_remove_source_branch?, null: true,
      description: 'Indicates if the project settings will lead to source branch deletion after merge.'
    field :in_progress_merge_commit_sha, GraphQL::Types::String, null: true,
      description: 'Commit SHA of the merge request if merge is in progress.'
    field :merge_commit_sha, GraphQL::Types::String, null: true,
      description: 'SHA of the merge request commit (set once merged).'
    field :merge_error, GraphQL::Types::String, null: true,
      description: 'Error message due to a merge error.'
    field :merge_ongoing, GraphQL::Types::Boolean, method: :merge_ongoing?, null: false,
      description: 'Indicates if a merge is currently occurring.'
    field :merge_status, GraphQL::Types::String, method: :public_merge_status, null: true,
      description: 'Status of the merge request.',
      deprecated: { reason: :renamed, replacement: 'MergeRequest.mergeStatusEnum', milestone: '14.0' }
    field :merge_status_enum, ::Types::MergeRequests::MergeStatusEnum,
      method: :public_merge_status, null: true,
      description: 'Merge status of the merge request.'

    field :merge_after, ::Types::TimeType,
      null: true,
      description: 'Date after which the merge request can be merged.'

    field :detailed_merge_status, ::Types::MergeRequests::DetailedMergeStatusEnum, null: true,
      calls_gitaly: true,
      description: 'Detailed merge status of the merge request.'

    field :mergeability_checks, [::Types::MergeRequests::MergeabilityCheckType],
      null: false,
      description: 'Status of all mergeability checks of the merge request.',
      method: :all_mergeability_checks_results,
      experiment: { milestone: '16.5' },
      calls_gitaly: true

    field :mergeable_discussions_state, GraphQL::Types::Boolean, null: true, calls_gitaly: true,
      description: 'Indicates if all discussions in the merge request have been resolved, ' \
        'allowing the merge request to be merged.'
    field :rebase_commit_sha, GraphQL::Types::String, null: true,
      description: 'Rebase commit SHA of the merge request.'
    field :rebase_in_progress, GraphQL::Types::Boolean, method: :rebase_in_progress?, null: false, calls_gitaly: true,
      description: 'Indicates if there is a rebase currently in progress for the merge request.'
    field :should_be_rebased, GraphQL::Types::Boolean, method: :should_be_rebased?, null: false, calls_gitaly: true,
      description: 'Indicates if the merge request will be rebased.'
    field :should_remove_source_branch, GraphQL::Types::Boolean, method: :should_remove_source_branch?, null: true,
      description: 'Indicates if the source branch of the merge request will be deleted after merge.'
    field :source_branch_exists, GraphQL::Types::Boolean,
      null: false, calls_gitaly: true,
      method: :source_branch_exists?,
      description: 'Indicates if the source branch of the merge request exists.'
    field :target_branch_exists, GraphQL::Types::Boolean,
      null: false, calls_gitaly: true,
      method: :target_branch_exists?,
      description: 'Indicates if the target branch of the merge request exists.'

    field :upvotes, GraphQL::Types::Int,
      null: false,
      description: 'Number of upvotes for the merge request.',
      resolver: Resolvers::UpVotesCountResolver

    field :resolvable_discussions_count, GraphQL::Types::Int, null: true,
      description: 'Number of user discussions that are resolvable in the merge request.'
    field :resolved_discussions_count, GraphQL::Types::Int, null: true,
      description: 'Number of user discussions that are resolved in the merge request.'
    field :user_discussions_count, GraphQL::Types::Int, null: true,
      description: 'Number of user discussions in the merge request.',
      resolver: Resolvers::UserDiscussionsCountResolver
    field :user_notes_count, GraphQL::Types::Int, null: true,
      description: 'User notes count of the merge request.',
      resolver: Resolvers::UserNotesCountResolver

    field :web_path,
      GraphQL::Types::String,
      null: false,
      description: 'Web path of the merge request.'

    field :web_url, GraphQL::Types::String, null: true,
      description: 'Web URL of the merge request.'

    field :head_pipeline, Types::Ci::PipelineType, null: true, method: :diff_head_pipeline,
      description: 'Pipeline running on the branch HEAD of the merge request.'
    field :pipelines,
      null: true,
      description: 'Pipelines for the merge request. Note: for performance reasons, ' \
        'no more than the most recent 500 pipelines will be returned.',
      resolver: Resolvers::MergeRequestPipelinesResolver

    field :assignees,
      type: Types::MergeRequests::AssigneeType.connection_type,
      null: true,
      complexity: 5,
      description: 'Assignees of the merge request.'
    field :author, Types::MergeRequests::AuthorType, null: true,
      description: 'User who created the merge request.'
    field :discussion_locked, GraphQL::Types::Boolean,
      description: 'Indicates if comments on the merge request are locked to members only.',
      null: false
    field :human_time_estimate, GraphQL::Types::String, null: true,
      description: 'Human-readable time estimate of the merge request.'
    field :human_total_time_spent, GraphQL::Types::String, null: true,
      description: 'Human-readable total time reported as spent on the merge request.'
    field :labels, Types::LabelType.connection_type,
      null: true, complexity: 5,
      description: 'Labels of the merge request.',
      resolver: Resolvers::BulkLabelsResolver

    field :auto_merge_enabled, GraphQL::Types::Boolean, null: false,
      description: 'Indicates if auto merge is enabled for the merge request.'
    field :commit_count, GraphQL::Types::Int, null: true, method: :commits_count,
      description: 'Number of commits in the merge request.'
    field :conflicts, GraphQL::Types::Boolean, null: false, method: :cannot_be_merged?,
      description: 'Indicates if the merge request has conflicts.'
    field :milestone, Types::MilestoneType, null: true,
      description: 'Milestone of the merge request.'
    field :participants,
      Types::MergeRequests::ParticipantType.connection_type,
      null: true,
      complexity: 15,
      description: 'Participants in the merge request. This includes the author, ' \
        'assignees, reviewers, and users mentioned in notes.',
      resolver: Resolvers::Users::ParticipantsResolver
    field :reference, GraphQL::Types::String, null: false, method: :to_reference,
      description: 'Internal reference of the merge request. Returned in shortened format by default.' do
      argument :full, GraphQL::Types::Boolean, required: false, default_value: false,
        description: 'Boolean option specifying whether the reference should be returned in full.'
    end
    field :reviewers,
      type: Types::MergeRequests::ReviewerType.connection_type,
      null: true,
      complexity: 5,
      description: 'Users from whom a review has been requested.'
    field :subscribed, GraphQL::Types::Boolean, method: :subscribed?, null: false, complexity: 5,
      description: 'Indicates if the currently logged in user is subscribed to the merge request.'
    field :supports_lock_on_merge, GraphQL::Types::Boolean, null: false, method: :supports_lock_on_merge?,
      description: 'Indicates if the merge request supports locked labels.'
    field :task_completion_status, Types::TaskCompletionStatus, null: false,
      description: Types::TaskCompletionStatus.description
    field :time_estimate, GraphQL::Types::Int, null: false,
      description: 'Time estimate of the merge request.'
    field :total_time_spent, GraphQL::Types::Int, null: false,
      description: 'Total time (in seconds) reported as spent on the merge request.'

    field :approved, GraphQL::Types::Boolean,
      method: :approved?,
      null: false, calls_gitaly: true,
      description: 'Indicates if the merge request has all the required approvals.'

    field :approved_by, Types::UserType.connection_type, null: true,
      description: 'Users who approved the merge request.', method: :approved_by_users
    field :auto_merge_strategy, GraphQL::Types::String, null: true,
      description: 'Selected auto merge strategy.'
    field :available_auto_merge_strategies, [GraphQL::Types::String], null: true, calls_gitaly: true,
      description: 'Array of available auto merge strategies.'
    field :commits, Types::Repositories::CommitType.connection_type, null: true,
      calls_gitaly: true, description: 'Merge request commits.'
    field :commits_without_merge_commits, Types::Repositories::CommitType.connection_type, null: true,
      calls_gitaly: true, description: 'Merge request commits excluding merge commits.'
    field :committers, Types::UserType.connection_type, null: true, complexity: 5,
      calls_gitaly: true, description: 'Users who have added commits to the merge request.'
    field :has_ci, GraphQL::Types::Boolean, null: false, method: :has_ci?,
      description: 'Indicates if the merge request has CI.'
    field :merge_user, Types::UserType, null: true,
      description: 'User who merged the merge request or set it to auto-merge.'
    field :mergeable, GraphQL::Types::Boolean, null: false, method: :mergeable?, calls_gitaly: true,
      description: 'Indicates if the merge request is mergeable.'
    field :security_auto_fix,
      GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if the merge request is created by @GitLab-Security-Bot.',
      deprecated: {
        reason: 'Security Auto Fix experiment feature was removed. ' \
          'It was always hidden behind `security_auto_fix` feature flag',
        milestone: '16.11'
      }

    field :squash, GraphQL::Types::Boolean, null: false,
      description: <<~HEREDOC.squish
                   Indicates if the merge request is set to be squashed when merged.
                   [Project settings](https://docs.gitlab.com/ee/user/project/merge_requests/squash_and_merge.html#configure-squash-options-for-a-project)
                   may override this value. Use `squash_on_merge` instead to take project squash options into account.
      HEREDOC
    field :squash_on_merge, GraphQL::Types::Boolean, null: false, method: :squash_on_merge?,
      description: 'Indicates if the merge request will be squashed when merged.'
    field :squash_read_only, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if `squashReadOnly` is enabled.',
      method: :squash_readonly?
    field :timelogs, Types::TimelogType.connection_type, null: false,
      description: 'Timelogs on the merge request.'

    field :award_emoji, Types::AwardEmojis::AwardEmojiType.connection_type,
      null: true,
      description: 'List of emoji reactions associated with the merge request.'

    field :codequality_reports_comparer,
      type: ::Types::Security::CodequalityReportsComparerType,
      null: true,
      description: 'Code quality reports comparison reported on the merge request.',
      resolver: ::Resolvers::CodequalityReportsComparerResolver

    field :prepared_at, Types::TimeType, null: true,
      description: 'Timestamp of when the merge request was prepared.'

    field :allows_multiple_assignees,
      GraphQL::Types::Boolean,
      method: :allows_multiple_assignees?,
      description: 'Allows assigning multiple users to a merge request.',
      null: false

    field :allows_multiple_reviewers,
      GraphQL::Types::Boolean,
      method: :allows_multiple_reviewers?,
      description: 'Allows assigning multiple reviewers to a merge request.',
      null: false

    field :retargeted, GraphQL::Types::Boolean, null: true,
      description: 'Indicates if merge request was retargeted.'

    field :hidden, GraphQL::Types::Boolean, null: true,
      description: 'Indicates the merge request is hidden because the author has been banned.', method: :hidden?

    markdown_field :title_html, null: true
    markdown_field :description_html, null: true

    def diff_stats(path: nil)
      stats = Array.wrap(object.diff_stats&.to_a)

      if path.present?
        stats.select { |s| s.path == path }
      else
        stats
      end
    end

    def diff_stats_summary
      BatchLoaders::MergeRequestDiffSummaryBatchLoader.load_for(object)
    end

    def source_branch_protected
      object.source_project.present? && ProtectedBranch.protected?(object.source_project, object.source_branch)
    end

    def discussion_locked
      !!object.discussion_locked
    end

    def default_merge_commit_message
      object.default_merge_commit_message(include_description: false, user: current_user)
    end

    def default_squash_commit_message
      object.default_squash_commit_message(user: current_user)
    end

    def available_auto_merge_strategies
      AutoMergeService.new(object.project, current_user).available_strategies(object)
    end

    def closed_at
      object.metrics&.latest_closed_at
    end

    def commits
      object.commits(
        load_from_gitaly: true
      ).commits
    end

    def commits_without_merge_commits
      object.commits(
        load_from_gitaly: true
      ).without_merge_commits
    end

    def security_auto_fix
      object.author == ::Users::Internal.security_bot
    end

    def merge_user
      object.metrics&.merged_by || object.merge_user
    end

    def merge_after
      object.merge_schedule&.merge_after
    end

    def detailed_merge_status
      ::MergeRequests::Mergeability::DetailedMergeStatusService.new(merge_request: object).execute
    end

    # This is temporary to fix a bug where `committers` is already loaded and memoized
    # and calling it again with a certain GraphQL query can cause the Rails to to throw
    # a ActiveRecord::ImmutableRelation error
    def committers
      object.commits.committers
    end

    def web_path
      ::Gitlab::Routing.url_helpers.project_merge_request_path(object.project, object)
    end

    def resolvable_discussions_count
      notes_count_for_collection(:merge_request_resolvable_discussions_count, &:resolvable)
    end

    def resolved_discussions_count
      notes_count_for_collection(:merge_request_resolved_discussions_count, &:resolved)
    end

    def notes_count_for_collection(key)
      BatchLoader::GraphQL.for(object.id).batch(key: key) do |ids, loader, args|
        counts = Note.count_for_collection(
          ids,
          'MergeRequest',
          'COUNT(DISTINCT discussion_id) as count'
        )
        counts = yield(counts).index_by(&:noteable_id)

        ids.each do |id|
          loader.call(id, counts[id]&.count || 0)
        end
      end
    end
  end
end

Types::MergeRequestType.prepend_mod_with('Types::MergeRequestType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/merge_strategy_enum.rb =====
# frozen_string_literal: true

module Types
  class MergeStrategyEnum < BaseEnum
    AutoMergeService.all_strategies_ordered_by_preference.each do |strat|
      value strat.upcase, value: strat, description: "Use the #{strat} merge strategy."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/metrics/dashboards/annotation_type.rb =====
# frozen_string_literal: true

# Deprecated:
#   All remaining references to this type always return nil.
#   Remove during any major release.
module Types
  module Metrics
    module Dashboards
      # rubocop:disable Graphql/AuthorizeTypes -- there is no object to authorize
      class AnnotationType < ::Types::BaseObject
        graphql_name 'MetricsDashboardAnnotation'

        field :description, GraphQL::Types::String, null: true,
          description: 'Description of the annotation.'

        field :id, GraphQL::Types::ID, null: false,
          description: 'ID of the annotation.'

        field :panel_id,
          GraphQL::Types::String,
          null: true,
          description: 'ID of a dashboard panel to which the annotation should be scoped.',
          method: :panel_xid

        field :starting_at, Types::TimeType, null: true,
          description: 'Timestamp marking start of annotated time span.'

        field :ending_at, Types::TimeType, null: true,
          description: 'Timestamp marking end of annotated time span.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/milestone_sort_enum.rb =====
# frozen_string_literal: true

module Types
  class MilestoneSortEnum < SortEnum
    graphql_name 'MilestoneSort'
    description 'Values for sorting milestones'

    value 'DUE_DATE_ASC', 'Milestone due date by ascending order.', value: :due_date_asc
    value 'DUE_DATE_DESC', 'Milestone due date by descending order.', value: :due_date_desc
    value 'EXPIRED_LAST_DUE_DATE_ASC',
      value: :expired_last_due_date_asc,
      description: 'Group milestones in the order: non-expired milestones with due dates, non-expired milestones ' \
        'without due dates and expired milestones then sort by due date in ascending order.'
    value 'EXPIRED_LAST_DUE_DATE_DESC',
      value: :expired_last_due_date_desc,
      description: 'Group milestones in the order: non-expired milestones with due dates, non-expired milestones ' \
        'without due dates and expired milestones then sort by due date in descending order.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/milestone_state_enum.rb =====
# frozen_string_literal: true

module Types
  class MilestoneStateEnum < BaseEnum
    graphql_name 'MilestoneStateEnum'
    description 'Current state of milestone'

    value 'active', description: 'Milestone is currently active.'
    value 'closed', description: 'Milestone is closed.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/milestone_stats_type.rb =====
# frozen_string_literal: true

module Types
  class MilestoneStatsType < BaseObject
    graphql_name 'MilestoneStats'
    description 'Contains statistics about a milestone'

    authorize :read_milestone

    field :total_issues_count,
      GraphQL::Types::Int,
      null: true,
      description: 'Total number of issues associated with the milestone.'

    field :closed_issues_count,
      GraphQL::Types::Int,
      null: true,
      description: 'Number of closed issues associated with the milestone.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/milestone_type.rb =====
# frozen_string_literal: true

module Types
  class MilestoneType < BaseObject
    graphql_name 'Milestone'
    description 'Represents a milestone'

    present_using MilestonePresenter

    authorize :read_milestone

    alias_method :milestone, :object

    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the milestone.'

    field :iid, GraphQL::Types::ID, null: false, # rubocop:disable Graphql/IDType -- Legacy argument using ID type kept for backwards compatibility
      description: "Internal ID of the milestone."

    field :title, GraphQL::Types::String, null: false,
      description: 'Title of the milestone.'

    field :description, GraphQL::Types::String, null: true,
      description: 'Description of the milestone.'

    field :state, Types::MilestoneStateEnum, null: false,
      description: 'State of the milestone.'

    field :expired, GraphQL::Types::Boolean, null: false,
      description: 'Expired state of the milestone (a milestone is expired when the due date is past the current ' \
        'date). Defaults to `false` when due date has not been set.'

    field :upcoming, GraphQL::Types::Boolean, null: false,
      description: 'Upcoming state of the milestone (a milestone is upcoming when the start date is in the future). ' \
        'Defaults to `false` when start date has not been set.'

    field :web_path, GraphQL::Types::String, null: false, method: :milestone_path,
      description: 'Web path of the milestone.'

    field :due_date, Types::TimeType, null: true,
      description: 'Timestamp of the milestone due date.'

    field :start_date, Types::TimeType, null: true,
      description: 'Timestamp of the milestone start date.'

    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of milestone creation.'

    field :updated_at, Types::TimeType, null: false,
      description: 'Timestamp of last milestone update.'

    field :project, Types::ProjectType, null: true, description: 'Project of the milestone.'

    field :project_milestone, GraphQL::Types::Boolean, null: false,
      description: 'Indicates if milestone is at project level.',
      method: :project_milestone?

    field :group, Types::GroupType, null: true, description: 'Group of the milestone.'

    field :group_milestone, GraphQL::Types::Boolean, null: false,
      description: 'Indicates if milestone is at group level.',
      method: :group_milestone?

    field :subgroup_milestone, GraphQL::Types::Boolean, null: false,
      description: 'Indicates if milestone is at subgroup level.',
      method: :subgroup_milestone?

    field :stats, Types::MilestoneStatsType, null: true,
      description: 'Milestone statistics.'

    field :releases, ::Types::ReleaseType.connection_type,
      null: true,
      description: 'Releases associated with the milestone.'

    def stats
      milestone
    end
  end
end

Types::MilestoneType.prepend_mod_with('Types::MilestoneType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/milestone_wildcard_id_enum.rb =====
# frozen_string_literal: true

module Types
  class MilestoneWildcardIdEnum < BaseEnum
    graphql_name 'MilestoneWildcardId'
    description 'Milestone ID wildcard values'

    value 'NONE', 'No milestone is assigned.'
    value 'ANY', 'Milestone is assigned.'
    value 'STARTED', description: "Milestone assigned is open and started (overlaps current date). This " \
                       "differs from the behavior in the [REST API implementation](https://docs.gitlab.com/api/issues/#list-issues)."
    value 'UPCOMING', description: "Milestone assigned starts in the future (start date > today). This differs " \
                        "from the behavior in the [REST API implementation](https://docs.gitlab.com/api/issues/#list-issues)."
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/candidate_links_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class CandidateLinksType < BaseObject
      graphql_name 'MLCandidateLinks'
      description 'Represents links to perform actions on the candidate'

      present_using ::Ml::CandidatePresenter

      field :show_path, GraphQL::Types::String,
        null: true, description: 'Path to the details page of the candidate.', method: :path

      field :artifact_path, GraphQL::Types::String,
        null: true,
        description: 'Path to the artifact.',
        method: :artifact_show_path
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/candidate_metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class CandidateMetadataType < ::Types::BaseObject
      graphql_name 'MlCandidateMetadata'
      description 'Metadata for a candidate in the model registry'

      connection_type_class Types::LimitedCountableConnectionType

      field :id, ::Types::GlobalIDType[::Ml::CandidateMetadata], null: false, description: 'ID of the metadata.'

      field :name, ::GraphQL::Types::String,
        null: true,
        description: 'Name of the metadata entry.'

      field :value, ::GraphQL::Types::String,
        null: false,
        description: 'Value set for the metadata entry.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/candidate_metric_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class CandidateMetricType < ::Types::BaseObject
      graphql_name 'MlCandidateMetric'
      description 'Metric for a candidate in the model registry'

      connection_type_class Types::LimitedCountableConnectionType

      field :id, ::Types::GlobalIDType[::Ml::CandidateMetric], null: false, description: 'ID of the metric.'

      field :name, ::GraphQL::Types::String,
        null: true,
        description: 'Name of the metric.'

      field :step, ::GraphQL::Types::Int,
        null: false,
        description: 'Step at which the metric was measured.'

      field :value, ::GraphQL::Types::Float,
        null: false,
        description: 'Value set for the metric.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/candidate_param_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class CandidateParamType < ::Types::BaseObject
      graphql_name 'MlCandidateParam'
      description 'Parameter for a candidate in the model registry'

      connection_type_class Types::LimitedCountableConnectionType

      field :id, ::Types::GlobalIDType[::Ml::CandidateParam], null: false, description: 'ID of the parameter.'

      field :name, ::GraphQL::Types::String,
        null: true,
        description: 'Name of the parameter.'

      field :value, ::GraphQL::Types::String,
        null: false,
        description: 'Value set for the parameter.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/candidate_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class CandidateType < ::Types::BaseObject
      graphql_name 'MlCandidate'
      description 'Candidate for a model version in the model registry'

      connection_type_class Types::LimitedCountableConnectionType

      present_using ::Ml::CandidatePresenter

      field :id, ::Types::GlobalIDType[::Ml::Candidate], null: false, description: 'ID of the candidate.'

      field :name, ::GraphQL::Types::String,
        null: true,
        description: 'Name of the candidate.'

      field :iid, ::GraphQL::Types::Int,
        null: false,
        description: 'IID of the candidate scoped to project.'

      field :eid, ::GraphQL::Types::String,
        null: false,
        description: 'MLflow uuid for the candidate.'

      field :status, ::GraphQL::Types::String,
        null: true,
        description: 'Candidate status.'

      field :created_at, Types::TimeType, null: false, description: 'Date of creation.'

      field :params, ::Types::Ml::CandidateParamType.connection_type,
        null: false,
        description: 'Parameters for the candidate.'

      field :metrics, ::Types::Ml::CandidateMetricType.connection_type,
        null: false,
        description: 'Metrics for the candidate.'

      field :metadata, ::Types::Ml::CandidateMetadataType.connection_type,
        null: false,
        description: 'Metadata entries for the candidate.'

      field :ci_job, ::Types::Ci::JobType,
        null: true,
        description: 'CI information about the job that created the candidate.'

      field :creator, ::Types::UserType,
        null: true,
        description: 'User that created the candidate.'

      field :_links, ::Types::Ml::CandidateLinksType, null: false, method: :itself,
        description: 'Map of links to perform actions on the candidate.'

      def ci_job
        return unless object.from_ci? && Ability.allowed?(current_user, :read_build, object.ci_build)

        object.ci_build
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/experiments_order_by_enum.rb =====
# frozen_string_literal: true

module Types
  module Ml
    class ExperimentsOrderByEnum < BaseEnum
      graphql_name 'MlExperimentsOrderBy'
      description 'Values for ordering machine learning experiments by a specific field'

      value 'NAME', 'Ordered by name.', value: :name
      value 'CREATED_AT', 'Ordered by creation time.', value: :created_at
      value 'UPDATED_AT', 'Ordered by update time.', value: :updated_at
      value 'ID', 'Ordered by id.', value: :id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/experiment_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes -- authorization in FindExperimentResolver / ExperimentDetailResolver
  module Ml
    class ExperimentType < ::Types::BaseObject
      graphql_name 'MlExperiment'
      description 'Machine learning experiment in model experiments'

      connection_type_class Types::LimitedCountableConnectionType

      present_using ::Ml::ExperimentPresenter

      field :id, ::Types::GlobalIDType[::Ml::Experiment], null: false,
        description: 'ID of the experiment.'

      field :name, ::GraphQL::Types::String, null: false, description: 'Name of the experiment.'

      field :created_at, ::Types::TimeType, null: false,
        description: 'Timestamp of when the experiment was created.'

      field :updated_at, ::Types::TimeType, null: false,
        description: 'Timestamp of when the experiment was updated.'

      field :candidate_count, ::GraphQL::Types::Int, null: false,
        description: 'Number of candidates in the experiment.'

      field :path, ::GraphQL::Types::String, null: false,
        description: 'Web URL of the experiment.'

      field :creator, ::Types::UserType, null: true,
        description: 'User who created the experiment.'

      field :model_id, ::Types::GlobalIDType[::Ml::Model], null: true, description: 'ID of the model.'

      field :candidates, ::Types::Ml::CandidateType.connection_type, null: true,
        description: 'Candidates of the experiment.'
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/model_links_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class ModelLinksType < BaseObject
      graphql_name 'MLModelLinks'
      description 'Represents links to perform actions on the model'

      present_using ::Ml::ModelPresenter

      field :show_path, GraphQL::Types::String,
        null: true, description: 'Path to the details page of the model.', method: :path
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/models_order_by_enum.rb =====
# frozen_string_literal: true

module Types
  module Ml
    class ModelsOrderByEnum < BaseEnum
      graphql_name 'MlModelsOrderBy'
      description 'Values for ordering machine learning models by a specific field'

      value 'NAME', 'Ordered by name.', value: :name
      value 'CREATED_AT', 'Ordered by creation time.', value: :created_at
      value 'UPDATED_AT', 'Ordered by update time.', value: :updated_at
      value 'ID', 'Ordered by id.', value: :id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/model_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class ModelType < ::Types::BaseObject
      graphql_name 'MlModel'
      description 'Machine learning model in the model registry'

      connection_type_class Types::LimitedCountableConnectionType

      present_using ::Ml::ModelPresenter

      markdown_field :description_html, null: true

      field :id, ::Types::GlobalIDType[::Ml::Model], null: false, description: 'ID of the model.'

      field :name, ::GraphQL::Types::String, null: false, description: 'Name of the model.'

      field :created_at, Types::TimeType, null: false, description: 'Date of creation.'

      field :author, ::Types::UserType, null: true, description: 'User that created the model.'

      field :description, ::GraphQL::Types::String,
        null: true,
        description: 'Description of the model.'

      field :latest_version, ::Types::Ml::ModelVersionType, null: true, description: 'Latest version of the model.'

      field :version_count, ::GraphQL::Types::Int, null: true, description: 'Count of versions in the model.'

      field :candidate_count, ::GraphQL::Types::Int,
        null: true,
        description: 'Count of candidates in the model.'

      field :_links, ::Types::Ml::ModelLinksType, null: false, method: :itself,
        description: 'Map of links to perform actions on the model.'

      field :versions, ::Types::Ml::ModelVersionType.connection_type, null: true,
        description: 'Versions of the model.',
        resolver: ::Resolvers::Ml::FindModelVersionsResolver

      field :candidates, ::Types::Ml::CandidateType.connection_type, null: true,
        description: 'Version candidates of the model.'

      field :default_experiment_path, ::GraphQL::Types::String,
        null: true,
        description: 'Path to default experiment page for the model.'

      field :version, ::Types::Ml::ModelVersionType, null: true,
        description: 'Version of the model.',
        resolver: ::Resolvers::Ml::FindModelVersionResolver
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/model_version_links_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class ModelVersionLinksType < BaseObject
      graphql_name 'MLModelVersionLinks'
      description 'Represents links to perform actions on the model version'

      present_using ::Ml::ModelVersionPresenter

      field :show_path, GraphQL::Types::String,
        null: true, description: 'Path to the details page of the model version.', method: :path

      field :package_path, GraphQL::Types::String,
        null: true, description: 'Path to the package of the model version.'

      field :import_path, GraphQL::Types::String,
        null: true, description: 'File upload path for the machine learning model.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/model_versions_order_by_enum.rb =====
# frozen_string_literal: true

module Types
  module Ml
    class ModelVersionsOrderByEnum < BaseEnum
      graphql_name 'MlModelVersionsOrderBy'
      description 'Field names for ordering machine learning model versions'

      value 'VERSION', 'Ordered by name.', value: :name
      value 'CREATED_AT', 'Ordered by creation time.', value: :created_at
      value 'ID', 'Ordered by id.', value: :id
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ml/model_version_type.rb =====
# frozen_string_literal: true

module Types
  module Ml
    # rubocop: disable Graphql/AuthorizeTypes -- authorization in ModelDetailsResolver
    class ModelVersionType < ::Types::BaseObject
      graphql_name 'MlModelVersion'
      description 'Version of a machine learning model'
      present_using ::Ml::ModelVersionPresenter

      connection_type_class Types::LimitedCountableConnectionType

      markdown_field :description_html, null: true

      field :id, ::Types::GlobalIDType[::Ml::ModelVersion], null: false, description: 'ID of the model version.'

      field :created_at, Types::TimeType, null: false, description: 'Date of creation.'

      field :author, ::Types::UserType, null: true, description: 'User that created the model version.'

      field :description, ::GraphQL::Types::String,
        null: true,
        description: 'Description of the version.'

      field :artifacts_count, GraphQL::Types::Int, null: true, description: 'Number of files in the package.'

      field :version, ::GraphQL::Types::String, null: false, description: 'Name of the version.'

      field :package_id, ::Types::GlobalIDType[::Packages::Package],
        null: false,
        description: 'Package for model version artifacts.'

      field :candidate, ::Types::Ml::CandidateType,
        null: false,
        description: 'Metrics, params and metadata for the model version.'

      field :_links, ::Types::Ml::ModelVersionLinksType, null: false, method: :itself,
        description: 'Map of links to perform actions on the model version.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/mutation_operation_mode_enum.rb =====
# frozen_string_literal: true

module Types
  class MutationOperationModeEnum < BaseEnum
    graphql_name 'MutationOperationMode'
    description 'Different toggles for changing mutator behavior'

    # Suggested param name for the enum: `operation_mode`

    value 'REPLACE', 'Performs a replace operation.'
    value 'APPEND', 'Performs an append operation.'
    value 'REMOVE', 'Performs a removal operation.'

    def self.default_mode
      enum[:replace]
    end

    def self.transform_modes
      enum.values_at(:remove, :append)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/mutation_type.rb =====
# frozen_string_literal: true

module Types
  class MutationType < BaseObject
    graphql_name 'Mutation'

    include Gitlab::Graphql::MountMutation

    mount_mutation Mutations::Achievements::Award, experiment: { milestone: '15.10' }
    mount_mutation Mutations::Achievements::Create, experiment: { milestone: '15.8' }
    mount_mutation Mutations::Achievements::Delete, experiment: { milestone: '15.11' }
    mount_mutation Mutations::Achievements::DeleteUserAchievement, experiment: { milestone: '16.1' }
    mount_mutation Mutations::Achievements::Revoke, experiment: { milestone: '15.10' }
    mount_mutation Mutations::Achievements::Update, experiment: { milestone: '15.11' }
    mount_mutation Mutations::Achievements::UpdateUserAchievement, experiment: { milestone: '17.3' }
    mount_mutation Mutations::Achievements::UpdateUserAchievementPriorities, experiment: { milestone: '16.5' }
    mount_mutation Mutations::Admin::SidekiqQueues::DeleteJobs
    mount_mutation Mutations::AlertManagement::CreateAlertIssue
    mount_mutation Mutations::AlertManagement::UpdateAlertStatus
    mount_mutation Mutations::AlertManagement::Alerts::SetAssignees
    mount_mutation Mutations::AlertManagement::Alerts::Todo::Create
    mount_mutation Mutations::AlertManagement::HttpIntegration::Create
    mount_mutation Mutations::AlertManagement::HttpIntegration::Update
    mount_mutation Mutations::AlertManagement::HttpIntegration::ResetToken
    mount_mutation Mutations::AlertManagement::HttpIntegration::Destroy
    mount_mutation Mutations::Security::CiConfiguration::ConfigureSast
    mount_mutation Mutations::Security::CiConfiguration::ConfigureSastIac
    mount_mutation Mutations::Security::CiConfiguration::ConfigureSecretDetection
    mount_mutation Mutations::AlertManagement::PrometheusIntegration::Create, deprecated: {
      reason: 'Use HttpIntegrationCreate', milestone: '18.2'
    }
    mount_mutation Mutations::AlertManagement::PrometheusIntegration::Update, deprecated: {
      reason: 'Use HttpIntegrationUpdate', milestone: '18.2'
    }
    mount_mutation Mutations::AlertManagement::PrometheusIntegration::ResetToken, deprecated: {
      reason: 'Use HttpIntegrationResetToken', milestone: '18.2'
    }
    mount_mutation Mutations::AwardEmojis::Add
    mount_mutation Mutations::AwardEmojis::Remove
    mount_mutation Mutations::AwardEmojis::Toggle
    mount_mutation Mutations::Boards::Create
    mount_mutation Mutations::Boards::Destroy
    mount_mutation Mutations::Boards::Update
    mount_mutation Mutations::Boards::Issues::IssueMoveList
    mount_mutation Mutations::Boards::Lists::Create
    mount_mutation Mutations::Boards::Lists::Update
    mount_mutation Mutations::Boards::Lists::Destroy
    mount_mutation Mutations::Repositories::Branches::Create, calls_gitaly: true
    mount_mutation Mutations::Repositories::Branches::Delete, calls_gitaly: true
    mount_mutation Mutations::Repositories::Tags::Create, calls_gitaly: true
    mount_mutation Mutations::Repositories::Tags::Delete, calls_gitaly: true
    mount_mutation Mutations::Clusters::Agents::Create
    mount_mutation Mutations::Clusters::Agents::Delete
    mount_mutation Mutations::Clusters::AgentTokens::Create
    mount_mutation Mutations::Clusters::AgentTokens::Revoke
    mount_mutation Mutations::Commits::Create, calls_gitaly: true
    mount_mutation Mutations::CustomEmoji::Create
    mount_mutation Mutations::CustomEmoji::Destroy
    mount_mutation Mutations::CustomerRelations::Contacts::Create
    mount_mutation Mutations::CustomerRelations::Contacts::Update
    mount_mutation Mutations::CustomerRelations::Organizations::Create
    mount_mutation Mutations::CustomerRelations::Organizations::Update
    mount_mutation Mutations::Discussions::ToggleResolve
    mount_mutation Mutations::DependencyProxy::ImageTtlGroupPolicy::Update
    mount_mutation Mutations::DependencyProxy::GroupSettings::Update
    mount_mutation Mutations::Environments::CanaryIngress::Update
    mount_mutation Mutations::Environments::Create
    mount_mutation Mutations::Environments::Delete
    mount_mutation Mutations::Environments::Stop
    mount_mutation Mutations::Environments::Update
    mount_mutation Mutations::Import::SourceUsers::CancelReassignment, experiment: { milestone: '17.2' }
    mount_mutation Mutations::Import::SourceUsers::KeepAllAsPlaceholder, experiment: { milestone: '17.6' }
    mount_mutation Mutations::Import::SourceUsers::KeepAsPlaceholder, experiment: { milestone: '17.2' }
    mount_mutation Mutations::Import::SourceUsers::Reassign, experiment: { milestone: '17.2' }
    mount_mutation Mutations::Import::SourceUsers::ResendNotification, experiment: { milestone: '17.2' }
    mount_mutation Mutations::IncidentManagement::TimelineEvent::Create, experiment: { milestone: '15.6' }
    mount_mutation Mutations::IncidentManagement::TimelineEvent::PromoteFromNote
    mount_mutation Mutations::IncidentManagement::TimelineEvent::Update
    mount_mutation Mutations::IncidentManagement::TimelineEvent::Destroy
    mount_mutation Mutations::IncidentManagement::TimelineEventTag::Create
    mount_mutation Mutations::Integrations::Exclusions::Create, experiment: { milestone: '17.0' }
    mount_mutation Mutations::Integrations::Exclusions::Delete, experiment: { milestone: '17.0' }
    mount_mutation Mutations::Issues::Create
    mount_mutation Mutations::Issues::SetAssignees
    mount_mutation Mutations::Issues::SetCrmContacts
    mount_mutation Mutations::Issues::SetConfidential
    mount_mutation Mutations::Issues::SetLocked
    mount_mutation Mutations::Issues::SetDueDate
    mount_mutation Mutations::Issues::SetSeverity
    mount_mutation Mutations::Issues::SetSubscription
    mount_mutation Mutations::Issues::SetEscalationStatus
    mount_mutation Mutations::Issues::Update
    mount_mutation Mutations::Issues::Move
    mount_mutation Mutations::Issues::LinkAlerts
    mount_mutation Mutations::Issues::UnlinkAlert
    mount_mutation Mutations::Labels::Create
    mount_mutation Mutations::Members::Groups::BulkUpdate
    mount_mutation Mutations::Members::Projects::BulkUpdate
    mount_mutation Mutations::MergeRequests::Accept
    mount_mutation Mutations::MergeRequests::Create
    mount_mutation Mutations::MergeRequests::Update
    mount_mutation Mutations::MergeRequests::SetLabels
    mount_mutation Mutations::MergeRequests::SetLocked
    mount_mutation Mutations::MergeRequests::SetMilestone
    mount_mutation Mutations::MergeRequests::SetSubscription
    mount_mutation Mutations::MergeRequests::SetDraft, calls_gitaly: true
    mount_mutation Mutations::MergeRequests::SetAssignees
    mount_mutation Mutations::MergeRequests::SetReviewers
    mount_mutation Mutations::MergeRequests::ReviewerRereview
    mount_mutation Mutations::Metrics::Dashboard::Annotations::Create, deprecated: {
      reason: 'Underlying feature was removed in 16.0',
      milestone: '16.0'
    }
    mount_mutation Mutations::Metrics::Dashboard::Annotations::Delete, deprecated: {
      reason: 'Underlying feature was removed in 16.0',
      milestone: '16.0'
    }
    mount_mutation Mutations::Notes::AbuseReport::Create
    mount_mutation Mutations::Notes::AbuseReport::Update, experiment: { milestone: '17.5' }
    mount_mutation Mutations::Notes::Create::Note, calls_gitaly: true, scopes: [:api, :ai_workflows]
    mount_mutation Mutations::Notes::Create::DiffNote, calls_gitaly: true
    mount_mutation Mutations::Notes::Create::ImageDiffNote, calls_gitaly: true
    mount_mutation Mutations::Notes::Create::Discussion, calls_gitaly: true
    mount_mutation Mutations::Notes::Update::Note, scopes: [:api, :ai_workflows]
    mount_mutation Mutations::Notes::Update::ImageDiffNote
    mount_mutation Mutations::Notes::ConvertToThread
    mount_mutation Mutations::Notes::RepositionImageDiffNote
    mount_mutation Mutations::Notes::Destroy
    mount_mutation Mutations::Organizations::Create, experiment: { milestone: '16.6' }
    mount_mutation Mutations::Organizations::Update, experiment: { milestone: '16.7' }
    mount_mutation Mutations::Organizations::OrganizationUsers::Update, experiment: { milestone: '17.5' }
    mount_mutation Mutations::Projects::BlobsRemove, calls_gitaly: true, experiment: { milestone: '17.1' }
    mount_mutation Mutations::Projects::SyncFork, calls_gitaly: true, experiment: { milestone: '15.9' }
    mount_mutation Mutations::Projects::TextReplace, calls_gitaly: true, experiment: { milestone: '17.1' }
    mount_mutation Mutations::Projects::Star, experiment: { milestone: '16.7' }
    mount_mutation Mutations::Projects::BranchRules::SquashOptions::Update, experiment: { milestone: '17.9' }
    mount_mutation Mutations::BranchRules::Update, experiment: { milestone: '16.7' }
    mount_mutation Mutations::BranchRules::Create, experiment: { milestone: '16.7' }
    mount_mutation Mutations::Releases::Create
    mount_mutation Mutations::Releases::Update
    mount_mutation Mutations::Releases::Delete
    mount_mutation Mutations::ReleaseAssetLinks::Create
    mount_mutation Mutations::ReleaseAssetLinks::Update
    mount_mutation Mutations::ReleaseAssetLinks::Delete
    mount_mutation Mutations::Terraform::State::Delete
    mount_mutation Mutations::Terraform::State::Lock
    mount_mutation Mutations::Terraform::State::Unlock
    mount_mutation Mutations::Timelogs::Create
    mount_mutation Mutations::Timelogs::Delete
    mount_mutation Mutations::Todos::Create
    mount_mutation Mutations::Todos::MarkDone
    mount_mutation Mutations::Todos::Restore
    mount_mutation Mutations::Todos::MarkAllDone
    mount_mutation Mutations::Todos::ResolveMany, experiment: { milestone: '17.9' }
    mount_mutation Mutations::Todos::RestoreMany
    mount_mutation Mutations::Todos::Snooze, experiment: { milestone: '17.4' }
    mount_mutation Mutations::Todos::UnSnooze, experiment: { milestone: '17.4' }
    mount_mutation Mutations::Todos::SnoozeMany, experiment: { milestone: '17.9' }
    mount_mutation Mutations::Todos::UnsnoozeMany, experiment: { milestone: '17.9' }
    mount_mutation Mutations::Todos::DeleteMany, experiment: { milestone: '17.11' }
    mount_mutation Mutations::Todos::DeleteAllDone, experiment: { milestone: '17.11' }
    mount_mutation Mutations::Snippets::Destroy
    mount_mutation Mutations::Snippets::Update
    mount_mutation Mutations::Snippets::Create
    mount_mutation Mutations::Snippets::MarkAsSpam
    mount_mutation Mutations::JiraImport::Start
    mount_mutation Mutations::JiraImport::ImportUsers
    mount_mutation Mutations::DesignManagement::Upload, calls_gitaly: true
    mount_mutation Mutations::DesignManagement::Delete, calls_gitaly: true
    mount_mutation Mutations::DesignManagement::Move
    mount_mutation Mutations::DesignManagement::Update
    mount_mutation Mutations::ContainerExpirationPolicies::Update
    mount_mutation Mutations::ContainerRegistry::Protection::Rule::Create
    mount_mutation Mutations::ContainerRegistry::Protection::Rule::Delete
    mount_mutation Mutations::ContainerRegistry::Protection::Rule::Update
    mount_mutation Mutations::ContainerRegistry::Protection::TagRule::Create, experiment: { milestone: '17.8' }
    mount_mutation Mutations::ContainerRegistry::Protection::TagRule::Delete, experiment: { milestone: '17.8' }
    mount_mutation Mutations::ContainerRegistry::Protection::TagRule::Update, experiment: { milestone: '17.8' }
    mount_mutation Mutations::ContainerRepositories::Destroy
    mount_mutation Mutations::ContainerRepositories::DestroyTags
    mount_mutation Mutations::Ci::Catalog::Resources::Create, experiment: { milestone: '15.11' }
    mount_mutation Mutations::Ci::Catalog::Resources::Destroy, experiment: { milestone: '16.6' }
    mount_mutation Mutations::Ci::Job::Cancel
    mount_mutation Mutations::Ci::Job::Play
    mount_mutation Mutations::Ci::Job::Retry
    mount_mutation Mutations::Ci::Job::ArtifactsDestroy
    mount_mutation Mutations::Ci::Job::Unschedule
    mount_mutation Mutations::Ci::JobTokenScope::AddGroupOrProject
    mount_mutation Mutations::Ci::JobTokenScope::AddProject
    mount_mutation Mutations::Ci::JobArtifact::BulkDestroy, experiment: { milestone: '15.10' }
    mount_mutation Mutations::Ci::JobArtifact::Destroy
    mount_mutation Mutations::Ci::JobTokenScope::RemoveGroup
    mount_mutation Mutations::Ci::JobTokenScope::RemoveProject
    mount_mutation Mutations::Ci::JobTokenScope::UpdateJobTokenPolicies, experiment: { milestone: '17.6' }
    mount_mutation Mutations::Ci::JobTokenScope::AutopopulateAllowlist, experiment: { milestone: '17.9' }
    mount_mutation Mutations::Ci::JobTokenScope::ClearAllowlistAutopopulations, experiment: { milestone: '17.9' }
    mount_mutation Mutations::Ci::Lint
    mount_mutation Mutations::Ci::NamespaceSettingsUpdate, experiment: { milestone: '17.9' }
    mount_mutation Mutations::Ci::Pipeline::Cancel
    mount_mutation Mutations::Ci::Pipeline::Create
    mount_mutation Mutations::Ci::Pipeline::Destroy
    mount_mutation Mutations::Ci::Pipeline::Retry
    mount_mutation Mutations::Ci::PipelineSchedule::Create
    mount_mutation Mutations::Ci::PipelineSchedule::Delete
    mount_mutation Mutations::Ci::PipelineSchedule::Play
    mount_mutation Mutations::Ci::PipelineSchedule::TakeOwnership
    mount_mutation Mutations::Ci::PipelineSchedule::Update
    mount_mutation Mutations::Ci::PipelineTrigger::Create, experiment: { milestone: '16.3' }
    mount_mutation Mutations::Ci::PipelineTrigger::Delete, experiment: { milestone: '16.3' }
    mount_mutation Mutations::Ci::PipelineTrigger::Update, experiment: { milestone: '16.3' }
    mount_mutation Mutations::Ci::ProjectCiCdSettingsUpdate
    mount_mutation Mutations::Ci::SafeDisablePipelineVariables
    mount_mutation Mutations::Ci::Runner::BulkDelete, experiment: { milestone: '15.3' }
    mount_mutation Mutations::Ci::Runner::BulkPause, experiment: { milestone: '17.11' }
    mount_mutation Mutations::Ci::Runner::Cache::Clear
    mount_mutation Mutations::Ci::Runner::Create, experiment: { milestone: '15.10' }
    mount_mutation Mutations::Ci::Runner::Delete
    mount_mutation Mutations::Ci::Runner::Update
    mount_mutation Mutations::Ci::Runner::AssignToProject, experiment: { milestone: '18.1' }
    mount_mutation Mutations::Ci::Runner::UnassignFromProject, experiment: { milestone: '18.1' }
    mount_mutation Mutations::Ci::RunnersRegistrationToken::Reset, deprecated: {
      reason: 'Underlying feature was deprecated in 15.6 and will be removed in 18.0',
      milestone: '17.7'
    }
    mount_mutation Mutations::Namespace::PackageSettings::Update
    mount_mutation Mutations::Namespaces::RegenerateNewWorkItemEmailAddress, experiment: { milestone: '18.2' }
    mount_mutation Mutations::Groups::Update
    mount_mutation Mutations::UserCallouts::Create
    mount_mutation Mutations::UserPreferences::Update
    mount_mutation Mutations::Packages::Destroy
    mount_mutation Mutations::Packages::BulkDestroy,
      extensions: [::Gitlab::Graphql::Limit::FieldCallCount => { limit: 1 }]
    mount_mutation Mutations::Packages::DestroyFile
    mount_mutation Mutations::Packages::Protection::Rule::Create
    mount_mutation Mutations::Packages::Protection::Rule::Delete
    mount_mutation Mutations::Packages::Protection::Rule::Update
    mount_mutation Mutations::Packages::DestroyFiles
    mount_mutation Mutations::Packages::Cleanup::Policy::Update
    mount_mutation Mutations::Echo
    mount_mutation Mutations::WorkItems::Create, experiment: { milestone: '15.1' }, scopes: [:api, :ai_workflows]
    mount_mutation Mutations::WorkItems::CreateFromTask, experiment: { milestone: '15.1' }
    mount_mutation Mutations::WorkItems::Delete, experiment: { milestone: '15.1' }
    mount_mutation Mutations::WorkItems::Update, experiment: { milestone: '15.1' }, scopes: [:api, :ai_workflows]
    mount_mutation Mutations::WorkItems::CSV::Export, experiment: { milestone: '15.10' }
    mount_mutation Mutations::WorkItems::CSV::Import, experiment: { milestone: '18.2' }
    mount_mutation Mutations::WorkItems::Convert, experiment: { milestone: '15.11' }
    mount_mutation Mutations::WorkItems::LinkedItems::Add, experiment: { milestone: '16.3' }
    mount_mutation Mutations::WorkItems::LinkedItems::Remove, experiment: { milestone: '16.3' }
    mount_mutation Mutations::WorkItems::AddClosingMergeRequest, experiment: { milestone: '17.1' }
    mount_mutation Mutations::WorkItems::Hierarchy::Reorder, experiment: { milestone: '17.3' }
    mount_mutation Mutations::WorkItems::Hierarchy::AddChildrenItems, experiment: { milestone: '18.2' }
    mount_mutation Mutations::WorkItems::BulkUpdate, experiment: { milestone: '17.4' }
    mount_mutation Mutations::WorkItems::BulkMove, experiment: { milestone: '18.2' }
    mount_mutation Mutations::WorkItems::Reorder, experiment: { milestone: '18.3' }
    mount_mutation Mutations::WorkItems::UserPreference::Update, experiment: { milestone: '17.10' }
    mount_mutation Mutations::Users::SavedReplies::Create
    mount_mutation Mutations::Users::SavedReplies::Update
    mount_mutation Mutations::Users::SavedReplies::Destroy
    mount_mutation Mutations::Pages::MarkOnboardingComplete
    mount_mutation Mutations::Pages::SetPagesForceHttps
    mount_mutation Mutations::Pages::SetPagesUseUniqueDomain
    mount_mutation Mutations::Uploads::Delete
    mount_mutation Mutations::Users::SetNamespaceCommitEmail
    mount_mutation Mutations::WorkItems::Subscribe, experiment: { milestone: '16.3' }
    mount_mutation Mutations::Admin::AbuseReportLabels::Create, experiment: { milestone: '16.4' }
    mount_mutation Mutations::Ml::Models::Create, experiment: { milestone: '16.8' }
    mount_mutation Mutations::Ml::Models::Edit, experiment: { milestone: '17.3' }
    mount_mutation Mutations::Ml::Models::Destroy, experiment: { milestone: '16.10' }
    mount_mutation Mutations::Ml::Models::Delete, experiment: { milestone: '17.0' }
    mount_mutation Mutations::Ml::ModelVersions::Create, experiment: { milestone: '17.1' }
    mount_mutation Mutations::Ml::ModelVersions::Edit, experiment: { milestone: '17.4' }
    mount_mutation Mutations::Ml::ModelVersions::Delete, experiment: { milestone: '17.0' }
    mount_mutation Mutations::BranchRules::Delete, experiment: { milestone: '16.9' }
    mount_mutation Mutations::Pages::Deployment::Delete, experiment: { milestone: '17.1' }
    mount_mutation Mutations::Pages::Deployment::Restore, experiment: { milestone: '17.1' }
    mount_mutation Mutations::Wikis::WikiPageSubscribe, experiment: { milestone: '18.1' }
  end
end

::Types::MutationType.prepend(::Types::DeprecatedMutations)
::Types::MutationType.prepend_mod_with('Types::MutationType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespace/package_settings_type.rb =====
# frozen_string_literal: true

module Types
  class Namespace::PackageSettingsType < BaseObject
    graphql_name 'PackageSettings'

    description 'Namespace-level Package Registry settings'

    authorize :admin_package

    field :generic_duplicate_exception_regex, Types::UntrustedRegexp,
      null: true,
      description: 'When generic_duplicates_allowed is false, you can publish duplicate packages with names that ' \
        'match this regex. Otherwise, this setting has no effect.'
    field :generic_duplicates_allowed, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether duplicate generic packages are allowed for the namespace.'
    field :maven_duplicate_exception_regex, Types::UntrustedRegexp,
      null: true,
      description: 'When maven_duplicates_allowed is false, you can publish duplicate packages with names that ' \
        'match this regex. Otherwise, this setting has no effect.'
    field :maven_duplicates_allowed, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether duplicate Maven packages are allowed for the namespace.'
    field :maven_package_requests_forwarding, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates whether Maven package forwarding is allowed for the namespace.'
    field :npm_package_requests_forwarding, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates whether npm package forwarding is allowed for the namespace.'
    field :nuget_duplicate_exception_regex, Types::UntrustedRegexp,
      null: true,
      description: 'When nuget_duplicates_allowed is false, you can publish duplicate packages with names that ' \
        'match this regex. Otherwise, this setting has no effect. '
    field :nuget_duplicates_allowed, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether duplicate NuGet packages are allowed for the namespace.'
    field :pypi_package_requests_forwarding, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates whether PyPI package forwarding is allowed for the namespace.'
    field :terraform_module_duplicate_exception_regex, Types::UntrustedRegexp,
      null: true,
      description: 'When terraform_module_duplicates_allowed is false, you can publish duplicate packages with ' \
        'names that match this regex. Otherwise, this setting has no effect.'
    field :terraform_module_duplicates_allowed, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether duplicate Terraform packages are allowed for the namespace.'

    field :lock_maven_package_requests_forwarding, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether Maven package forwarding is locked for all descendent namespaces.'
    field :lock_npm_package_requests_forwarding, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether npm package forwarding is locked for all descendent namespaces.'
    field :lock_pypi_package_requests_forwarding, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether PyPI package forwarding is locked for all descendent namespaces.'

    field :maven_package_requests_forwarding_locked, GraphQL::Types::Boolean,
      null: false,
      method: :maven_package_requests_forwarding_locked?,
      description: 'Indicates whether Maven package forwarding settings are locked by a parent namespace.'
    field :npm_package_requests_forwarding_locked, GraphQL::Types::Boolean,
      null: false,
      method: :npm_package_requests_forwarding_locked?,
      description: 'Indicates whether npm package forwarding settings are locked by a parent namespace.'
    field :pypi_package_requests_forwarding_locked, GraphQL::Types::Boolean,
      null: false,
      method: :pypi_package_requests_forwarding_locked?,
      description: 'Indicates whether PyPI package forwarding settings are locked by a parent namespace.'

    field :nuget_symbol_server_enabled, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates whether the NuGet symbol server is enabled for the namespace.'
  end
end

Types::Namespace::PackageSettingsType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/available_features_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    class AvailableFeaturesType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
      graphql_name 'NamespaceAvailableFeatures'

      include IssuesHelper

      field :has_blocked_issues_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether blocked issues are enabled for the namespace.',
        resolver_method: :blocked_issues_enabled?,
        experiment: { milestone: '18.3' }

      field :has_custom_fields_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether custom fields are enabled for the namespace.',
        resolver_method: :custom_fields_enabled?,
        experiment: { milestone: '18.3' }

      field :has_epics_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether epics are enabled for the namespace.',
        resolver_method: :epics_enabled?,
        experiment: { milestone: '18.1' }

      field :has_group_bulk_edit_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether group bulk edit is enabled for the namespace.',
        resolver_method: :group_bulk_edit_enabled?,
        experiment: { milestone: '18.3' }

      field :has_issuable_health_status_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether issuable health status is enabled for the namespace.',
        resolver_method: :issuable_health_status_enabled?,
        experiment: { milestone: '18.1' }

      field :has_issue_date_filter_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether issue date filter is enabled for the namespace.',
        resolver_method: :issue_date_filter_enabled?,
        experiment: { milestone: '18.1' }

      field :has_issue_weights_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether issue weights are enabled for the namespace.',
        resolver_method: :issue_weights_enabled?,
        experiment: { milestone: '18.1' }

      field :has_iterations_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether iterations are enabled for the namespace.',
        resolver_method: :iterations_enabled?,
        experiment: { milestone: '18.1' }

      field :has_linked_items_epics_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether linked items epics are enabled for the namespace.',
        resolver_method: :linked_items_epics_enabled?,
        experiment: { milestone: '18.1' }

      field :has_okrs_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether OKRs are enabled for the namespace.',
        resolver_method: :okrs_enabled?,
        experiment: { milestone: '18.1' }

      field :has_quality_management_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether quality management is enabled for the namespace.',
        resolver_method: :quality_management_enabled?,
        experiment: { milestone: '18.1' }

      field :has_scoped_labels_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether scoped labels are enabled for the namespace.',
        resolver_method: :scoped_labels_enabled?,
        experiment: { milestone: '18.1' }

      field :has_subepics_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether subepics are enabled for the namespace.',
        resolver_method: :subepics_enabled?,
        experiment: { milestone: '18.1' }

      field :has_work_item_status_feature,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether work item statuses are enabled for the namespace.',
        resolver_method: :work_item_status_enabled?,
        experiment: { milestone: '18.3' }

      def blocked_issues_enabled?
        object.licensed_feature_available?(:blocked_issues)
      end

      def custom_fields_enabled?
        object.licensed_feature_available?(:custom_fields)
      end

      def epics_enabled?
        object.licensed_feature_available?(:epics)
      end

      def group_bulk_edit_enabled?
        object.licensed_feature_available?(:group_bulk_edit)
      end

      def issuable_health_status_enabled?
        object.licensed_feature_available?(:issuable_health_status)
      end

      def issue_date_filter_enabled?
        has_issue_date_filter_feature?(object, current_user)
      end

      def issue_weights_enabled?
        object.licensed_feature_available?(:issue_weights)
      end

      def iterations_enabled?
        object.licensed_feature_available?(:iterations)
      end

      def linked_items_epics_enabled?
        object.licensed_feature_available?(:linked_items_epics)
      end

      def okrs_enabled?
        object.licensed_feature_available?(:okrs)
      end

      def quality_management_enabled?
        object.licensed_feature_available?(:quality_management)
      end

      def scoped_labels_enabled?
        object.licensed_feature_available?(:scoped_labels)
      end

      def subepics_enabled?
        object.licensed_feature_available?(:subepics)
      end

      def work_item_status_enabled?
        object.licensed_feature_available?(:work_item_status)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/group_base_field.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    # rubocop: disable GraphQL/GraphqlName -- Not a type
    # rubocop: disable Graphql/AuthorizeTypes -- Not a type
    class GroupBaseField < ::Types::BaseField
      def initialize(**kwargs, &block)
        kwargs[:authorize] = :read_group

        super
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
    # rubocop: enable GraphQL/GraphqlName
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/group_interface.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    # This inteface sets [authorize: :read_group] (field-level authorization via
    # GroupBaseField) for all defined fields to ensure implementing types don't
    # expose inherited fields without proper authorization.
    #
    # Implementing types can opt-out from this field-level auth and use
    # type-level auth by re-defining the field without the authorize argument.
    # For example, GroupType uses :read_group type-level auth and redefines all
    # fields in this interface to opt-out while GroupMinimalAccessType uses
    # :read_group_metadata type-level auth to expose a set of defined fields and
    # leaves inherited fields it does not want to expose to use field-level auth
    # using :read_group.
    module GroupInterface
      include BaseInterface

      graphql_name 'GroupInterface'

      # rubocop:disable Layout/LineLength -- otherwise description is creating unnecessary newlines.
      description 'Returns either a "Group" type for users with :read_group permission, or a "GroupMinimalAccess" type for users with only :read_group_metadata permission.'
      # rubocop:enable Layout/LineLength

      field_class GroupBaseField

      field :id, GraphQL::Types::ID, null: true,
        description: 'ID of the group.'
      field :full_name, GraphQL::Types::String, null: true,
        description: 'Full name of the group.'
      field :name, GraphQL::Types::String, null: true,
        description: 'Name of the group.'
      field :web_url,
        type: GraphQL::Types::String,
        null: true,
        description: 'Web URL of the group.'
      field :avatar_url,
        type: GraphQL::Types::String,
        null: true,
        description: 'Avatar URL of the group.'

      def self.resolve_type(_object, _context)
        ::Types::GroupType
      end
    end
  end
end

Types::Namespaces::GroupInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/group_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    class GroupSortEnum < BaseEnum
      graphql_name 'GroupSort'
      description 'Values for sorting groups'

      value 'SIMILARITY',
        'Most similar to the search query.',
        value: :similarity

      value 'NAME_ASC',
        'Sort by name, ascending order.',
        value: :name_asc
      value 'NAME_DESC',
        'Sort by name, descending order.',
        value: :name_desc

      value 'PATH_ASC',
        'Sort by path, ascending order.',
        value: :path_asc
      value 'PATH_DESC',
        'Sort by path, descending order.',
        value: :path_desc

      value 'ID_ASC',
        'Sort by ID, ascending order.',
        value: :id_asc
      value 'ID_DESC',
        'Sort by ID, descending order.',
        value: :id_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespace/shared_runners_setting_enum.rb =====
# frozen_string_literal: true

module Types
  class Namespace::SharedRunnersSettingEnum < BaseEnum
    graphql_name 'SharedRunnersSetting'

    ::Namespace::SHARED_RUNNERS_SETTINGS.each do |type|
      value type.upcase,
        description: "Sharing of runners is #{type.tr('_', ' ')}.",
        value: type
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/link_paths/comment_template_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module LinkPaths
      class CommentTemplateType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'CommentTemplatePath'

        field :href,
          GraphQL::Types::String,
          null: false,
          description: 'Path of the comment template.'

        field :text,
          GraphQL::Types::String,
          null: false,
          description: 'Text used on the template path.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/link_paths/group_namespace_links_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module LinkPaths
      class GroupNamespaceLinksType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'GroupNamespaceLinks'
        implements ::Types::Namespaces::LinkPaths

        alias_method :group, :object

        def issues_list
          url_helpers.issues_group_path(group)
        end

        def labels_manage
          url_helpers.group_labels_path(group)
        end

        def new_project
          url_helpers.new_project_path(namespace_id: group&.id)
        end

        def report_abuse
          url_helpers.add_category_abuse_reports_path
        end

        def new_comment_template
          url_helpers.new_comment_template_paths(group)
        end
      end
    end
  end
end

::Types::Namespaces::LinkPaths::GroupNamespaceLinksType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/link_paths/project_namespace_links_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module LinkPaths
      class ProjectNamespaceLinksType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'ProjectNamespaceLinks'
        implements ::Types::Namespaces::LinkPaths

        field :new_work_item_email_address,
          GraphQL::Types::String,
          null: true,
          description: 'Email address that can be used to create a new work item in this project. ' \
            'Returns null if incoming email is not configured. More details on how to configure incoming email ' \
            'is in this [documentation](https://docs.gitlab.com/administration/incoming_email/#set-it-up).'

        def issues_list
          url_helpers.project_issues_path(project)
        end

        def labels_manage
          url_helpers.project_labels_path(project)
        end

        def new_project
          url_helpers.new_project_path(namespace_id: group&.id)
        end

        def new_comment_template
          url_helpers.new_comment_template_paths(group, project)
        end

        def contribution_guide_path
          return unless project&.repository

          ::ProjectPresenter.new(project).contribution_guide_path
        end

        def new_work_item_email_address
          project.new_issuable_address(current_user, 'issue')
        end

        private

        def project
          @project ||= object.project
        end

        def group
          @group ||= project.group
        end
      end
    end
  end
end

::Types::Namespaces::LinkPaths::ProjectNamespaceLinksType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/link_paths.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module LinkPaths
      include ::Types::BaseInterface

      graphql_name 'NamespacesLinkPaths'

      # rubocop: disable Graphql/AuthorizeTypes, GraphQL/GraphqlName -- helper class
      class UrlHelpers
        include GitlabRoutingHelper
        include Gitlab::Routing

        # required for the new_comment_template_paths
        include ::IssuablesHelper

        # required for the new_comment_template_paths
        public :new_comment_template_paths

        attr_reader :current_user

        def initialize(current_user)
          @current_user = current_user
        end
      end
      private_constant :UrlHelpers
      # rubocop: enable Graphql/AuthorizeTypes, GraphQL/GraphqlName

      TYPE_MAPPINGS = {
        ::Group => ::Types::Namespaces::LinkPaths::GroupNamespaceLinksType,
        ::Namespaces::ProjectNamespace => ::Types::Namespaces::LinkPaths::ProjectNamespaceLinksType,
        ::Namespaces::UserNamespace => ::Types::Namespaces::LinkPaths::UserNamespaceLinksType
      }.freeze

      field :issues_list,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace issues_list.',
        fallback_value: nil

      field :labels_manage,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace labels_manage.',
        fallback_value: nil

      field :new_project,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace new_project.',
        fallback_value: nil

      field :new_comment_template,
        [Types::Namespaces::LinkPaths::CommentTemplateType],
        null: true,
        description: 'Namespace new_comment_template_paths.',
        fallback_value: nil

      field :register,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace register_path.'

      field :report_abuse,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace report_abuse.'

      field :sign_in,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace sign_in_path.'

      field :contribution_guide_path,
        GraphQL::Types::String,
        null: true,
        description: 'Namespace contribution guide path.',
        fallback_value: nil,
        calls_gitaly: true

      field :emails_help_page_path,
        GraphQL::Types::String,
        null: true,
        description: 'Help page path for emails.'

      field :markdown_help_path,
        GraphQL::Types::String,
        null: true,
        description: 'Help page path for Markdown.'

      field :quick_actions_help_path,
        GraphQL::Types::String,
        null: true,
        description: 'Help page path for quick actions.'

      field :user_export_email,
        GraphQL::Types::String,
        null: true,
        description: 'User email for export CSV. Returns `null` for user namespaces.',
        fallback_value: nil,
        experiment: { milestone: '18.3' }

      def self.type_mappings
        TYPE_MAPPINGS
      end

      def self.resolve_type(object, _context)
        type_mappings[object.class] || raise("Unknown GraphQL type for namespace type #{object.class}")
      end

      orphan_types(*type_mappings.values)

      def register
        url_helpers.new_user_registration_path(redirect_to_referer: 'yes')
      end

      def report_abuse
        url_helpers.add_category_abuse_reports_path
      end

      def sign_in
        url_helpers.new_user_session_path(redirect_to_referer: 'yes')
      end

      def emails_help_page_path
        url_helpers.help_page_path('development/emails.md', anchor: 'email-namespace')
      end

      def markdown_help_path
        url_helpers.help_page_path('user/markdown.md')
      end

      def quick_actions_help_path
        url_helpers.help_page_path('user/project/quick_actions.md')
      end

      def user_export_email
        current_user&.notification_email_or_default
      end

      private

      def url_helpers
        @url_helpers ||= UrlHelpers.new(current_user)
      end
    end
  end
end

::Types::Namespaces::LinkPaths.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/link_paths/user_namespace_links_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module LinkPaths
      class UserNamespaceLinksType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'UserNamespaceLinks'
        implements ::Types::Namespaces::LinkPaths

        # Do not expose the export email for user namespaces, since exporting work items on this namespace type is not
        # supported
        def user_export_email; end
      end
    end
  end
end

::Types::Namespaces::LinkPaths::UserNamespaceLinksType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/markdown_paths/group_namespace_markdown_paths_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module MarkdownPaths
      class GroupNamespaceMarkdownPathsType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'GroupNamespaceMarkdownPaths'
        implements ::Types::Namespaces::MarkdownPaths

        alias_method :group, :object

        def uploads_path
          url_helpers.group_uploads_path(group)
        end

        def markdown_preview_path(iid: nil)
          url_helpers.group_preview_markdown_path(group, target_type: 'WorkItem', target_id: iid)
        end

        def autocomplete_sources_path(iid: nil, work_item_type_id: nil)
          params = build_autocomplete_params(iid: iid, work_item_type_id: work_item_type_id)

          {
            members: url_helpers.members_group_autocomplete_sources_path(group, params),
            issues: url_helpers.issues_group_autocomplete_sources_path(group, params),
            merge_requests: url_helpers.merge_requests_group_autocomplete_sources_path(group, params),
            labels: url_helpers.labels_group_autocomplete_sources_path(group, params),
            milestones: url_helpers.milestones_group_autocomplete_sources_path(group, params),
            commands: url_helpers.commands_group_autocomplete_sources_path(group, params)
          }
        end
      end
    end
  end
end

::Types::Namespaces::MarkdownPaths::GroupNamespaceMarkdownPathsType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/markdown_paths/project_namespace_markdown_paths_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module MarkdownPaths
      class ProjectNamespaceMarkdownPathsType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'ProjectNamespaceMarkdownPaths'
        implements ::Types::Namespaces::MarkdownPaths

        def uploads_path
          url_helpers.project_uploads_path(project)
        end

        def markdown_preview_path(iid: nil)
          url_helpers.project_preview_markdown_path(project, target_type: 'WorkItem', target_id: iid)
        end

        def autocomplete_sources_path(iid: nil, work_item_type_id: nil)
          params = build_autocomplete_params(iid: iid, work_item_type_id: work_item_type_id)

          {
            members: url_helpers.members_project_autocomplete_sources_path(project, params),
            issues: url_helpers.issues_project_autocomplete_sources_path(project, params),
            merge_requests: url_helpers.merge_requests_project_autocomplete_sources_path(project, params),
            labels: url_helpers.labels_project_autocomplete_sources_path(project, params),
            milestones: url_helpers.milestones_project_autocomplete_sources_path(project, params),
            commands: url_helpers.commands_project_autocomplete_sources_path(project, params),
            snippets: url_helpers.snippets_project_autocomplete_sources_path(project, params),
            contacts: url_helpers.contacts_project_autocomplete_sources_path(project, params),
            wikis: url_helpers.wikis_project_autocomplete_sources_path(project, params)
          }
        end

        def project
          @project ||= object.project
        end
      end
    end
  end
end

::Types::Namespaces::MarkdownPaths::ProjectNamespaceMarkdownPathsType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/markdown_paths.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module MarkdownPaths
      include ::Types::BaseInterface
      include ::IssuablesHelper

      graphql_name 'MarkdownPaths'

      TYPE_MAPPINGS = {
        ::Group => ::Types::Namespaces::MarkdownPaths::GroupNamespaceMarkdownPathsType,
        ::Namespaces::ProjectNamespace => ::Types::Namespaces::MarkdownPaths::ProjectNamespaceMarkdownPathsType,
        ::Namespaces::UserNamespace => ::Types::Namespaces::MarkdownPaths::UserNamespaceMarkdownPathsType
      }.freeze

      NEW_WORK_ITEM_IID = 'new-work-item-iid'

      field :uploads_path,
        GraphQL::Types::String,
        null: true,
        description: 'Uploads path for a given namespace.',
        fallback_value: nil

      field :markdown_preview_path,
        GraphQL::Types::String,
        null: true,
        description: 'Path for the markdown preview for given namespace.',
        fallback_value: nil do
          argument :iid, GraphQL::Types::String,
            required: false,
            description: 'IID of the target item for markdown preview.'
        end

      field :autocomplete_sources_path, # rubocop:disable Graphql/JSONType -- it return supported items in json
        GraphQL::Types::JSON,
        null: true,
        description: 'Supported paths for autocomplete sources for a given namespace.',
        fallback_value: nil do
          argument :iid, GraphQL::Types::String,
            required: false,
            description: 'IID of the work item.'
          argument :work_item_type_id, GraphQL::Types::String,
            required: false,
            description: 'ID of the work item type.'
        end

      def self.type_mappings
        TYPE_MAPPINGS
      end

      def self.resolve_type(object, _context)
        type_mappings[object.class] || raise("Unknown GraphQL type for namespace type #{object.class}")
      end

      orphan_types(*type_mappings.values)

      private

      def url_helpers
        ::Gitlab::Routing.url_helpers
      end

      def build_autocomplete_params(iid: nil, work_item_type_id: nil)
        strong_memoize_with(:build_autocomplete_params, iid, work_item_type_id) do
          params = { type: 'WorkItem' }

          if new_work_item?(iid) && work_item_type_id
            params[:work_item_type_id] = extract_id_from_gid(work_item_type_id)
          elsif iid
            params[:type_id] = iid
          end

          params
        end
      end

      def extract_id_from_gid(gid)
        GlobalID.parse(gid)&.model_id
      end

      def new_work_item?(iid)
        iid == NEW_WORK_ITEM_IID
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/markdown_paths/user_namespace_markdown_paths_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    module MarkdownPaths
      class UserNamespaceMarkdownPathsType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
        graphql_name 'UserNamespaceMarkdownPaths'
        implements ::Types::Namespaces::MarkdownPaths
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/project_statistics_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    # This type returns columns added by the `Namespace#with_statistics` scope.

    # `ResolvesGroups#resolve_with_lookahead` detects if the `project_statistics`
    # field is requested and passes the `with_statistics` argument to `GroupsFinder`
    # which then calls `Namespace#with_statistics`.
    class ProjectStatisticsType < BaseObject
      graphql_name 'NamespaceProjectStatistics'

      authorize :read_statistics

      field :build_artifacts_size, GraphQL::Types::Float, null: true,
        description: 'Build artifacts size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :lfs_objects_size,
        GraphQL::Types::Float,
        null: true,
        description: 'Large File Storage (LFS) object size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :packages_size, GraphQL::Types::Float, null: true,
        description: 'Packages size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :pipeline_artifacts_size, GraphQL::Types::Float, null: true,
        description: 'CI/CD Pipeline artifacts size in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :repository_size, GraphQL::Types::Float, null: true,
        description: 'Repository size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :snippets_size, GraphQL::Types::Float, null: true,
        description: 'Snippets size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :storage_size, GraphQL::Types::Float, null: true,
        description: 'Storage size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :uploads_size, GraphQL::Types::Float, null: true,
        description: 'Uploads size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field
      field :wiki_size, GraphQL::Types::Float, null: true,
        description: 'Wiki size of the project in bytes.',
        extras: [:graphql_name],
        resolver_method: :try_field

      def try_field(graphql_name:)
        object.try(graphql_name.underscore)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespaces/sidebar_type.rb =====
# frozen_string_literal: true

module Types
  module Namespaces
    class SidebarType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- parent is already authorized
      graphql_name 'NamespaceSidebar'

      alias_method :namespace, :object

      field :open_issues_count,
        GraphQL::Types::Int,
        null: true,
        description: 'Number of open issues of the namespace.'

      field :open_merge_requests_count, # rubocop:disable GraphQL/ExtractType -- no need to extract these into a field named "open"
        GraphQL::Types::Int,
        null: true,
        description: 'Number of open merge requests of the namespace.'

      def open_issues_count
        case namespace
        when ::Group
          group_open_issues_count
        when ::Namespaces::ProjectNamespace
          namespace.project.open_issues_count(context[:current_user])
        end
      end

      def open_merge_requests_count
        case namespace
        when Group
          ::Groups::MergeRequestsCountService.new(namespace, context[:current_user]).count
        when ::Namespaces::ProjectNamespace
          namespace.project.open_merge_requests_count
        end
      end

      def group_open_issues_count
        ::Groups::OpenIssuesCountService.new(namespace, context[:current_user], fast_timeout: true).count
      rescue ActiveRecord::QueryCanceled => e # rubocop:disable Database/RescueQueryCanceled -- used with fast_read_statement_timeout to prevent this count from slowing down the rest of the request
        Gitlab::ErrorTracking.log_exception(e, group_id: namespace.id, query: 'group_sidebar_issues_count')

        nil
      end
    end
  end
end

Types::Namespaces::SidebarType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/namespace_type.rb =====
# frozen_string_literal: true

module Types
  class NamespaceType < BaseObject
    graphql_name 'Namespace'

    authorize :read_namespace

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    implements Types::TodoableInterface
    expose_permissions Types::PermissionTypes::Namespaces::Base

    field :id, GraphQL::Types::ID, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'ID of the namespace.'

    field :full_name, GraphQL::Types::String, null: false,
      description: 'Full name of the namespace.'
    field :full_path, GraphQL::Types::ID, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Full path of the namespace.'
    field :name, GraphQL::Types::String, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Name of the namespace.'
    field :path, GraphQL::Types::String, null: false,
      description: 'Path of the namespace.'

    field :cross_project_pipeline_available,
      GraphQL::Types::Boolean,
      null: false,
      resolver_method: :cross_project_pipeline_available?,
      description: 'Indicates if the cross_project_pipeline feature is available for the namespace.'

    field :description, GraphQL::Types::String, null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Description of the namespace.'

    field :lfs_enabled,
      GraphQL::Types::Boolean,
      null: true,
      method: :lfs_enabled?,
      description: 'Indicates if Large File Storage (LFS) is enabled for namespace.'
    field :merge_requests_enabled,
      GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if merge requests are enabled for the namespace.',
      experiment: { milestone: '18.3' }
    field :request_access_enabled,
      GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if users can request access to namespace.'
    field :visibility, GraphQL::Types::String, null: true,
      description: 'Visibility of the namespace.'

    field :root_storage_statistics, Types::RootStorageStatisticsType,
      null: true,
      description: 'Aggregated storage statistics of the namespace. Only available for root namespaces.'

    field :projects, Types::ProjectType.connection_type, null: false,
      description: 'Projects within this namespace. ' \
        'Returns projects from the parent group if namespace is project.',
      resolver: ::Resolvers::NamespaceProjectsResolver

    field :package_settings,
      Types::Namespace::PackageSettingsType,
      null: true,
      description: 'Package settings for the namespace.'

    field :avatar_url, GraphQL::Types::String,
      null: true,
      description: 'URL to avatar image file of the namespace.'

    field :ci_cd_settings,
      Types::Ci::NamespaceSettingsType,
      null: true,
      experiment: { milestone: '17.9' },
      description: 'Namespace CI/CD settings for the namespace.',
      method: :namespace_settings

    field :shared_runners_setting,
      Types::Namespace::SharedRunnersSettingEnum,
      null: true,
      description: "Shared runners availability for the namespace and its descendants."

    field :timelog_categories,
      Types::TimeTracking::TimelogCategoryType.connection_type,
      null: true,
      description: "Timelog categories for the namespace.",
      experiment: { milestone: '15.3' }

    field :achievements,
      Types::Achievements::AchievementType.connection_type,
      null: true,
      experiment: { milestone: '15.8' },
      description: "Achievements for the namespace. " \
        "Returns `null` if the `achievements` feature flag is disabled.",
      extras: [:lookahead],
      resolver: ::Resolvers::Achievements::AchievementsResolver

    field :achievements_path, GraphQL::Types::String,
      null: true,
      experiment: { milestone: '17.0' },
      description: "Path for the namespace's achievements. " \
        "Returns `null` if the namespace is not a group, or the `achievements` feature flag is disabled."

    field :work_item, Types::WorkItemType,
      null: true,
      scopes: [:api, :read_api, :ai_workflows],
      resolver: Resolvers::Namespaces::WorkItemResolver,
      experiment: { milestone: '16.10' },
      description: 'Find a work item by IID directly associated with the namespace (project or group)'

    field :work_items,
      null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Work items that belong to the namespace (project or group). Returns `null` for user namespaces.',
      experiment: { milestone: '18.1' },
      resolver: ::Resolvers::Namespaces::WorkItemsResolver

    field :work_item_state_counts,
      Types::WorkItemStateCountsType,
      null: true,
      experiment: { milestone: '18.3' },
      description: 'Counts of work items by state for the namespace (project or group). Returns `null` for user ' \
        'namespaces.',
      resolver: Resolvers::Namespaces::WorkItemStateCountsResolver

    field :work_items_widgets,
      null: true,
      description: 'List of available widgets for the given work items.',
      experiment: { milestone: '18.2' },
      resolver: ::Resolvers::WorkItems::WidgetsResolver

    field :work_item_types, Types::WorkItems::TypeType.connection_type,
      scopes: [:api, :read_api, :ai_workflows],
      resolver: Resolvers::WorkItems::TypesResolver,
      experiment: { milestone: '17.2' },
      description: 'Work item types available to the namespace.'

    field :pages_deployments, Types::PagesDeploymentType.connection_type, null: true,
      resolver: Resolvers::PagesDeploymentsResolver,
      connection: true,
      description: "List of the namespaces's Pages Deployments."

    field :import_source_users, Import::SourceUserType.connection_type,
      null: true,
      experiment: { milestone: '17.2' },
      resolver: Resolvers::Import::SourceUsersResolver,
      description: 'Import source users of the namespace. This field can only be resolved for one namespace in any ' \
        'single request.' do
      extension(::Gitlab::Graphql::Limit::FieldCallCount, limit: 1)
    end

    field :sidebar,
      Types::Namespaces::SidebarType,
      null: true,
      description: 'Data needed to render the sidebar for the namespace.',
      method: :itself,
      experiment: { milestone: '17.6' }

    field :work_item_description_templates,
      Types::WorkItems::DescriptionTemplateType.connection_type,
      resolver: Resolvers::WorkItems::DescriptionTemplatesResolver,
      null: true, experiment: { milestone: '17.6' },
      calls_gitaly: true,
      description: 'Work item description templates available to the namespace.'

    field :link_paths,
      Types::Namespaces::LinkPaths,
      null: true,
      description: 'Namespace relevant paths to create links on the UI.',
      method: :itself,
      experiment: { milestone: '18.1' }

    field :markdown_paths,
      Types::Namespaces::MarkdownPaths,
      null: true,
      description: 'Namespace relevant paths to create markdown links on the UI.',
      method: :itself,
      experiment: { milestone: '18.1' }

    # TODO: Remove once the frontend switches to using available_features.
    # See: https://gitlab.com/gitlab-org/gitlab/-/issues/555803
    field :licensed_features,
      Types::Namespaces::AvailableFeaturesType,
      null: false,
      description: 'Licensed features available on the namespace.',
      method: :itself,
      experiment: { milestone: '18.1' }

    field :available_features,
      Types::Namespaces::AvailableFeaturesType,
      null: false,
      description: 'Features available on the namespace.',
      method: :itself,
      experiment: { milestone: '18.3' }

    field :web_url,
      GraphQL::Types::String,
      null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'URL of the namespace.'

    markdown_field :description_html, null: true, &:namespace_details

    def achievements_path
      return unless Feature.enabled?(:achievements, object)

      ::Gitlab::Routing.url_helpers.group_achievements_path(object) if object.is_a?(Group)
    end

    def timelog_categories
      object.timelog_categories if Feature.enabled?(:timelog_categories)
    end

    def cross_project_pipeline_available?
      object.licensed_feature_available?(:cross_project_pipelines)
    end

    def merge_requests_enabled
      return object.project.merge_requests_enabled? if object.is_a?(::Namespaces::ProjectNamespace)

      true
    end

    def root_storage_statistics
      Gitlab::Graphql::Loaders::BatchRootStorageStatisticsLoader.new(object.id).find
    end
  end
end

Types::NamespaceType.prepend_mod_with('Types::NamespaceType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/negated_milestone_wildcard_id_enum.rb =====
# frozen_string_literal: true

module Types
  class NegatedMilestoneWildcardIdEnum < BaseEnum
    graphql_name 'NegatedMilestoneWildcardId'
    description 'Negated Milestone ID wildcard values'

    value 'STARTED', 'Milestone assigned is open and yet to be started (start date > today).'
    value 'UPCOMING', description: "Milestone assigned is open but starts in the past (start date <= today). " \
                        "This differs from the behavior in the [REST API implementation](https://docs.gitlab.com/api/issues/#list-issues)."
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/nested_environment_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class NestedEnvironmentType < BaseObject
    graphql_name 'NestedEnvironment'
    description 'Describes where code is deployed for a project organized by folder.'

    field :name, GraphQL::Types::String,
      null: false, description: 'Human-readable name of the environment.'

    field :size, GraphQL::Types::Int,
      null: false, description: 'Number of environments nested in the folder.'

    field :environment,
      Types::EnvironmentType,
      null: true, description: 'Latest environment in the folder.'

    def environment
      BatchLoader::GraphQL.for(object.last_id).batch do |environment_ids, loader|
        Environment.id_in(environment_ids).each do |environment|
          loader.call(environment.id, environment)
        end
      end
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/noteable_type.rb =====
# frozen_string_literal: true

module Types
  class NoteableType < BaseUnion
    graphql_name 'NoteableType'
    description 'Represents an object that supports notes.'

    possible_types Types::IssueType, Types::DesignManagement::DesignType, Types::MergeRequestType

    def self.resolve_type(object, context)
      case object
      when Issue
        Types::IssueType
      when ::DesignManagement::Design
        Types::DesignManagement::DesignType
      when MergeRequest
        Types::MergeRequestType
      else
        raise 'Unsupported issuable type'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/abuse_report/discussion_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    module AbuseReport
      class DiscussionType < BaseObject
        graphql_name 'AbuseReportDiscussion'

        authorize :read_note

        DiscussionID = ::Types::GlobalIDType[::Discussion]

        implements Types::Notes::BaseDiscussionInterface

        field :abuse_report, Types::AbuseReportType, null: true,
          description: 'Abuse report which the discussion belongs to.'

        field :notes, Types::Notes::AbuseReport::NoteType.connection_type, null: false,
          description: 'All notes in the discussion.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/abuse_report/note_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    module AbuseReport
      class NoteType < BaseObject
        graphql_name 'AbuseReportNote'

        include ActionView::Helpers::SanitizeHelper

        implements Types::Notes::BaseNoteInterface

        present_using NotePresenter

        authorize :read_note

        field :id, ::Types::GlobalIDType[::AntiAbuse::Reports::Note],
          null: false,
          description: 'ID of the note.'

        field :discussion, Types::Notes::AbuseReport::DiscussionType,
          null: true,
          description: 'Discussion the note is a part of.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/base_discussion_interface.rb =====
# frozen_string_literal: true

module Types
  module Notes
    module BaseDiscussionInterface
      include Types::BaseInterface

      DiscussionID = ::Types::GlobalIDType[::Discussion]

      implements Types::ResolvableInterface

      field :created_at, Types::TimeType, null: false,
        description: "Timestamp of the discussion's creation."
      field :id, DiscussionID, null: false,
        description: "ID of the discussion."
      field :reply_id, DiscussionID, null: false,
        description: 'ID used to reply to the discussion.'

      # DiscussionID.coerce_result is suitable here, but will always mark this
      # as being a 'Discussion'. Using `GlobalId.build` guarantees that we get
      # the correct class, and that it matches `id`.
      def reply_id
        ::Gitlab::GlobalId.build(object, id: object.reply_id)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/base_note_interface.rb =====
# frozen_string_literal: true

module Types
  module Notes
    module BaseNoteInterface
      include Types::BaseInterface

      implements Types::ResolvableInterface

      field :author, Types::UserType,
        null: true,
        scopes: [:api, :read_api, :ai_workflows],
        description: 'User who wrote the note.'

      field :award_emoji, Types::AwardEmojis::AwardEmojiType.connection_type,
        null: true,
        description: 'List of emoji reactions associated with the note.'

      field :body, GraphQL::Types::String,
        null: false,
        scopes: [:api, :read_api, :ai_workflows],
        method: :note,
        description: 'Content of the note.'

      field :body_first_line_html, GraphQL::Types::String,
        method: :note_first_line_html,
        null: false,
        description: 'First line of the note content.'

      field :body_html, GraphQL::Types::String,
        method: :note_html,
        null: true,
        calls_gitaly: true,
        description: "GitLab Flavored Markdown rendering of the content of the note."

      field :created_at, Types::TimeType,
        scopes: [:api, :read_api, :ai_workflows],
        null: false,
        description: 'Timestamp of the note creation.'

      field :last_edited_at, Types::TimeType,
        null: true,
        description: 'Timestamp when note was last edited.'

      field :last_edited_by, Types::UserType,
        null: true,
        description: 'User who last edited the note.'

      field :updated_at, Types::TimeType,
        null: false,
        description: "Timestamp of the note's last activity."

      field :url, GraphQL::Types::String,
        null: true,
        description: 'URL to view the note in the Web UI.'

      def author
        Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.author_id).find
      end

      def url
        # compute note url if noteable_url is not already precomputed
        return ::Gitlab::UrlBuilder.build(object) unless context[:noteable_url]

        context[:noteable_url] + "#note_#{object.id}"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/deleted_note_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    # rubocop: disable Graphql/AuthorizeTypes
    class DeletedNoteType < BaseObject
      graphql_name 'DeletedNote'

      field :id, ::Types::GlobalIDType[::Note],
        null: false,
        description: 'ID of the deleted note.'

      field :discussion_id, ::Types::GlobalIDType[::Discussion],
        null: true,
        description: 'ID of the discussion for the deleted note.'

      field :last_discussion_note, GraphQL::Types::Boolean,
        null: true,
        description: 'Whether deleted note is the last note in the discussion.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/diff_image_position_input_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class DiffImagePositionInputType < DiffPositionBaseInputType
      graphql_name 'DiffImagePositionInput'

      argument :height,
        GraphQL::Types::Int,
        required: true,
        description: copy_field_description(Types::Notes::DiffPositionType, :height)
      argument :width,
        GraphQL::Types::Int,
        required: true,
        description: copy_field_description(Types::Notes::DiffPositionType, :width)
      argument :x,
        GraphQL::Types::Int,
        required: true,
        description: copy_field_description(Types::Notes::DiffPositionType, :x)
      argument :y,
        GraphQL::Types::Int,
        required: true,
        description: copy_field_description(Types::Notes::DiffPositionType, :y)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/diff_position_base_input_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class DiffPositionBaseInputType < BaseInputObject
      argument :base_sha, GraphQL::Types::String, required: false,
        description: copy_field_description(Types::DiffRefsType, :base_sha)
      argument :head_sha, GraphQL::Types::String, required: true,
        description: copy_field_description(Types::DiffRefsType, :head_sha)
      argument :start_sha, GraphQL::Types::String, required: true,
        description: copy_field_description(Types::DiffRefsType, :start_sha)

      argument :paths,
        Types::DiffPathsInputType,
        required: true,
        description: 'The paths of the file that was changed. ' \
          'Both of the properties of this input are optional, but at least one of them is required'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/diff_position_input_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class DiffPositionInputType < DiffPositionBaseInputType
      graphql_name 'DiffPositionInput'

      argument :new_line, GraphQL::Types::Int, required: false,
        description: "#{copy_field_description(Types::Notes::DiffPositionType, :new_line)} Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field."
      argument :old_line, GraphQL::Types::Int, required: false,
        description: "#{copy_field_description(Types::Notes::DiffPositionType, :old_line)} Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/diff_position_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `NoteType` that has its own authorization
    class DiffPositionType < BaseObject
      graphql_name 'DiffPosition'

      field :diff_refs,
        Types::DiffRefsType,
        null: false,
        description: 'Information about the branch, HEAD, and base at the time of commenting.'

      field :file_path, GraphQL::Types::String, null: false,
        description: 'Path of the file that was changed.'
      field :new_path, GraphQL::Types::String, null: true,
        description: 'Path of the file on the HEAD SHA.'
      field :old_path, GraphQL::Types::String, null: true,
        description: 'Path of the file on the start SHA.'
      field :position_type, Types::Notes::PositionTypeEnum, null: false,
        description: 'Type of file the position refers to.'

      # Fields for text positions
      field :new_line, GraphQL::Types::Int, null: true,
        description: 'Line on HEAD SHA that was changed.'
      field :old_line, GraphQL::Types::Int, null: true,
        description: 'Line on start SHA that was changed.'

      # Fields for image positions
      field :height, GraphQL::Types::Int, null: true,
        description: 'Total height of the image.'
      field :width, GraphQL::Types::Int, null: true,
        description: 'Total width of the image.'
      field :x, GraphQL::Types::Int, null: true,
        description: 'X position of the note.'
      field :y, GraphQL::Types::Int, null: true,
        description: 'Y position of the note.'

      def old_line
        object.old_line if object.on_text?
      end

      def new_line
        object.new_line if object.on_text?
      end

      def x
        object.x if object.on_image?
      end

      def y
        object.y if object.on_image?
      end

      def width
        object.width if object.on_image?
      end

      def height
        object.height if object.on_image?
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/discussion_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class DiscussionType < BaseObject
      graphql_name 'Discussion'

      authorize :read_note

      implements Types::Notes::BaseDiscussionInterface
      expose_permissions ::Types::PermissionTypes::Notes::Discussion

      field :noteable, Types::NoteableType, null: true,
        description: 'Object which the discussion belongs to.'
      field :notes, Types::Notes::NoteType.connection_type, null: false,
        description: 'All notes in the discussion.',
        max_page_size: 200

      def noteable
        noteable = object.noteable

        return unless Ability.allowed?(context[:current_user], :"read_#{noteable.to_ability_name}", noteable)

        noteable
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/noteable_interface.rb =====
# frozen_string_literal: true

module Types
  module Notes
    module NoteableInterface
      include Types::BaseInterface

      field :notes, resolver: Resolvers::Noteable::NotesResolver, null: false,
        description: "All notes on this noteable."
      field :discussions, Types::Notes::DiscussionType.connection_type, null: false,
        description: "All discussions on the noteable."
      field :commenters, Types::UserType.connection_type, null: false, description: "All commenters on the noteable."

      def self.resolve_type(object, context)
        case object
        when Issue
          Types::IssueType
        when MergeRequest
          Types::MergeRequestType
        when Snippet
          Types::SnippetType
        when ::DesignManagement::Design
          Types::DesignManagement::DesignType
        when ::AlertManagement::Alert
          Types::AlertManagement::AlertType
        when WikiPage::Meta
          Types::Wikis::WikiPageType
        else
          raise "Unknown GraphQL type for #{object}"
        end
      end

      def commenters
        object.commenters(user: current_user)
      end
    end
  end
end

Types::Notes::NoteableInterface.prepend_mod_with('Types::Notes::NoteableInterface')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/note_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class NoteType < BaseObject
      graphql_name 'Note'

      connection_type_class Types::CountableConnectionType

      authorize :read_note

      expose_permissions Types::PermissionTypes::Note

      implements Types::Notes::BaseNoteInterface

      def self.authorization_scopes
        super + [:ai_workflows]
      end

      present_using NotePresenter

      field :max_access_level_of_author, GraphQL::Types::String,
        null: true,
        description: "Max access level of the note author in the project.",
        method: :human_max_access

      field :id, ::Types::GlobalIDType[::Note],
        scopes: [:api, :read_api, :ai_workflows],
        null: false,
        description: 'ID of the note.'

      field :project, Types::ProjectType,
        null: true,
        description: 'Project associated with the note.'

      field :system, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates whether the note was created by the system or by a user.'
      field :system_note_icon_name, GraphQL::Types::String,
        null: true,
        description: 'Name of the icon corresponding to a system note.'

      field :imported, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the note was imported.',
        method: :imported?
      field :internal, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates if the note is internal.',
        method: :confidential?

      field :discussion, Types::Notes::DiscussionType,
        null: true,
        description: 'Discussion the note is a part of.'
      field :position, Types::Notes::DiffPositionType,
        null: true,
        description: 'Position of the note on a diff.'

      field :author_is_contributor, GraphQL::Types::Boolean,
        null: true,
        description: 'Indicates whether the note author is a contributor.',
        method: :contributor?,
        calls_gitaly: true

      field :system_note_metadata, Types::Notes::SystemNoteMetadataType,
        null: true,
        description: 'Metadata for the given note if it is a system note.'

      field :external_author, GraphQL::Types::String,
        null: true,
        description: 'Email address of non-GitLab user adding the note. For guests, the email address is obfuscated.'

      def system_note_icon_name
        SystemNoteHelper.system_note_icon_name(object) if object.system?
      end

      def project
        Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
      end

      # We now support also SyntheticNote notes as a NoteType, but SyntheticNote does not have a real note ID,
      # as SyntheticNote is generated dynamically from a ResourceEvent instance.
      def id
        return super unless object.is_a?(SyntheticNote)

        # object is a presenter, so object.object returns the concrete note object.
        ::Gitlab::GlobalId.build(object, model_name: object.object.class.to_s, id: object.discussion_id)
      end

      def position
        object.position if object.position.is_a?(Gitlab::Diff::Position)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/position_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class PositionTypeEnum < BaseEnum
      graphql_name 'DiffPositionType'
      description 'Type of file the position refers to'

      value 'text', description: "Text file."
      value 'image', description: "An image."
      value 'file', description: "Unknown file type."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/quick_actions_status_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class QuickActionsStatusType < BaseObject
      graphql_name 'QuickActionsStatus'

      authorize :read_note

      field :messages, [GraphQL::Types::String],
        null: true,
        description: 'Response messages from quick actions.'

      field :command_names, [GraphQL::Types::String],
        null: true,
        description: 'Quick action command names.'

      field :commands_only, GraphQL::Types::Boolean,
        null: true,
        description: 'Returns true if only quick action commands were in the note.'

      field :error_messages, [GraphQL::Types::String],
        null: true,
        description: 'Error messages from quick actions that failed to apply.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/system_note_metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    class SystemNoteMetadataType < BaseObject
      graphql_name 'SystemNoteMetadata'

      authorize :read_note

      field :id, ::Types::GlobalIDType[::SystemNoteMetadata],
        null: false,
        description: 'Global ID of the specific system note metadata.'

      field :action, GraphQL::Types::String,
        null: true,
        description: 'System note metadata action.'
      field :description_version, ::Types::DescriptionVersionType,
        null: true,
        description: 'Version of the changed description.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/notes/update_diff_image_position_input_type.rb =====
# frozen_string_literal: true

module Types
  module Notes
    # InputType used for updateImageDiffNote mutation.
    class UpdateDiffImagePositionInputType < BaseInputObject
      graphql_name 'UpdateDiffImagePositionInput'

      argument :x, GraphQL::Types::Int,
        required: false,
        description: copy_field_description(Types::Notes::DiffPositionType, :x)

      argument :y, GraphQL::Types::Int,
        required: false,
        description: copy_field_description(Types::Notes::DiffPositionType, :y)

      argument :width, GraphQL::Types::Int,
        required: false,
        description: copy_field_description(Types::Notes::DiffPositionType, :width)

      argument :height, GraphQL::Types::Int,
        required: false,
        description: copy_field_description(Types::Notes::DiffPositionType, :height)

      def prepare
        to_h.compact.tap do |properties|
          if properties.empty?
            raise GraphQL::ExecutionError, "At least one property of `#{self.class.graphql_name}` must be set"
          end
        end

        super
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/groups_projects_display_enum.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    class GroupsProjectsDisplayEnum < BaseEnum
      graphql_name 'OrganizationGroupProjectDisplay'
      description 'Default list view for organization groups and projects.'

      UserPreference.organization_groups_projects_displays.each_key do |field|
        value field.upcase, value: field,
          description: "Display organization #{field} list.",
          experiment: { milestone: '17.2' }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/groups_projects_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    class GroupsProjectsSortEnum < SortEnum
      graphql_name 'OrganizationGroupProjectSort'
      description 'Values for sorting organization groups and projects.'

      value 'NAME_DESC', 'Name descending order.', value: :name_desc, experiment: { milestone: '17.2' }
      value 'NAME_ASC', 'Name ascending order.', value: :name_asc, experiment: { milestone: '17.2' }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/organization_type.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    class OrganizationType < BaseObject
      graphql_name 'Organization'

      connection_type_class Types::CountableConnectionType

      authorize :read_organization

      field :avatar_url,
        type: GraphQL::Types::String,
        null: true,
        description: 'Avatar URL of the organization.',
        experiment: { milestone: '16.7' }
      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of the organization.',
        experiment: { milestone: '16.7' }
      field :groups,
        Types::GroupType.connection_type,
        null: false,
        description: 'Groups within this organization that the user has access to.',
        experiment: { milestone: '16.4' },
        resolver: ::Resolvers::Organizations::GroupsResolver
      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'ID of the organization.',
        experiment: { milestone: '16.4' }
      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the organization.',
        experiment: { milestone: '16.4' }
      field :organization_users,
        null: false,
        description: 'Users with access to the organization.',
        experiment: { milestone: '16.4' },
        resolver: ::Resolvers::Organizations::OrganizationUsersResolver
      field :path,
        GraphQL::Types::String,
        null: false,
        description: 'Path of the organization.',
        experiment: { milestone: '16.4' }
      field :projects, Types::ProjectType.connection_type, null: false,
        description: 'Projects within this organization that the user has access to.',
        experiment: { milestone: '16.8' },
        resolver: ::Resolvers::Organizations::ProjectsResolver
      field :web_url,
        GraphQL::Types::String,
        null: false,
        description: 'Web URL of the organization.',
        experiment: { milestone: '16.6' }

      markdown_field :description_html, null: true, experiment: { milestone: '16.7' }, &:organization_detail

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
  end
end

Types::Organizations::OrganizationType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/organization_user_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    class OrganizationUserAccessLevelEnum < BaseEnum
      graphql_name 'OrganizationUserAccessLevel'
      description 'Access level of an organization user'

      value 'DEFAULT', value: Gitlab::Access::GUEST, description: 'Guest access.', experiment: { milestone: '16.11' }
      value 'OWNER', value: Gitlab::Access::OWNER, description: 'Owner access.', experiment: { milestone: '16.11' }
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/organization_user_access_level_type.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    # rubocop:disable Graphql/AuthorizeTypes -- -- Already authorized in parent OrganizationUserType.
    class OrganizationUserAccessLevelType < Types::BaseObject
      graphql_name 'OrganizationUserAccess'
      description 'Represents the access level of a relationship between a User and Organization that it is related to'

      field :integer_value, GraphQL::Types::Int,
        description: 'Integer representation of access level.',
        experiment: { milestone: '16.11' },
        method: :to_i

      field :string_value, Types::Organizations::OrganizationUserAccessLevelEnum,
        description: 'String representation of access level.',
        experiment: { milestone: '16.11' },
        method: :to_i
    end
    # rubocop:enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/organization_user_badge_type.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    # rubocop: disable Graphql/AuthorizeTypes -- Already authorized in parent OrganizationUserType.
    class OrganizationUserBadgeType < BaseObject
      graphql_name 'OrganizationUserBadge'
      description 'An organization user badge.'

      field :text,
        GraphQL::Types::String,
        null: false,
        description: 'Badge text.'

      field :variant,
        GraphQL::Types::String,
        null: false,
        description: 'Badge variant.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/organizations/organization_user_type.rb =====
# frozen_string_literal: true

module Types
  module Organizations
    class OrganizationUserType < BaseObject
      graphql_name 'OrganizationUser'
      description 'A user with access to the organization.'

      include ::UsersHelper

      authorize :read_organization_user

      alias_method :organization_user, :object

      expose_permissions Types::PermissionTypes::OrganizationUser

      field :access_level,
        ::Types::Organizations::OrganizationUserAccessLevelType,
        null: false,
        description: 'Access level of the user in the organization.',
        experiment: { milestone: '16.11' },
        method: :access_level_before_type_cast
      field :badges,
        [::Types::Organizations::OrganizationUserBadgeType],
        null: true,
        description: 'Badges describing the user within the organization.',
        experiment: { milestone: '16.4' }
      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'ID of the organization user.',
        experiment: { milestone: '16.4' }
      field :is_last_owner,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Whether the user is the last owner of the organization.',
        experiment: { milestone: '16.11' },
        method: :last_owner?
      field :user,
        ::Types::UserType,
        null: false,
        description: 'User that is associated with the organization.',
        experiment: { milestone: '16.4' }

      def badges
        user_badges_in_admin_section(organization_user.user)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/cleanup/keep_duplicated_package_files_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Cleanup
      class KeepDuplicatedPackageFilesEnum < BaseEnum
        graphql_name 'PackagesCleanupKeepDuplicatedPackageFilesEnum'

        OPTIONS_MAPPING = {
          'all' => 'ALL_PACKAGE_FILES',
          '1' => 'ONE_PACKAGE_FILE',
          '10' => 'TEN_PACKAGE_FILES',
          '20' => 'TWENTY_PACKAGE_FILES',
          '30' => 'THIRTY_PACKAGE_FILES',
          '40' => 'FORTY_PACKAGE_FILES',
          '50' => 'FIFTY_PACKAGE_FILES'
        }.freeze

        ::Packages::Cleanup::Policy::KEEP_N_DUPLICATED_PACKAGE_FILES_VALUES.each do |keep_value|
          value OPTIONS_MAPPING[keep_value], value: keep_value, description: "Value to keep #{keep_value} package files"
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/cleanup/policy_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Cleanup
      class PolicyType < ::Types::BaseObject
        graphql_name 'PackagesCleanupPolicy'
        description 'A packages cleanup policy designed to keep only packages and packages assets that matter most'

        authorize :admin_package

        field :keep_n_duplicated_package_files,
          Types::Packages::Cleanup::KeepDuplicatedPackageFilesEnum,
          null: false,
          description: 'Number of duplicated package files to retain.'
        field :next_run_at,
          Types::TimeType,
          null: true,
          description: 'Next time that the packages cleanup policy will be executed.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/composer/json_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Composer
      # rubocop: disable Graphql/AuthorizeTypes
      class JsonType < BaseObject
        graphql_name 'PackageComposerJsonType'
        description 'Represents a composer JSON file'

        field :license, GraphQL::Types::String, null: true, description: 'License set in the Composer JSON file.'
        field :name, GraphQL::Types::String, null: true, description: 'Name set in the Composer JSON file.'
        field :type, GraphQL::Types::String, null: true, description: 'Type set in the Composer JSON file.'
        field :version, GraphQL::Types::String, null: true, description: 'Version set in the Composer JSON file.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/composer/metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Composer
      class MetadatumType < BaseObject
        graphql_name 'ComposerMetadata'
        description 'Composer metadata'

        authorize :read_package

        field :composer_json, Types::Packages::Composer::JsonType, null: false,
          description: 'Data of the Composer JSON file.'
        field :target_sha, GraphQL::Types::String, null: false, description: 'Target SHA of the package.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/conan/file_metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Conan
      class FileMetadatumType < BaseObject
        graphql_name 'ConanFileMetadata'
        description 'Conan file metadata'

        implements Types::Packages::FileMetadataType

        authorize :read_package

        field :conan_file_type, ::Types::Packages::Conan::MetadatumFileTypeEnum, null: false,
          description: 'Type of the Conan file.'
        field :conan_package_reference, GraphQL::Types::String, null: true,
          description: 'Reference of the Conan package.',
          method: :package_reference_value
        field :id, ::Types::GlobalIDType[::Packages::Conan::FileMetadatum], null: false,
          description: 'ID of the metadatum.'
        field :package_revision, GraphQL::Types::String, null: true, description: 'Revision of the package.',
          method: :package_revision_value
        field :recipe_revision, GraphQL::Types::String, null: false, description: 'Revision of the Conan recipe.',
          method: :recipe_revision_value
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/conan/metadatum_file_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Conan
      class MetadatumFileTypeEnum < BaseEnum
        graphql_name 'ConanMetadatumFileTypeEnum'
        description 'Conan file types'

        ::Packages::Conan::FileMetadatum.conan_file_types.keys.each do |file|
          value file.upcase, value: file, description: "A #{file.humanize(capitalize: false)} type."
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/conan/metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Conan
      class MetadatumType < BaseObject
        graphql_name 'ConanMetadata'
        description 'Conan metadata'

        authorize :read_package

        field :created_at, Types::TimeType, null: false, description: 'Date of creation.'
        field :id, ::Types::GlobalIDType[::Packages::Conan::Metadatum], null: false, description: 'ID of the metadatum.'
        field :package_channel, GraphQL::Types::String, null: false, description: 'Channel of the Conan package.'
        field :package_username, GraphQL::Types::String, null: false, description: 'Username of the Conan package.'
        field :recipe, GraphQL::Types::String, null: false, description: 'Recipe of the Conan package.'
        field :recipe_path, GraphQL::Types::String, null: false, description: 'Recipe path of the Conan package.'
        field :updated_at, Types::TimeType, null: false, description: 'Date of most recent update.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/dependency_link_metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class DependencyLinkMetadataType < BaseUnion
      graphql_name 'DependencyLinkMetadata'
      description 'Represents metadata associated with a dependency link'

      possible_types ::Types::Packages::Nuget::DependencyLinkMetadatumType

      def self.resolve_type(object, context)
        case object
        when ::Packages::Nuget::DependencyLinkMetadatum
          ::Types::Packages::Nuget::DependencyLinkMetadatumType
        else
          # NOTE: This method must be kept in sync with `PackageDependencyLinkType#metadata`,
          # which must never produce data that this discriminator cannot handle.
          raise 'Unsupported metadata type'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/file_metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module FileMetadataType
      include ::Types::BaseInterface
      graphql_name 'PackageFileMetadata'
      description 'Represents metadata associated with a Package file'

      field :created_at, ::Types::TimeType, null: false, description: 'Date of creation.'
      field :updated_at, ::Types::TimeType, null: false, description: 'Date of most recent update.'

      def self.resolve_type(object, context)
        case object
        when ::Packages::Conan::FileMetadatum
          ::Types::Packages::Conan::FileMetadatumType
        when ::Packages::Helm::FileMetadatum
          ::Types::Packages::Helm::FileMetadatumType
        else
          # NOTE: This method must be kept in sync with `PackageFileType#file_metadata`,
          # which must never produce data that this discriminator cannot handle.
          raise 'Unsupported file metadata type'
        end
      end

      orphan_types Types::Packages::Conan::FileMetadatumType,
        Types::Packages::Helm::FileMetadatumType
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/helm/dependency_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Helm
      # rubocop: disable Graphql/AuthorizeTypes
      class DependencyType < BaseObject
        graphql_name 'PackageHelmDependencyType'
        description 'Represents a Helm dependency'

        # Need to be synced with app/validators/json_schemas/helm_metadata.json#dependencies
        field :alias,
          GraphQL::Types::String,
          null: true,
          description: 'Alias of the dependency.',
          resolver_method: :resolve_alias
        field :condition, GraphQL::Types::String, null: true, description: 'Condition of the dependency.'
        field :enabled, GraphQL::Types::Boolean, null: true, description: 'Indicates the dependency is enabled.'
        field :import_values, [GraphQL::Types::JSON], null: true, description: 'Import-values of the dependency.',
          hash_key: :'import-values'
        field :name, GraphQL::Types::String, null: true, description: 'Name of the dependency.'
        field :repository, GraphQL::Types::String, null: true, description: 'Repository of the dependency.'
        field :tags, [GraphQL::Types::String], null: true, description: 'Tags of the dependency.'
        field :version, GraphQL::Types::String, null: true, description: 'Version of the dependency.'

        # field :alias` conflicts with a built-in method
        def resolve_alias
          object['alias']
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/helm/file_metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Helm
      class FileMetadatumType < BaseObject
        graphql_name 'HelmFileMetadata'
        description 'Helm file metadata'

        implements Types::Packages::FileMetadataType

        authorize :read_package

        field :channel, GraphQL::Types::String, null: false, description: 'Channel of the Helm chart.'
        field :metadata, Types::Packages::Helm::MetadataType, null: false, description: 'Metadata of the Helm chart.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/helm/maintainer_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Helm
      # rubocop: disable Graphql/AuthorizeTypes
      class MaintainerType < BaseObject
        graphql_name 'PackageHelmMaintainerType'
        description 'Represents a Helm maintainer'

        # Need to be synced with app/validators/json_schemas/helm_metadata.json#maintainers
        field :email, GraphQL::Types::String, null: true, description: 'Email of the maintainer.'
        field :name, GraphQL::Types::String, null: true, description: 'Name of the maintainer.'
        field :url, GraphQL::Types::String, null: true, description: 'URL of the maintainer.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/helm/metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Helm
      # rubocop: disable Graphql/AuthorizeTypes
      class MetadataType < BaseObject
        graphql_name 'PackageHelmMetadataType'
        description 'Represents the contents of a Helm Chart.yml file'

        # Need to be synced with app/validators/json_schemas/helm_metadata.json
        field :annotations, GraphQL::Types::JSON, null: true, description: 'Annotations for the chart.' # rubocop:disable Graphql/JSONType
        field :api_version,
          GraphQL::Types::String,
          null: false,
          description: 'API version of the chart.',
          hash_key: :apiVersion
        field :app_version,
          GraphQL::Types::String,
          null: true,
          description: 'App version of the chart.',
          hash_key: :appVersion
        field :condition, GraphQL::Types::String, null: true, description: 'Condition for the chart.'
        field :dependencies, [Types::Packages::Helm::DependencyType], null: true,
          description: 'Dependencies of the chart.'
        field :deprecated, GraphQL::Types::Boolean, null: true, description: 'Indicates if the chart is deprecated.'
        field :description, GraphQL::Types::String, null: true, description: 'Description of the chart.'
        field :home, GraphQL::Types::String, null: true, description: 'URL of the home page.'
        field :icon, GraphQL::Types::String, null: true, description: 'URL to an SVG or PNG image for the chart.'
        field :keywords, [GraphQL::Types::String], null: true, description: 'Keywords for the chart.'
        field :kube_version,
          GraphQL::Types::String,
          null: true,
          description: 'Kubernetes versions for the chart.',
          hash_key: :kubeVersion
        field :maintainers, [Types::Packages::Helm::MaintainerType], null: true,
          description: 'Maintainers of the chart.'
        field :name, GraphQL::Types::String, null: false, description: 'Name of the chart.'
        field :sources, [GraphQL::Types::String], null: true, description: 'URLs of the source code for the chart.'
        field :tags, GraphQL::Types::String, null: true, description: 'Tags for the chart.'
        field :type, GraphQL::Types::String, null: true, description: 'Type of the chart.', hash_key: :appVersion
        field :version, GraphQL::Types::String, null: false, description: 'Version of the chart.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/maven/metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Maven
      class MetadatumType < BaseObject
        graphql_name 'MavenMetadata'
        description 'Maven metadata'

        authorize :read_package

        field :app_group, GraphQL::Types::String, null: false, description: 'App group of the Maven package.'
        field :app_name, GraphQL::Types::String, null: false, description: 'App name of the Maven package.'
        field :app_version, GraphQL::Types::String, null: true, description: 'App version of the Maven package.'
        field :created_at, Types::TimeType, null: false, description: 'Date of creation.'
        field :id, ::Types::GlobalIDType[::Packages::Maven::Metadatum], null: false, description: 'ID of the metadatum.'
        field :path, GraphQL::Types::String, null: false, description: 'Path of the Maven package.'
        field :updated_at, Types::TimeType, null: false, description: 'Date of most recent update.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/metadata_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class MetadataType < BaseUnion
      graphql_name 'PackageMetadata'
      description 'Represents metadata associated with a Package'

      possible_types ::Types::Packages::Composer::MetadatumType,
        ::Types::Packages::Conan::MetadatumType,
        ::Types::Packages::Maven::MetadatumType,
        ::Types::Packages::Nuget::MetadatumType,
        ::Types::Packages::Pypi::MetadatumType,
        ::Types::Packages::TerraformModule::MetadatumType

      def self.resolve_type(object, context)
        case object
        when ::Packages::Composer::Metadatum
          ::Types::Packages::Composer::MetadatumType
        when ::Packages::Conan::Metadatum
          ::Types::Packages::Conan::MetadatumType
        when ::Packages::Maven::Metadatum
          ::Types::Packages::Maven::MetadatumType
        when ::Packages::Nuget::Metadatum
          ::Types::Packages::Nuget::MetadatumType
        when ::Packages::Pypi::Metadatum
          ::Types::Packages::Pypi::MetadatumType
        when ::Packages::TerraformModule::Metadatum
          ::Types::Packages::TerraformModule::MetadatumType
        else
          # NOTE: This method must be kept in sync with `PackageWithoutVersionsType#metadata`,
          # which must never produce data that this discriminator cannot handle.
          raise 'Unsupported metadata type'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/nuget/dependency_link_metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Nuget
      class DependencyLinkMetadatumType < BaseObject
        graphql_name 'NugetDependencyLinkMetadata'
        description 'Nuget dependency link metadata'

        authorize :read_package

        field :id, ::Types::GlobalIDType[::Packages::Nuget::DependencyLinkMetadatum], null: false,
          description: 'ID of the metadatum.'
        field :target_framework, GraphQL::Types::String, null: false,
          description: 'Target framework of the dependency link package.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/nuget/metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Nuget
      class MetadatumType < BaseObject
        graphql_name 'NugetMetadata'
        description 'Nuget metadata'

        authorize :read_package

        field :icon_url, GraphQL::Types::String, null: true, description: 'Icon URL of the Nuget package.'
        field :id, ::Types::GlobalIDType[::Packages::Nuget::Metadatum], null: false, description: 'ID of the metadatum.'
        field :license_url, GraphQL::Types::String, null: true, description: 'License URL of the Nuget package.'
        field :project_url, GraphQL::Types::String, null: true, description: 'Project URL of the Nuget package.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_base_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageBaseType < ::Types::BaseObject
      graphql_name 'PackageBase'
      description 'Represents a package in the package registry'

      PROTECTION_RULE_EXISTS_BATCH_SIZE = 20

      connection_type_class Types::CountableConnectionType

      authorize :read_package

      expose_permissions Types::PermissionTypes::Package

      field :id, ::Types::GlobalIDType[::Packages::Package], null: false, description: 'ID of the package.'

      field :_links, Types::Packages::PackageLinksType, null: false, method: :itself,
        description: 'Map of links to perform actions on the package.'
      field :created_at, Types::TimeType, null: false, description: 'Date of creation.'
      field :metadata, Types::Packages::MetadataType,
        null: true,
        description: 'Package metadata.'
      field :name, GraphQL::Types::String, null: false, description: 'Name of the package.'
      field :package_type, Types::Packages::PackageTypeEnum, null: false, description: 'Package type.'
      field :project, Types::ProjectType, null: false, description: 'Project where the package is stored.'
      field :protection_rule_exists, GraphQL::Types::Boolean,
        null: false,
        description: 'Whether any matching package protection rule exists for the package.'
      field :status, Types::Packages::PackageStatusEnum, null: false, description: 'Package status.'
      field :status_message, GraphQL::Types::String, null: true, description: 'Status message.'
      field :tags, Types::Packages::PackageTagType.connection_type, null: true, description: 'Package tags.'
      field :updated_at, Types::TimeType, null: false, description: 'Date of most recent update.'
      field :version, GraphQL::Types::String, null: true, description: 'Version string.'

      def project
        Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
      end

      def protection_rule_exists
        object_package_type_value = ::Packages::Package.package_types[object.package_type]

        BatchLoader::GraphQL.for([object.project_id, object.name, object_package_type_value]).batch do |tuples, loader|
          tuples.each_slice(PROTECTION_RULE_EXISTS_BATCH_SIZE) do |projects_and_packages|
            ::Packages::Protection::Rule
              .for_push_exists_for_projects_and_packages(projects_and_packages)
              .each do |row|
                loader.call([row['project_id'], row['package_name'], row['package_type']], row['protected'])
              end
          end
        end
      end

      # NOTE: This method must be kept in sync with the union
      # type: `Types::Packages::MetadataType`.
      #
      # `Types::Packages::MetadataType.resolve_type(metadata, ctx)` must never raise.
      # rubocop: disable GraphQL/ResolverMethodLength
      def metadata
        case object.package_type
        when 'composer'
          object.composer_metadatum
        when 'conan'
          object.conan_metadatum
        when 'maven'
          object.maven_metadatum
        when 'nuget'
          object.nuget_metadatum
        when 'pypi'
          object.pypi_metadatum
        when 'terraform_module'
          object.terraform_module_metadatum
        end
      end
      # rubocop: enable GraphQL/ResolverMethodLength
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_dependency_link_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageDependencyLinkType < BaseObject
      graphql_name 'PackageDependencyLink'
      description 'Represents a package dependency link'
      authorize :read_package

      field :dependency, Types::Packages::PackageDependencyType, null: true, description: 'Dependency.'
      field :dependency_type, Types::Packages::PackageDependencyTypeEnum, null: false, description: 'Dependency type.'
      field :id, ::Types::GlobalIDType[::Packages::DependencyLink], null: false,
        description: 'ID of the dependency link.'
      field :metadata, Types::Packages::DependencyLinkMetadataType, null: true, description: 'Dependency link metadata.'

      # NOTE: This method must be kept in sync with the union
      # type: `Types::Packages::DependencyLinkMetadata`.
      #
      # `Types::Packages::DependencyLinkMetadata.resolve_type(metadata, ctx)` must never raise.
      def metadata
        model_class = case object.package.package_type
                      when 'nuget'
                        ::Packages::Nuget::DependencyLinkMetadatum
                      end

        return unless model_class

        # rubocop: disable CodeReuse/ActiveRecord
        BatchLoader::GraphQL.for(object.id).batch do |ids, loader|
          results = model_class.where(dependency_link_id: ids)
          results.each { |record| loader.call(record.dependency_link_id, record) }
        end
        # rubocop: enable CodeReuse/ActiveRecord
      end

      def dependency
        ::Gitlab::Graphql::Loaders::BatchModelLoader.new(::Packages::Dependency, object.dependency_id).find
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_dependency_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageDependencyTypeEnum < BaseEnum
      graphql_name 'PackageDependencyType'

      ::Packages::DependencyLink.dependency_types.keys.each do |type|
        value type.to_s.underscore.upcase, description: "#{type} dependency type", value: type.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_dependency_type.rb =====
# frozen_string_literal: true

# this model does not have any kind of authorization so we disable it
# rubocop:disable Graphql/AuthorizeTypes

module Types
  module Packages
    class PackageDependencyType < BaseObject
      graphql_name 'PackageDependency'
      description 'Represents a package dependency.'

      field :id, ::Types::GlobalIDType[::Packages::Dependency], null: false, description: 'ID of the dependency.'
      field :name, GraphQL::Types::String, null: false, description: 'Name of the dependency.'
      field :version_pattern, GraphQL::Types::String, null: false, description: 'Version pattern of the dependency.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_details_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageDetailsType < PackageType
      graphql_name 'PackageDetailsType'
      description 'Represents a package details in the Package Registry'

      include ::PackagesHelper

      authorize :read_package

      field :versions, ::Types::Packages::PackageBaseType.connection_type, null: true,
        description: 'Other versions of the package.'

      field :package_files,
        Types::Packages::PackageFileType.connection_type,
        null: true,
        method: :installable_package_files,
        description: 'Package files.'

      field :dependency_links, Types::Packages::PackageDependencyLinkType.connection_type, null: true,
        description: 'Dependency link.'

      field :composer_config_repository_url, GraphQL::Types::String, null: true,
        description: 'Url of the Composer setup endpoint.'
      field :composer_url, GraphQL::Types::String, null: true, description: 'Url of the Composer endpoint.'
      field :conan_url, GraphQL::Types::String, null: true, description: 'Url of the Conan project endpoint.'
      field :maven_url, GraphQL::Types::String, null: true, description: 'Url of the Maven project endpoint.'
      field :npm_url, GraphQL::Types::String, null: true, description: 'Url of the NPM project endpoint.'
      field :nuget_url, GraphQL::Types::String, null: true, description: 'Url of the Nuget project endpoint.'
      field :pypi_setup_url, GraphQL::Types::String, null: true, description: 'Url of the PyPi project setup endpoint.'
      field :pypi_url, GraphQL::Types::String, null: true, description: 'Url of the PyPi project endpoint.'

      field :last_downloaded_at, Types::TimeType, null: true,
        description: 'Last time that a file of the package was downloaded.'

      field :public_package, GraphQL::Types::Boolean, null: true,
        description: 'Indicates if there is public access to the package.'

      def composer_config_repository_url
        composer_config_repository_name(object.project.group&.id)
      end

      def composer_url
        composer_registry_url(object.project.group&.id)
      end

      def conan_url
        package_registry_project_url(object.project.id, :conan)
      end

      def maven_url
        package_registry_project_url(object.project.id, :maven)
      end

      def npm_url
        package_registry_project_url(object.project.id, :npm)
      end

      def nuget_url
        nuget_package_registry_url(object.project.id)
      end

      def pypi_setup_url
        package_registry_project_url(object.project.id, :pypi)
      end

      def pypi_url
        pypi_registry_url(object.project)
      end

      def public_package
        object.project.project_feature.public_packages?
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_file_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageFileType < BaseObject
      graphql_name 'PackageFile'
      description 'Represents a package file'
      authorize :read_package

      field :created_at, Types::TimeType, null: false, description: 'Created date.'
      field :download_path, GraphQL::Types::String, null: false, description: 'Download path of the package file.'
      field :file_md5, GraphQL::Types::String, null: true, description: 'Md5 of the package file.'
      field :file_metadata, Types::Packages::FileMetadataType, null: true,
        description: 'File metadata.'
      field :file_name, GraphQL::Types::String, null: false, description: 'Name of the package file.'
      field :file_sha1, GraphQL::Types::String, null: true, description: 'Sha1 of the package file.'
      field :file_sha256, GraphQL::Types::String, null: true, description: 'Sha256 of the package file.'
      field :id, ::Types::GlobalIDType[::Packages::PackageFile], null: false, description: 'ID of the file.'
      field :size, GraphQL::Types::String, null: false, description: 'Size of the package file.'
      field :updated_at, Types::TimeType, null: false, description: 'Updated date.'

      # NOTE: This method must be kept in sync with the union
      # type: `Types::Packages::FileMetadataType`.
      #
      # `Types::Packages::FileMetadataType.resolve_type(metadata, ctx)` must never raise.
      def file_metadata
        case object.package.package_type
        when 'conan'
          object.conan_file_metadatum
        when 'helm'
          object.helm_file_metadatum
        end
      end

      def file_name
        URI.decode_uri_component(object.file_name)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_group_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageGroupSortEnum < PackageSortEnum
      graphql_name 'PackageGroupSort'
      description 'Values for sorting group packages'

      value 'PROJECT_PATH_DESC', 'Ordered by project path in descending order.', value: :project_path_desc
      value 'PROJECT_PATH_ASC', 'Ordered by project path in ascending order.', value: :project_path_asc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_links_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageLinksType < BaseObject
      graphql_name 'PackageLinks'
      description 'Represents links to perform actions on the package'
      authorize :read_package

      include ::Routing::PackagesHelper

      field :web_path, GraphQL::Types::String, null: true, description: 'Path to the package details page.'

      def web_path
        return unless object.detailed_info?

        package_path(object)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageSortEnum < BaseEnum
      graphql_name 'PackageSort'
      description 'Values for sorting package'

      value 'CREATED_DESC', 'Ordered by created_at in descending order.', value: :created_desc
      value 'CREATED_ASC', 'Ordered by created_at in ascending order.', value: :created_asc
      value 'NAME_DESC', 'Ordered by name in descending order.', value: :name_desc
      value 'NAME_ASC', 'Ordered by name in ascending order.', value: :name_asc
      value 'VERSION_DESC', 'Ordered by version in descending order.', value: :version_desc
      value 'VERSION_ASC', 'Ordered by version in ascending order.', value: :version_asc
      value 'TYPE_DESC', 'Ordered by type in descending order.', value: :type_desc
      value 'TYPE_ASC', 'Ordered by type in ascending order.', value: :type_asc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageStatusEnum < BaseEnum
      graphql_name 'PackageStatus'

      ::Packages::Package.statuses.keys.each do |status|
        value status.to_s.upcase, description: "Packages with a #{status} status", value: status.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_tag_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageTagType < BaseObject
      graphql_name 'PackageTag'
      description 'Represents a package tag'
      authorize :read_package

      field :created_at, Types::TimeType, null: false, description: 'Created date.'
      field :id, GraphQL::Types::ID, null: false, description: 'ID of the tag.'
      field :name, GraphQL::Types::String, null: false, description: 'Name of the tag.'
      field :updated_at, Types::TimeType, null: false, description: 'Updated date.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageTypeEnum < BaseEnum
      PACKAGE_TYPE_NAMES = {
        pypi: 'PyPI',
        npm: 'npm',
        terraform_module: 'Terraform Module'
      }.freeze

      ::Packages::Package.package_types.keys.each do |package_type|
        type_name = PACKAGE_TYPE_NAMES.fetch(package_type.to_sym, package_type.capitalize)
        value package_type.to_s.upcase,
          description: "Packages from the #{type_name} package manager",
          value: package_type.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/package_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    class PackageType < Types::Packages::PackageBaseType
      graphql_name 'Package'
      description 'Represents a package with pipelines in the package registry'

      authorize :read_package

      field :pipelines,
        resolver: Resolvers::PackagePipelinesResolver,
        connection_extension: Gitlab::Graphql::Extensions::ExternallyPaginatedArrayExtension,
        description: <<-DESC
              Pipelines that built the package. Max page size #{Resolvers::PackagePipelinesResolver::MAX_PAGE_SIZE}.
        DESC
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/protection/rule_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Protection
      class RuleAccessLevelEnum < BaseEnum
        graphql_name 'PackagesProtectionRuleAccessLevel'
        description 'Access level of a package protection rule resource'

        ::Packages::Protection::Rule.minimum_access_level_for_pushes.each_key do |access_level_key|
          value access_level_key.upcase,
            value: access_level_key.to_s,
            description: "#{access_level_key.capitalize} access."
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/protection/rule_access_level_for_delete_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Protection
      class RuleAccessLevelForDeleteEnum < BaseEnum
        graphql_name 'PackagesProtectionRuleAccessLevelForDelete'
        description 'Access level for the deletion of a package protection rule resource.'

        ::Packages::Protection::Rule.minimum_access_level_for_deletes.each_key do |access_level_key|
          value access_level_key.upcase,
            value: access_level_key.to_s,
            description: "#{access_level_key.capitalize} access. " \
              'Available only when feature flag `packages_protected_packages_delete` is enabled.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/protection/rule_package_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Protection
      class RulePackageTypeEnum < BaseEnum
        graphql_name 'PackagesProtectionRulePackageType'
        description 'Package type of a package protection rule resource'

        value 'CONAN',
          value: 'conan',
          description: 'Packages of the Conan format.'

        value 'HELM',
          value: 'helm',
          description: 'Packages of the Helm format.'

        value 'GENERIC',
          value: 'generic',
          description: 'Packages of the Generic format.'

        value 'MAVEN',
          value: 'maven',
          description: 'Packages of the Maven format.'

        value 'NPM',
          value: 'npm',
          description: 'Packages of the npm format.'

        value 'NUGET',
          value: 'nuget',
          description: 'Packages of the NuGet format.'

        value 'PYPI',
          value: 'pypi',
          description: 'Packages of the PyPI format.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/protection/rule_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Protection
      class RuleType < ::Types::BaseObject
        graphql_name 'PackagesProtectionRule'
        description 'A packages protection rule designed to protect packages ' \
          'from being pushed by users with a certain access level.'

        authorize :admin_package

        field :id,
          ::Types::GlobalIDType[::Packages::Protection::Rule],
          null: false,
          description: 'Global ID of the package protection rule.'

        field :package_name_pattern,
          GraphQL::Types::String,
          null: false,
          description:
            'Package name protected by the protection rule. For example, `@my-scope/my-package-*`. ' \
            'Wildcard character `*` allowed.'

        field :package_type,
          Types::Packages::Protection::RulePackageTypeEnum,
          null: false,
          description: 'Package type protected by the protection rule. For example, `NPM`, `PYPI`.'

        field :minimum_access_level_for_delete,
          Types::Packages::Protection::RuleAccessLevelForDeleteEnum,
          null: true,
          experiment: { milestone: '17.10' },
          description:
            'Minimum GitLab access required to delete packages from the package registry. ' \
            'Valid values include `OWNER` or `ADMIN`. ' \
            'If the value is `nil`, the default minimum access level is `MAINTAINER`. ' \
            'Available only when feature flag `packages_protected_packages_delete` is enabled.'

        field :minimum_access_level_for_push,
          Types::Packages::Protection::RuleAccessLevelEnum,
          null: true,
          description:
            'Minimum GitLab access required to push packages to the package registry. ' \
            'Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. ' \
            'If the value is `nil`, the default minimum access level is `DEVELOPER`.'

        def minimum_access_level_for_delete
          return unless Feature.enabled?(:packages_protected_packages_delete, object&.project)

          object.minimum_access_level_for_delete
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/pypi/metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module Pypi
      class MetadatumType < BaseObject
        graphql_name 'PypiMetadata'
        description 'Pypi metadata'

        authorize :read_package

        field :author_email, GraphQL::Types::String, null: true,
          description: 'Author email address(es) in RFC-822 format.'
        field :description, GraphQL::Types::String, null: true,
          description: 'Longer description that can run to several paragraphs.'
        field :description_content_type, GraphQL::Types::String, null: true,
          description: 'Markup syntax used in the description field.'
        field :id, ::Types::GlobalIDType[::Packages::Pypi::Metadatum], null: false, description: 'ID of the metadatum.'
        field :keywords, GraphQL::Types::String, null: true, description: 'List of keywords, separated by commas.'
        field :metadata_version, GraphQL::Types::String, null: true, description: 'Metadata version.'
        field :required_python, GraphQL::Types::String, null: true,
          description: 'Required Python version of the Pypi package.'
        field :summary, GraphQL::Types::String, null: true, description: 'One-line summary of the description.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/dependencies_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class DependenciesType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Already authorized in parent
          graphql_name 'TerraformModuleMetadataDependencies'
          description 'Terraform module metadata dependencies'

          field :modules, [Types::Packages::TerraformModule::Metadatum::DependencyType], null: true,
            description: 'Modules of the module.'
          field :providers, [Types::Packages::TerraformModule::Metadatum::DependencyType], null: true,
            description: 'Providers of the module.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/dependency_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class DependencyType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Already authorized in parent
          graphql_name 'TerraformModuleMetadataDependency'
          description 'Terraform module metadata dependency'

          field :name, GraphQL::Types::String, null: false, description: 'Name of the dependency.'
          field :source, GraphQL::Types::String, null: true, description: 'Source of the dependency.'
          field :version, GraphQL::Types::String, null: true, description: 'Version of the dependency.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/example_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class ExampleType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Already authorized in parent MetadatumType
          graphql_name 'TerraformModuleMetadataExample'
          description 'Terraform module metadata example'

          implements SharedFieldsInterface

          field :name, GraphQL::Types::String, null: false, description: 'Name of the example.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/fields_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class FieldsType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- This type is used for package metadata
          graphql_name 'TerraformModuleMetadataFields'
          description 'Terraform module metadata fields type'

          field :examples, [Types::Packages::TerraformModule::Metadatum::ExampleType], null: true,
            description: 'Examples of the module.'
          field :root, Types::Packages::TerraformModule::Metadatum::RootType, null: false,
            description: 'Root module.'
          field :submodules, [Types::Packages::TerraformModule::Metadatum::SubmoduleType], null: true,
            description: 'Submodules of the module.'

          def submodules
            hash_to_arr(object['submodules'])
          end

          def examples
            hash_to_arr(object['examples'])
          end

          private

          def hash_to_arr(hash)
            return unless hash

            hash.map { |name, details| { name: name }.merge(details) }
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/input_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        # This is not a GraphQL input type, but a terraform module input variables type: https://developer.hashicorp.com/terraform/language/values/variables
        class InputType < BaseObject
          graphql_name 'TerraformModuleMetadataInput'
          description 'Terraform module metadata input type'

          field :default, GraphQL::Types::String, null: true, description: 'Default value of the input.'
          field :description, GraphQL::Types::String, null: true, description: 'Description of the input.'
          field :name, GraphQL::Types::String, null: false, description: 'Name of the input.'
          field :type, GraphQL::Types::String, null: false, description: 'Type of the input.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/output_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class OutputType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Already authorized in parent MetadatumType
          graphql_name 'TerraformModuleMetadataOutput'
          description 'Terraform module metadata output'

          field :description, GraphQL::Types::String, null: true, description: 'Description of the output field.'
          field :name, GraphQL::Types::String, null: false, description: 'Name of the output field.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/root_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class RootType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Already authorized in parent MetadatumType
          graphql_name 'TerraformModuleMetadataRoot'
          description 'Metadata for Terraform root module'

          implements SharedFieldsInterface

          field :dependencies, Types::Packages::TerraformModule::Metadatum::DependenciesType, null: true,
            description: 'Dependencies of the module.'
          field :resources, [GraphQL::Types::String], null: true, description: 'Resources of the module.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/shared_fields_interface.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        module SharedFieldsInterface
          include ::Types::BaseInterface
          prepend Gitlab::Graphql::MarkdownField

          graphql_name 'TerraformModuleMetadataSharedFields'

          field :inputs, [Types::Packages::TerraformModule::Metadatum::InputType], null: true,
            description: 'Inputs of the module.'
          field :outputs, [Types::Packages::TerraformModule::Metadatum::OutputType], null: true,
            description: 'Outputs of the module.'
          field :readme, GraphQL::Types::String, null: true, description: 'Readme data.'

          markdown_field :readme_html, null: true

          def readme_html_resolver
            ::MarkupHelper.markdown(object['readme'], context.to_h.dup)
          end
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum/submodule_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      module Metadatum
        class SubmoduleType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- Already authorized in parent MetadatumType
          graphql_name 'TerraformModuleMetadataSubmodule'
          description 'Terraform module metadata submodule'

          implements SharedFieldsInterface

          field :dependencies, Types::Packages::TerraformModule::Metadatum::DependenciesType, null: true,
            description: 'Dependencies of the submodule.'
          field :name, GraphQL::Types::String, null: false, description: 'Name of the submodule.'
          field :resources, [GraphQL::Types::String], null: true, description: 'Resources of the submodule.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/packages/terraform_module/metadatum_type.rb =====
# frozen_string_literal: true

module Types
  module Packages
    module TerraformModule
      class MetadatumType < BaseObject
        graphql_name 'TerraformModuleMetadata'
        description 'Terraform module metadata'

        authorize :read_package

        field :created_at, Types::TimeType, null: false, description: 'Timestamp of when the metadata was created.'
        field :fields, Types::Packages::TerraformModule::Metadatum::FieldsType, null: false,
          description: 'Fields of the metadata.'
        field :id, ::Types::GlobalIDType[::Packages::TerraformModule::Metadatum], null: false,
          description: 'ID of the metadata.'
        field :updated_at, Types::TimeType, null: false,
          description: 'Timestamp of when the metadata was last updated.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/pages_deployment_type.rb =====
# frozen_string_literal: true

module Types
  class PagesDeploymentType < BaseObject
    graphql_name 'PagesDeployment'
    description 'Represents a pages deployment.'

    connection_type_class Types::CountableConnectionType
    authorize :read_pages_deployments

    field :active, GraphQL::Types::Boolean, null: false,
      description: 'Whether the deployment is currently active.', method: :active?
    field :ci_build_id, GraphQL::Types::ID, null: true,
      description: 'ID of the CI build that created the deployment.'
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false,
      description: 'Time the deployment was created.'
    field :deleted_at, GraphQL::Types::ISO8601DateTime, null: true,
      description: 'Time the deployment was deleted.'
    field :expires_at, GraphQL::Types::ISO8601DateTime, null: true,
      description: 'Time the deployment will expire.'
    field :file_count, GraphQL::Types::Int, null: true,
      description: 'Number of files that were published with the deployment.'
    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the Pages Deployment.'
    field :path_prefix, GraphQL::Types::String, null: true,
      description: 'URL path Prefix that points to the deployment.'
    field :project, Types::ProjectType, null: false,
      description: 'Project the deployment belongs to.'
    field :root_directory, GraphQL::Types::String, null: true,
      description: 'Path within the build assets that functions as the root directory for Pages sites.'
    field :size, GraphQL::Types::Int, null: true,
      description: 'Size of the storage used.'
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false,
      description: 'Time the deployment was last updated.'
    field :url, GraphQL::Types::String, null: false,
      description: 'Publicly accessible URL of the deployment.'

    def project
      ::Project.find(object.project_id)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/base_permission_type.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class BasePermissionType < BaseObject
      extend Gitlab::Allowable

      RESOLVING_KEYWORDS = [:resolver, :method, :hash_key, :function].to_set.freeze

      def self.abilities(*abilities)
        abilities.each { |ability| ability_field(ability) }
      end

      def self.ability_field(ability, **kword_args, &block)
        define_field_resolver_method(ability) unless resolving_keywords?(kword_args)

        permission_field(ability, **kword_args, &block)
      end

      def self.permission_field(name, **kword_args, &block)
        kword_args = kword_args.reverse_merge(
          name: name,
          type: GraphQL::Types::Boolean,
          description: "If `true`, the user can perform `#{name}` on this resource",
          null: false)

        field(**kword_args, &block) # rubocop:disable Graphql/Descriptions
      end

      def self.define_field_resolver_method(ability)
        unless respond_to?(ability)
          define_method ability.to_sym do |*args|
            Ability.allowed?(context[:current_user], ability, object, **args.to_h)
          end
        end
      end

      def self.resolving_keywords?(arguments)
        RESOLVING_KEYWORDS.intersect?(arguments.keys.to_set)
      end
      private_class_method :resolving_keywords?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/ci/job.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Ci
      class Job < BasePermissionType
        graphql_name 'JobPermissions'

        abilities :read_job_artifacts, :read_build
        ability_field :update_build, calls_gitaly: true
        ability_field :cancel_build, calls_gitaly: true
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/ci/pipeline.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Ci
      class Pipeline < BasePermissionType
        graphql_name 'PipelinePermissions'

        abilities :admin_pipeline, :destroy_pipeline
        ability_field :update_pipeline, calls_gitaly: true
        ability_field :cancel_pipeline, calls_gitaly: true
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/ci/pipeline_schedules.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Ci
      class PipelineSchedules < BasePermissionType
        graphql_name 'PipelineSchedulePermissions'

        abilities :update_pipeline_schedule,
          :admin_pipeline_schedule

        ability_field :play_pipeline_schedule, calls_gitaly: true
        ability_field :take_ownership_pipeline_schedule,
          deprecated: {
            reason: 'Use admin_pipeline_schedule permission to determine if the user can take ownership ' \
              'of a pipeline schedule',
            milestone: '15.9'
          }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/ci/runner.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Ci
      class Runner < BasePermissionType
        graphql_name 'RunnerPermissions'

        abilities :read_runner, :update_runner, :delete_runner, :assign_runner
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/container_registry/protection/tag_rule.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module ContainerRegistry
      module Protection
        class TagRule < BasePermissionType
          graphql_name 'ContainerRegistryProtectionTagRulePermissions'

          ability_field :destroy_container_registry_protection_tag_rule
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/container_repository.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class ContainerRepository < BasePermissionType
      graphql_name 'ContainerRepositoryPermissions'

      ability_field :destroy_container_image,
        name: 'destroy_container_repository',
        resolver_method: :destroy_container_image
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/container_repository_tag.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class ContainerRepositoryTag < BasePermissionType
      graphql_name 'ContainerRepositoryTagPermissions'

      ability_field :destroy_container_image_tag,
        name: 'destroy_container_repository_tag',
        resolver_method: :destroy_container_image_tag
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/custom_emoji.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class CustomEmoji < BasePermissionType
      graphql_name 'CustomEmojiPermissions'

      abilities :create_custom_emoji, :read_custom_emoji, :delete_custom_emoji
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/deployment.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Deployment < BasePermissionType
      graphql_name 'DeploymentPermissions'

      abilities :destroy_deployment
      ability_field :update_deployment, calls_gitaly: true
    end
  end
end

Types::PermissionTypes::Deployment.prepend_mod_with('Types::PermissionTypes::Deployment')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/environment.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Environment < BasePermissionType
      graphql_name 'EnvironmentPermissions'

      abilities :update_environment, :destroy_environment, :stop_environment
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/group_enum.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class GroupEnum < BaseEnum
      graphql_name 'GroupPermission'
      description 'User permission on groups'

      value 'CREATE_PROJECTS', value: :create_projects, description: 'Groups where the user can create projects.'
      value 'TRANSFER_PROJECTS',
        value: :transfer_projects,
        description: 'Groups where the user can transfer projects to.'
      value 'IMPORT_PROJECTS',
        value: :import_projects,
        description: 'Groups where the user can import projects to.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/group.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Group < BasePermissionType
      graphql_name 'GroupPermissions'

      abilities(
        :read_group,
        :create_projects,
        :create_custom_emoji,
        :remove_group,
        :view_edit_page,
        :admin_issue,
        :read_crm_contact,
        :read_crm_organization
      )

      ability_field :archive_group,
        experiment: { milestone: '18.3' }

      permission_field :can_leave,
        description: 'If `true`, the user can leave this group.'

      permission_field :admin_all_resources,
        description: 'If `true`, the user is an instance administrator.'

      def can_leave
        return false unless current_user

        current_user.can_leave_group?(object)
      end

      def admin_all_resources
        return false unless current_user

        current_user.can_admin_all_resources?
      end
    end
  end
end

::Types::PermissionTypes::Group.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/issue.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Issue < BasePermissionType
      graphql_name 'IssuePermissions'
      description 'Check permissions for the current user on a issue'

      abilities :read_issue, :admin_issue, :update_issue, :reopen_issue,
        :read_design, :create_design, :destroy_design,
        :create_note, :update_design, :move_design, :move_issue, :clone_issue,
        :admin_issue_relation
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/members/group_member.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Members
      class GroupMember < BasePermissionType
        graphql_name 'GroupMemberPermissions'

        abilities :read_group, :create_projects, :create_custom_emoji, :remove_group, :view_edit_page
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/merge_request.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class MergeRequest < BasePermissionType
      graphql_name 'MergeRequestPermissions'
      description 'Check permissions for the current user on a merge request'

      present_using MergeRequestPresenter

      PERMISSION_FIELDS = %i[push_to_source_branch
        remove_source_branch
        cherry_pick_on_current_merge_request
        revert_on_current_merge_request].freeze

      abilities :read_merge_request, :admin_merge_request,
        :update_merge_request, :create_note

      PERMISSION_FIELDS.each do |field_name|
        permission_field field_name, method: :"can_#{field_name}?", calls_gitaly: true
      end

      permission_field :can_merge, calls_gitaly: true
      permission_field :can_approve, calls_gitaly: true

      def can_merge
        object.can_be_merged_by?(context[:current_user])
      end

      def can_approve
        object.eligible_for_approval_by?(context[:current_user])
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/namespaces/base.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Namespaces
      class Base < BasePermissionType
        graphql_name 'NamespacePermissions'

        abilities :admin_label, :admin_issue, :create_work_item,
          :import_issues, :read_crm_contact, :read_crm_organization, :create_projects

        ability_field :read_namespace

        ability_field :set_new_work_item_metadata,
          description: 'If `true`, the user can set work item metadata for new work items.'
      end
    end
  end
end

::Types::PermissionTypes::Namespaces::Base.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/note.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Note < BasePermissionType
      graphql_name 'NotePermissions'

      abilities :read_note, :create_note, :admin_note, :resolve_note, :reposition_note, :award_emoji
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/notes/discussion.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Notes
      class Discussion < BasePermissionType
        graphql_name 'DiscussionPermissions'

        permission_field :resolve_note

        def resolve_note
          object.can_resolve_discussion?(context[:current_user])
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/organization_user.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class OrganizationUser < BasePermissionType
      graphql_name 'OrganizationUserPermissions'

      abilities :remove_user, :delete_user, :admin_organization
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/package.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Package < BasePermissionType
      graphql_name 'PackagePermissions'

      ability_field :destroy_package,
        description: 'If `true`, the user can perform `destroy_package` on this resource'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/project.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Project < BasePermissionType
      graphql_name 'ProjectPermissions'

      abilities :change_namespace, :change_visibility_level, :rename_project,
        :remove_project, :archive_project, :remove_fork_project,
        :remove_pages, :read_project, :create_merge_request_in,
        :read_wiki, :read_project_member, :create_issue, :upload_file,
        :read_cycle_analytics, :download_code, :download_wiki_code,
        :fork_project, :read_commit_status,
        :request_access, :create_pipeline, :create_pipeline_schedule,
        :create_merge_request_from, :create_wiki, :push_code,
        :create_deployment, :push_to_delete_protected_branch,
        :admin_wiki, :admin_project, :update_pages,
        :admin_remote_mirror, :create_label, :update_wiki, :destroy_wiki,
        :create_pages, :destroy_pages, :read_pages_content, :admin_operations,
        :read_merge_request, :read_design, :create_design, :update_design, :destroy_design,
        :move_design, :read_environment, :view_edit_page, :admin_issue, :create_work_item,
        :import_issues, :read_crm_contact, :read_crm_organization

      permission_field :create_snippet
      permission_field :admin_all_resources,
        description: 'If `true`, the user is an instance administrator.'

      def create_snippet
        Ability.allowed?(context[:current_user], :create_snippet, object)
      end

      def admin_all_resources
        return false unless current_user

        current_user.can_admin_all_resources?
      end
    end
  end
end

::Types::PermissionTypes::Project.prepend_mod_with('Types::PermissionTypes::Project')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/snippet.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Snippet < BasePermissionType
      graphql_name 'SnippetPermissions'

      abilities :create_note, :award_emoji

      permission_field :read_snippet, method: :can_read_snippet?
      permission_field :update_snippet, method: :can_update_snippet?
      permission_field :admin_snippet, method: :can_admin_snippet?
      permission_field :report_snippet, method: :can_report_as_spam?
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/timelog.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class Timelog < BasePermissionType
      graphql_name 'TimelogPermissions'

      abilities :admin_timelog
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/user.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class User < BasePermissionType
      graphql_name 'UserPermissions'

      permission_field :create_snippet

      def create_snippet
        Ability.allowed?(context[:current_user], :create_snippet)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/wikis/wiki_page.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    module Wikis
      class WikiPage < BasePermissionType
        graphql_name 'WikiPagePermissions'

        abilities :read_wiki_page, :create_note, :mark_note_as_internal
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/permission_types/work_item.rb =====
# frozen_string_literal: true

module Types
  module PermissionTypes
    class WorkItem < BasePermissionType
      graphql_name 'WorkItemPermissions'
      description 'Check permissions for the current user on a work item'

      abilities :read_work_item, :update_work_item, :delete_work_item,
        :admin_work_item, :admin_parent_link, :set_work_item_metadata,
        :create_note, :admin_work_item_link, :mark_note_as_internal,
        :report_spam, :move_work_item, :clone_work_item, :summarize_comments
    end
  end
end

::Types::PermissionTypes::WorkItem.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_feature_access_level_enum.rb =====
# frozen_string_literal: true

module Types
  class ProjectFeatureAccessLevelEnum < BaseEnum
    graphql_name 'ProjectFeatureAccessLevel'
    description 'Access level of a project feature'

    value 'DISABLED', value: ProjectFeature::DISABLED, description: 'Not enabled for anyone.'
    value 'PRIVATE', value: ProjectFeature::PRIVATE, description: 'Enabled only for team members.'
    value 'ENABLED', value: ProjectFeature::ENABLED, description: 'Enabled for everyone able to access the project.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_feature_access_level_type.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/AuthorizeTypes -- It just returns the value of an enum as an integer and a string
module Types
  class ProjectFeatureAccessLevelType < Types::BaseObject
    graphql_name 'ProjectFeatureAccess'
    description 'Represents the access level required by the user to access a project feature'

    field :integer_value, GraphQL::Types::Int, null: true,
      description: 'Integer representation of access level.',
      method: :to_i

    field :string_value, Types::ProjectFeatureAccessLevelEnum, null: true,
      description: 'String representation of access level.',
      method: :to_i
  end
end
# rubocop:enable Graphql/AuthorizeTypes


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_invitation_type.rb =====
# frozen_string_literal: true

module Types
  class ProjectInvitationType < BaseObject
    graphql_name 'ProjectInvitation'
    description 'Represents a Project Membership Invitation'

    expose_permissions Types::PermissionTypes::Project

    implements InvitationInterface

    authorize :admin_project

    field :project, Types::ProjectType, null: true,
      description: 'Project ID for the project of the invitation.'

    def project
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.source_id).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_member_relation_enum.rb =====
# frozen_string_literal: true

module Types
  class ProjectMemberRelationEnum < BaseEnum
    graphql_name 'ProjectMemberRelation'
    description 'Project member relation'

    ::MembersFinder::RELATIONS.each do |member_relation|
      value member_relation.to_s.upcase, value: member_relation, description: "#{member_relation.to_s.titleize} members"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_member_type.rb =====
# frozen_string_literal: true

module Types
  class ProjectMemberType < BaseObject
    graphql_name 'ProjectMember'
    description 'Represents a Project Membership'

    expose_permissions Types::PermissionTypes::Project

    implements MemberInterface

    authorize :read_project

    field :project, Types::ProjectType, null: true,
      description: 'Project that User is a member of.'

    def project
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.source_id).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_plan_limits_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes -- The resolver authorizes the request
  class ProjectPlanLimitsType < BaseObject
    graphql_name 'ProjectPlanLimits'
    description 'Plan limits for the current project.'

    field :ci_pipeline_schedules, GraphQL::Types::Int, null: true,
      description: 'Maximum number of pipeline schedules allowed per project.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/archived_enum.rb =====
# frozen_string_literal: true

module Types
  module Projects
    class ArchivedEnum < BaseEnum
      graphql_name 'ProjectArchived'
      description 'Values for the archived argument'

      value 'ONLY', 'Only archived projects.', value: 'only'
      value 'INCLUDE', 'Include archived projects.', value: true
      value 'EXCLUDE', 'Exclude archived projects.', value: false
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/branch_rules/squash_option_setting_enum.rb =====
# frozen_string_literal: true

module Types
  module Projects
    module BranchRules
      class SquashOptionSettingEnum < ::Types::BaseEnum
        graphql_name 'SquashOptionSetting'
        description 'Options for default squash behaviour for merge requests'

        value 'NEVER', description: 'Do not allow.', value: 0
        value 'ALLOWED', description: 'Allow.', value: 3
        value 'ENCOURAGED', description: 'Encourage.', value: 2
        value 'ALWAYS', description: 'Require.', value: 1
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/branch_rules/squash_option_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    module BranchRules
      class SquashOptionType < Types::BaseObject
        graphql_name 'SquashOption'
        description 'Squash option overrides for a protected branch'
        accepts ::Projects::SquashOption
        authorize :read_squash_option
        present_using ::Projects::BranchRules::SquashOptionPresenter

        field :option,
          GraphQL::Types::String,
          null: false,
          description: 'Human-readable description of the squash option.',
          method: :human_squash_option

        field :help_text,
          GraphQL::Types::String,
          null: false,
          description: 'Help text for the squash option.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/branch_rule_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    class BranchRuleType < BaseObject
      graphql_name 'BranchRule'
      description 'Branch rules configured for a rule target.'
      authorize :read_protected_branch

      alias_method :branch_rule, :object

      field :id, ::Types::GlobalIDType[::Projects::BranchRule],
        description: 'ID of the branch rule.'

      field :name,
        type: GraphQL::Types::String,
        null: false,
        description: 'Name of the branch rule target. Includes wildcards.'

      field :is_default,
        type: GraphQL::Types::Boolean,
        null: false,
        method: :default_branch?,
        calls_gitaly: true,
        description: "Check if the branch rule protects the project's default branch."

      field :is_protected,
        type: GraphQL::Types::Boolean,
        null: false,
        method: :protected?,
        description: "Check if the branch rule protects access for the branch."

      field :matching_branches_count,
        type: GraphQL::Types::Int,
        null: false,
        calls_gitaly: true,
        description: 'Number of existing branches that match the branch rule.'

      field :branch_protection,
        type: Types::BranchRules::BranchProtectionType,
        null: true,
        description: 'Branch protections configured for the branch rule.'

      field :created_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp of when the branch rule was created.'

      field :squash_option,
        type: ::Types::Projects::BranchRules::SquashOptionType,
        null: true,
        description: 'Default behavior for squashing in merge requests. ',
        experiment: { milestone: '17.9' }
      field :updated_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp of when the branch rule was last updated.'

      def squash_option
        branch_rule.squash_option
      end
    end
  end
end

Types::Projects::BranchRuleType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/commit_parent_names_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # rubocop: disable Graphql/AuthorizeTypes
    class CommitParentNamesType < BaseObject
      graphql_name 'CommitParentNames'

      field :names, [GraphQL::Types::String], null: true, description: 'Names of the commit parent (branch or tag).'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/detailed_import_status_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    class DetailedImportStatusType < BaseObject
      graphql_name 'DetailedImportStatus'
      description 'Details of the import status of a project.'

      authorize :read_project

      field :id, ::Types::GlobalIDType[::ProjectImportState],
        description: 'ID of the import state.'

      field :status, GraphQL::Types::String,
        description: 'Current status of the import.'

      field :url, GraphQL::Types::String,
        description: 'Import url.'

      field :last_error, GraphQL::Types::String,
        description: 'Last error of the import.',
        null: true,
        authorize: :read_import_error

      field :last_update_at, Types::TimeType,
        description: 'Time of the last update.'

      field :last_update_started_at, Types::TimeType,
        description: 'Time of the start of the last update.'

      field :last_successful_update_at, Types::TimeType,
        description: 'Time of the last successful update.'

      def url
        object.project.safe_import_url
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/fork_details_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # rubocop: disable Graphql/AuthorizeTypes
    class ForkDetailsType < BaseObject
      graphql_name 'ForkDetails'
      description 'Details of the fork project compared to its upstream project.'

      field :ahead, GraphQL::Types::Int,
        null: true,
        calls_gitaly: true,
        description: 'Number of commits ahead of upstream.'

      field :behind, GraphQL::Types::Int,
        null: true,
        calls_gitaly: true,
        description: 'Number of commits behind upstream.'

      field :is_syncing, GraphQL::Types::Boolean,
        null: true,
        method: :syncing?,
        description: 'Indicates if there is a synchronization in progress.'

      field :has_conflicts, GraphQL::Types::Boolean,
        null: true,
        method: :has_conflicts?,
        description: 'Indicates if the fork conflicts with its upstream project.'

      def ahead
        counts[:ahead]
      end

      def behind
        counts[:behind]
      end

      def counts
        @counts ||= object.counts
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/namespace_project_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Projects
    class NamespaceProjectSortEnum < BaseEnum
      graphql_name 'NamespaceProjectSort'
      description 'Values for sorting projects'

      value 'SIMILARITY', 'Most similar to the search query.', value: :similarity
      value 'ACTIVITY_DESC', 'Sort by latest activity, descending order.', value: :latest_activity_desc
      value 'STORAGE_SIZE_ASC',  'Sort by total storage size, ascending order.', value: :storage_size_asc
      value 'STORAGE_SIZE_DESC', 'Sort by total storage size, descending order.', value: :storage_size_desc

      value 'PATH_ASC', 'Sort by path, ascending order.', value: :path_asc
      value 'PATH_DESC', 'Sort by path, descending order.', value: :path_desc

      value 'FULL_PATH_ASC', 'Sort by full path, ascending order.', value: :full_path_asc
      value 'FULL_PATH_DESC', 'Sort by full path, descending order.', value: :full_path_desc

      value 'REPOSITORY_SIZE_ASC',  'Sort by total repository size, ascending order.', value: :repository_size_asc
      value 'REPOSITORY_SIZE_DESC', 'Sort by total repository size, descending order.', value: :repository_size_desc

      value 'SNIPPETS_SIZE_ASC',  'Sort by total snippet size, ascending order.', value: :snippets_size_asc
      value 'SNIPPETS_SIZE_DESC', 'Sort by total snippet size, descending order.', value: :snippets_size_desc

      value 'BUILD_ARTIFACTS_SIZE_ASC',  'Sort by total build artifact size, ascending order.',
        value: :build_artifacts_size_asc
      value 'BUILD_ARTIFACTS_SIZE_DESC', 'Sort by total build artifact size, descending order.',
        value: :build_artifacts_size_desc

      value 'LFS_OBJECTS_SIZE_ASC',  'Sort by total LFS object size, ascending order.', value: :lfs_objects_size_asc
      value 'LFS_OBJECTS_SIZE_DESC', 'Sort by total LFS object size, descending order.', value: :lfs_objects_size_desc

      value 'PACKAGES_SIZE_ASC',  'Sort by total package size, ascending order.', value: :packages_size_asc
      value 'PACKAGES_SIZE_DESC', 'Sort by total package size, descending order.', value: :packages_size_desc

      value 'WIKI_SIZE_ASC',  'Sort by total wiki size, ascending order.', value: :wiki_size_asc
      value 'WIKI_SIZE_DESC', 'Sort by total wiki size, descending order.', value: :wiki_size_desc

      value 'CONTAINER_REGISTRY_SIZE_ASC',  'Sort by total container registry size, ascending order.',
        value: :container_registry_size_asc
      value 'CONTAINER_REGISTRY_SIZE_DESC', 'Sort by total container registry size, descending order.',
        value: :container_registry_size_desc
    end
  end
end

Types::Projects::NamespaceProjectSortEnum.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/project_base_field.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # rubocop: disable GraphQL/GraphqlName -- Not a type
    # rubocop: disable Graphql/AuthorizeTypes -- Not a type
    class ProjectBaseField < ::Types::BaseField
      def initialize(**kwargs, &block)
        kwargs[:authorize] = :read_project

        super
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
    # rubocop: enable GraphQL/GraphqlName
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/project_interface.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # This interface sets [authorize: :read_project] (field-level authorization via
    # ProjectBaseField) for all defined fields to ensure implementing types don't
    # expose inherited fields without proper authorization.
    #
    # Implementing types can opt-out from this field-level auth and use
    # type-level auth by re-defining the field without the authorize argument.
    # For example, ProjectType uses :read_project type-level auth and redefines all
    # fields in this interface to opt-out while ProjectMinimalAccessType uses
    # :read_project_metadata type-level auth to expose a set of defined fields and
    # leaves inherited fields it does not want to expose to use field-level auth
    # using :read_project.
    module ProjectInterface
      include BaseInterface

      connection_type_class Types::CountableConnectionType

      graphql_name 'ProjectInterface'

      field_class ::Types::Projects::ProjectBaseField

      field :avatar_url, GraphQL::Types::String,
        null: true,
        calls_gitaly: true,
        description: 'Avatar URL of the project.'
      field :description, GraphQL::Types::String,
        null: true,
        description: 'Short description of the project.'
      field :full_path, GraphQL::Types::ID,
        null: true,
        description: 'Full path of the project.'
      field :id, GraphQL::Types::ID, null: true,
        description: 'ID of the project.'
      field :name, GraphQL::Types::String,
        null: true,
        description: 'Name of the project without the namespace.'
      field :name_with_namespace, GraphQL::Types::String,
        null: true,
        description: 'Name of the project including the namespace.'
      field :web_url, GraphQL::Types::String,
        null: true,
        description: 'Web URL of the project.'

      def self.resolve_type(_object, _context)
        ::Types::ProjectType
      end

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
  end
end

Types::Projects::ProjectInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/project_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module Projects
    class ProjectSortEnum < SortEnum
      graphql_name 'ProjectSort'
      description 'Values for sorting projects'

      value 'ID_ASC', 'ID by ascending order.', value: :id_asc
      value 'ID_DESC', 'ID by descending order.', value: :id_desc
      value 'LATEST_ACTIVITY_ASC', 'Latest activity by ascending order.', value: :latest_activity_asc
      value 'LATEST_ACTIVITY_DESC', 'Latest activity by descending order.', value: :latest_activity_desc
      value 'NAME_ASC', 'Name by ascending order.', value: :name_asc
      value 'NAME_DESC', 'Name by descending order.', value: :name_desc
      value 'PATH_ASC', 'Path by ascending order.', value: :path_asc
      value 'PATH_DESC', 'Path by descending order.', value: :path_desc
      value 'STARS_ASC', 'Stars by ascending order.', value: :stars_asc
      value 'STARS_DESC', 'Stars by descending order.', value: :stars_desc
      value 'STORAGE_SIZE_ASC', 'Storage size by ascending order.', value: :storage_size_asc
      value 'STORAGE_SIZE_DESC', 'Storage size by descending order.', value: :storage_size_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/repository_language_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # rubocop: disable Graphql/AuthorizeTypes
    class RepositoryLanguageType < BaseObject
      graphql_name 'RepositoryLanguage'

      def self.authorization_scopes
        super + [:ai_workflows]
      end

      field :name, GraphQL::Types::String, null: false,
        description: 'Name of the repository language.',
        scopes: [:api, :read_api, :ai_workflows]

      field :share, GraphQL::Types::Float, null: true,
        description: "Percentage of the repository's languages.",
        scopes: [:api, :read_api, :ai_workflows]

      field :color, Types::ColorType, null: true,
        description: 'Color to visualize the repository language.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/services/base_service_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    module Services
      # TODO: Remove in 17.0, see https://gitlab.com/gitlab-org/gitlab/-/merge_requests/108418
      class BaseServiceType < BaseObject
        graphql_name 'BaseService'

        implements Types::Projects::ServiceType

        authorize :admin_project
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/services/jira_project_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    module Services
      # rubocop:disable Graphql/AuthorizeTypes
      # TODO: Remove in 17.0, see https://gitlab.com/gitlab-org/gitlab/-/merge_requests/108418
      class JiraProjectType < BaseObject
        graphql_name 'JiraProject'

        field :key, GraphQL::Types::String, null: false,
          description: 'Key of the Jira project.'
        field :name, GraphQL::Types::String, null: true,
          description: 'Name of the Jira project.'
        field :project_id, GraphQL::Types::Int, null: false,
          description: 'ID of the Jira project.',
          method: :id
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/services/jira_service_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    module Services
      # TODO: Remove in 17.0, see https://gitlab.com/gitlab-org/gitlab/-/merge_requests/108418
      class JiraServiceType < BaseObject
        graphql_name 'JiraService'

        implements Types::Projects::ServiceType

        authorize :admin_project

        field :projects,
          Types::Projects::Services::JiraProjectType.connection_type,
          null: true,
          description: 'List of all Jira projects fetched through Jira REST API.',
          resolver: Resolvers::Projects::JiraProjectsResolver
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/service_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # TODO: Remove in 17.0, see https://gitlab.com/gitlab-org/gitlab/-/merge_requests/108418
    class ServiceTypeEnum < BaseEnum
      graphql_name 'ServiceType'

      class << self
        private

        def graphql_value(name)
          "#{name.upcase}_SERVICE"
        end

        def domain_value(name)
          Integration.integration_name_to_type(name)
        end

        def value_description(name)
          "#{Integration.integration_name_to_model(name).title} integration"
        end

        def integration_names
          Integration.available_integration_names(
            include_instance_specific: false, include_dev: false, include_disabled: true
          )
        end
      end

      # This prepend must stay here because the dynamic block below depends on it.
      prepend_mod

      integration_names.each do |name|
        value graphql_value(name), value: domain_value(name), description: value_description(name) # rubocop:disable Graphql/EnumValues -- Cop falsely identifies we must call upcase. Enum value is upcased in #graphql_value
      end
    end
  end
end

Types::Projects::ServiceTypeEnum.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/service_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # TODO: Remove in 17.0, see https://gitlab.com/gitlab-org/gitlab/-/merge_requests/108418
    module ServiceType
      include Types::BaseInterface
      graphql_name 'Service'

      # TODO: Add all the fields that we want to expose for the project services integrations
      # https://gitlab.com/gitlab-org/gitlab/-/issues/213088
      field :type, GraphQL::Types::String, null: true,
        description: 'Class name of the service.'
      field :service_type, ::Types::Projects::ServiceTypeEnum, null: true,
        description: 'Type of the service.', method: :type
      field :active, GraphQL::Types::Boolean, null: true,
        description: 'Indicates if the service is active.'

      def type
        enum = ::Types::Projects::ServiceTypeEnum.coerce_result(object.type, context)
        enum.downcase.camelize
      end

      definition_methods do
        def resolve_type(object, context)
          if object.is_a?(::Integrations::Jira)
            Types::Projects::Services::JiraServiceType
          else
            Types::Projects::Services::BaseServiceType
          end
        end
      end

      orphan_types Types::Projects::Services::BaseServiceType, Types::Projects::Services::JiraServiceType
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_statistics_redirect_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class ProjectStatisticsRedirectType < BaseObject
    graphql_name 'ProjectStatisticsRedirect'

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    field :repository, GraphQL::Types::String, null: false,
      description: 'Redirection Route for repository.',
      scopes: [:api, :read_api, :ai_workflows]

    field :wiki, GraphQL::Types::String, null: false,
      description: 'Redirection Route for wiki.'

    field :build_artifacts, GraphQL::Types::String, null: false,
      description: 'Redirection Route for job_artifacts.'

    field :packages, GraphQL::Types::String, null: false,
      description: 'Redirection Route for packages.'

    field :snippets, GraphQL::Types::String, null: false,
      description: 'Redirection Route for snippets.'

    field :container_registry, GraphQL::Types::String, null: false,
      description: 'Redirection Route for container_registry.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_statistics_type.rb =====
# frozen_string_literal: true

module Types
  class ProjectStatisticsType < BaseObject
    graphql_name 'ProjectStatistics'

    authorize :read_statistics

    field :commit_count, GraphQL::Types::Float, null: false,
      description: 'Commit count of the project.'

    field :build_artifacts_size, GraphQL::Types::Float, null: false,
      description: 'Build artifacts size of the project in bytes.'
    field :container_registry_size,
      GraphQL::Types::Float,
      null: true,
      description: 'Container registry size of the project in bytes.'
    field :lfs_objects_size,
      GraphQL::Types::Float,
      null: false,
      description: 'Large File Storage (LFS) object size of the project in bytes.'
    field :packages_size, GraphQL::Types::Float, null: false,
      description: 'Packages size of the project in bytes.'
    field :pipeline_artifacts_size, GraphQL::Types::Float, null: true,
      description: 'CI Pipeline artifacts size in bytes.'
    field :repository_size, GraphQL::Types::Float, null: false,
      description: 'Repository size of the project in bytes.'
    field :snippets_size, GraphQL::Types::Float, null: true,
      description: 'Snippets size of the project in bytes.'
    field :storage_size, GraphQL::Types::Float, null: false,
      description: 'Storage size of the project in bytes.'
    field :uploads_size, GraphQL::Types::Float, null: true,
      description: 'Uploads size of the project in bytes.'
    field :wiki_size, GraphQL::Types::Float, null: true,
      description: 'Wiki size of the project in bytes.'
  end
end

Types::ProjectStatisticsType.prepend_mod_with('Types::ProjectStatisticsType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/projects/topic_type.rb =====
# frozen_string_literal: true

module Types
  module Projects
    # rubocop: disable Graphql/AuthorizeTypes
    class TopicType < BaseObject
      graphql_name 'Topic'

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the topic.'

      field :name, GraphQL::Types::String, null: false,
        description: 'Name of the topic.'

      field :title, GraphQL::Types::String, null: false,
        method: :title_or_name,
        description: 'Title of the topic.'

      field :description, GraphQL::Types::String, null: true,
        description: 'Description of the topic.'

      field :avatar_url, GraphQL::Types::String, null: true,
        description: 'URL to avatar image file of the topic.'

      markdown_field :description_html, null: true

      def avatar_url
        object.avatar_url(only_path: false)
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/project_type.rb =====
# frozen_string_literal: true

module Types
  class ProjectType < BaseObject
    graphql_name 'Project'

    include ::Namespaces::DeletableHelper

    connection_type_class Types::CountableConnectionType

    authorize :read_project

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    expose_permissions Types::PermissionTypes::Project

    implements Types::TodoableInterface
    implements ::Types::Projects::ProjectInterface

    field :id, GraphQL::Types::ID,
      null: false,
      description: 'ID of the project.',
      scopes: [:api, :read_api, :ai_workflows]

    field :ci_config_path_or_default, GraphQL::Types::String,
      null: false,
      description: 'Path of the CI configuration file.'

    field :ci_config_variables, [Types::Ci::ConfigVariableType],
      null: true,
      calls_gitaly: true,
      authorize: :create_pipeline,
      experiment: { milestone: '15.3' },
      description: 'CI/CD config variable.' do
      argument :ref, GraphQL::Types::String,
        required: true,
        description: 'Ref.'
    end

    field :ci_pipeline_creation_request, Types::Ci::PipelineCreation::RequestType,
      authorize: :create_pipeline,
      description: 'Get information about an asynchronous pipeline creation request.',
      experiment: { milestone: '17.9' } do
      argument :request_id, GraphQL::Types::String,
        required: true,
        description: 'ID of the pipeline creation request.'
    end

    field :ci_pipeline_creation_inputs, [Types::Ci::Inputs::SpecType],
      authorize: :create_pipeline,
      null: true,
      calls_gitaly: true,
      experiment: { milestone: '17.10' },
      description: 'Inputs to create a pipeline.' do
      argument :ref, GraphQL::Types::String,
        required: true,
        description: 'Ref where to create the pipeline.'
    end

    field :full_path, GraphQL::Types::ID,
      null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Full path of the project.'

    field :path, GraphQL::Types::String,
      null: false,
      description: 'Path of the project.'

    field :organization_edit_path, GraphQL::Types::String,
      null: true,
      description: 'Path for editing project at the organization level.',
      experiment: { milestone: '16.11' }

    field :incident_management_timeline_event_tags, [Types::IncidentManagement::TimelineEventTagType],
      null: true,
      description: 'Timeline event tags for the project.'

    field :sast_ci_configuration, Types::CiConfiguration::Sast::Type,
      null: true,
      calls_gitaly: true,
      description: 'SAST CI configuration for the project.'

    field :name, GraphQL::Types::String,
      null: false,
      description: 'Name of the project without the namespace.',
      scopes: [:api, :read_api, :ai_workflows]

    field :name_with_namespace, GraphQL::Types::String,
      null: false,
      description: 'Name of the project including the namespace.'

    field :description, GraphQL::Types::String,
      null: true,
      description: 'Short description of the project.',
      scopes: [:api, :read_api, :ai_workflows]

    field :tag_list, GraphQL::Types::String,
      null: true,
      deprecated: { reason: 'Use `topics`', milestone: '13.12' },
      description: 'List of project topics (not Git tags).',
      method: :topic_list

    field :topics, [GraphQL::Types::String],
      null: true,
      description: 'List of project topics.',
      method: :topic_list

    field :http_url_to_repo, GraphQL::Types::String,
      null: true,
      description: 'URL to connect to the project via HTTPS.',
      scopes: [:api, :read_api, :ai_workflows]

    field :ssh_url_to_repo, GraphQL::Types::String,
      null: true,
      description: 'URL to connect to the project via SSH.',
      scopes: [:api, :read_api, :ai_workflows]

    field :web_url, GraphQL::Types::String,
      null: true,
      description: 'Web URL of the project.',
      scopes: [:api, :read_api, :ai_workflows]

    field :forks_count, GraphQL::Types::Int,
      null: false,
      calls_gitaly: true, # 4 times
      description: 'Number of times the project has been forked.'

    field :star_count, GraphQL::Types::Int,
      null: false,
      description: 'Number of times the project has been starred.'

    field :created_at, Types::TimeType,
      null: true,
      description: 'Timestamp of the project creation.'

    field :updated_at, Types::TimeType,
      null: true,
      description: 'Timestamp of when the project was last updated.'

    field :last_activity_at, Types::TimeType,
      null: true,
      description: 'Timestamp of the project last activity.'

    field :archived, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates the archived status of the project.',
      method: :self_or_ancestors_archived?

    field :is_self_deletion_in_progress, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if project deletion is in progress.',
      method: :self_deletion_in_progress?,
      experiment: { milestone: '18.3' }

    field :is_self_deletion_scheduled, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if project deletion is scheduled.',
      method: :self_deletion_scheduled?,
      experiment: { milestone: '18.3' }

    field :marked_for_deletion, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if the project or any ancestor is scheduled for deletion.',
      method: :scheduled_for_deletion_in_hierarchy_chain?,
      experiment: { milestone: '18.1' }

    field :marked_for_deletion_on, ::Types::TimeType,
      null: true,
      description: 'Date when project was scheduled to be deleted.',
      experiment: { milestone: '16.10' }

    field :permanent_deletion_date, GraphQL::Types::String,
      null: true,
      description: "For projects pending deletion, returns the project's scheduled deletion date. " \
        'For projects not pending deletion, returns a theoretical date based on current settings ' \
        'if marked for deletion today.',
      experiment: { milestone: '16.11' }

    field :visibility, GraphQL::Types::String,
      null: true,
      description: 'Visibility of the project.'

    field :lfs_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if the project has Large File Storage (LFS) enabled.'

    field :max_access_level, Types::AccessLevelType,
      null: false,
      description: 'Maximum access level of the current user in the project.'

    field :merge_requests_ff_only_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if no merge commits should be created and all merges should instead be ' \
        'fast-forwarded, which means that merging is only allowed if the branch could be fast-forwarded.'

    field :shared_runners_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if shared runners are enabled for the project.'

    field :service_desk_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if the project has Service Desk enabled.'

    field :service_desk_address, GraphQL::Types::String,
      null: true,
      description: 'E-mail address of the Service Desk.'

    field :avatar_url, GraphQL::Types::String,
      null: true,
      calls_gitaly: true,
      description: 'Avatar URL of the project.'

    field :jobs_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if CI/CD pipeline jobs are enabled for the current user.'

    field :is_catalog_resource, GraphQL::Types::Boolean,
      experiment: { milestone: '15.11' },
      null: true,
      description: 'Indicates if a project is a catalog resource.'

    field :explore_catalog_path, GraphQL::Types::String,
      experiment: { milestone: '17.6' },
      null: true,
      description: 'Path to the project catalog resource.'

    field :public_jobs, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if there is public access to pipelines and job details of the project, ' \
        'including output logs and artifacts.',
      method: :public_builds

    field :open_issues_count, GraphQL::Types::Int,
      null: true,
      description: 'Number of open issues for the project.'

    field :open_merge_requests_count, GraphQL::Types::Int,
      null: true,
      description: 'Number of open merge requests for the project.'

    field :allow_merge_on_skipped_pipeline, GraphQL::Types::Boolean,
      null: true,
      description: 'If `only_allow_merge_if_pipeline_succeeds` is true, indicates if merge requests of ' \
        'the project can also be merged with skipped jobs.'

    field :autoclose_referenced_issues, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if issues referenced by merge requests and commits within the default branch ' \
        'are closed automatically.'

    field :import_status, GraphQL::Types::String,
      null: true,
      description: 'Status of import background job of the project.'

    field :jira_import_status, GraphQL::Types::String,
      null: true,
      description: 'Status of Jira import background job of the project.'

    field :only_allow_merge_if_all_discussions_are_resolved, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if merge requests of the project can only be merged ' \
        'when all the discussions are resolved.'

    field :only_allow_merge_if_pipeline_succeeds, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if merge requests of the project can only be merged with successful jobs.'

    field :printing_merge_request_link_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if a link to create or view a merge request should display after a push to Git ' \
        'repositories of the project from the command line.'

    field :remove_source_branch_after_merge, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if `Delete source branch` option should be enabled by default for all ' \
        'new merge requests of the project.'

    field :request_access_enabled, GraphQL::Types::Boolean,
      null: true,
      description: 'Indicates if users can request member access to the project.'

    field :squash_read_only, GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if `squashReadOnly` is enabled.',
      method: :squash_readonly?

    field :suggestion_commit_message, GraphQL::Types::String,
      null: true,
      description: 'Commit message used to apply merge request suggestions.'

    # No, the quotes are not a typo. Used to get around circular dependencies.
    # See https://gitlab.com/gitlab-org/gitlab/-/merge_requests/27536#note_871009675
    field :group, 'Types::GroupType',
      null: true,
      description: 'Group of the project.'

    field :namespace, Types::NamespaceType,
      null: true,
      description: 'Namespace of the project.'

    field :statistics, Types::ProjectStatisticsType,
      null: true,
      description: 'Statistics of the project.'

    field :statistics_details_paths, Types::ProjectStatisticsRedirectType,
      null: true,
      description: 'Redirects for Statistics of the project.',
      scopes: [:api, :read_api, :ai_workflows],
      calls_gitaly: true

    field :repository, Types::RepositoryType,
      null: true,
      description: 'Git repository of the project.'

    field :merge_requests,
      Types::MergeRequestType.connection_type,
      null: true,
      description: 'Merge requests of the project.',
      extras: [:lookahead],
      resolver: Resolvers::ProjectMergeRequestsResolver

    field :merge_request,
      Types::MergeRequestType,
      null: true,
      description: 'A single merge request of the project.',
      resolver: Resolvers::MergeRequestsResolver.single

    field :issues,
      Types::IssueType.connection_type,
      null: true,
      description: 'Issues of the project.',
      resolver: Resolvers::ProjectIssuesResolver

    field :work_items,
      Types::WorkItemType.connection_type,
      null: true,
      experiment: { milestone: '15.1' },
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Work items of the project.',
      extras: [:lookahead],
      resolver: Resolvers::WorkItemsResolver

    field :work_item_state_counts,
      Types::WorkItemStateCountsType,
      null: true,
      experiment: { milestone: '16.7' },
      description: 'Counts of work items by state for the project.',
      resolver: Resolvers::WorkItemStateCountsResolver

    field :issue_status_counts,
      Types::IssueStatusCountsType,
      null: true,
      description: 'Counts of issues by status for the project.',
      resolver: Resolvers::IssueStatusCountsResolver

    field :milestones, Types::MilestoneType.connection_type,
      null: true,
      description: 'Milestones of the project.',
      resolver: Resolvers::ProjectMilestonesResolver

    field :project_members,
      description: 'Members of the project.',
      resolver: Resolvers::ProjectMembersResolver

    field :environments,
      Types::EnvironmentType.connection_type,
      null: true,
      description: 'Environments of the project. ' \
        'This field can only be resolved for one project in any single request.',
      resolver: Resolvers::EnvironmentsResolver do
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
    end

    field :environment,
      Types::EnvironmentType,
      null: true,
      description: 'A single environment of the project.',
      resolver: Resolvers::EnvironmentsResolver.single

    field :nested_environments,
      Types::NestedEnvironmentType.connection_type,
      null: true,
      calls_gitaly: true,
      description: 'Environments for this project with nested folders, ' \
        'can only be resolved for one project in any single request',
      resolver: Resolvers::Environments::NestedEnvironmentsResolver do
      extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
    end

    field :deployment,
      Types::DeploymentType,
      null: true,
      description: 'Details of the deployment of the project.',
      resolver: Resolvers::DeploymentResolver.single

    field :issue,
      Types::IssueType,
      null: true,
      description: 'A single issue of the project.',
      resolver: Resolvers::ProjectIssuesResolver.single

    field :packages,
      description: 'Packages of the project.',
      resolver: Resolvers::ProjectPackagesResolver

    field :packages_cleanup_policy,
      Types::Packages::Cleanup::PolicyType,
      null: true,
      description: 'Packages cleanup policy for the project.'

    field :packages_protection_rules,
      Types::Packages::Protection::RuleType.connection_type,
      null: true,
      description: 'Packages protection rules for the project.',
      experiment: { milestone: '16.6' },
      resolver: Resolvers::ProjectPackagesProtectionRulesResolver

    field :jobs,
      type: Types::Ci::JobType.connection_type,
      null: true,
      authorize: :read_build,
      description: 'Jobs of a project. This field can only be resolved for one project in any single request.',
      resolver: Resolvers::ProjectJobsResolver,
      connection_extension: ::Gitlab::Graphql::Extensions::ExternallyPaginatedArrayExtension

    field :job,
      type: Types::Ci::JobType,
      null: true,
      authorize: :read_build,
      description: 'One job belonging to the project, selected by ID.' do
      argument :id, Types::GlobalIDType[::CommitStatus],
        required: true,
        description: 'ID of the job.'
    end

    field :pipelines,
      null: true,
      calls_gitaly: true,
      description: 'Pipelines of the project.',
      extras: [:lookahead],
      resolver: Resolvers::Ci::ProjectPipelinesResolver

    field :pipeline_schedules,
      type: Types::Ci::PipelineScheduleType.connection_type,
      null: true,
      description: 'Pipeline schedules of the project. This field can only be resolved for one project per request.',
      resolver: Resolvers::Ci::ProjectPipelineSchedulesResolver

    field :pipeline_triggers,
      Types::Ci::PipelineTriggerType.connection_type,
      null: true,
      description: 'List of pipeline trigger tokens.',
      resolver: Resolvers::Ci::PipelineTriggersResolver,
      experiment: { milestone: '16.3' }

    field :pipeline, Types::Ci::PipelineType,
      null: true,
      description: 'Pipeline of the project. If no arguments are provided, returns the latest pipeline for the ' \
        'head commit on the default branch',
      extras: [:lookahead],
      resolver: Resolvers::Ci::ProjectPipelineResolver

    field :pipeline_counts, Types::Ci::PipelineCountsType,
      null: true,
      description: 'Pipeline counts of the project.',
      resolver: Resolvers::Ci::ProjectPipelineCountsResolver

    field :ci_variables, Types::Ci::ProjectVariableType.connection_type,
      null: true,
      description: "List of the project's CI/CD variables.",
      authorize: :admin_cicd_variables,
      resolver: Resolvers::Ci::VariablesResolver

    field :inherited_ci_variables, Types::Ci::InheritedCiVariableType.connection_type,
      null: true,
      description: "List of CI/CD variables the project inherited from its parent group and ancestors.",
      authorize: :admin_cicd_variables,
      resolver: Resolvers::Ci::InheritedVariablesResolver

    field :ci_cd_settings, Types::Ci::CiCdSettingType,
      null: true,
      description: 'CI/CD settings for the project.'

    field :sentry_detailed_error, Types::ErrorTracking::SentryDetailedErrorType,
      null: true,
      description: 'Detailed version of a Sentry error on the project.',
      resolver: Resolvers::ErrorTracking::SentryDetailedErrorResolver

    field :grafana_integration, Types::GrafanaIntegrationType,
      null: true,
      description: 'Grafana integration details for the project.',
      resolver: Resolvers::Projects::GrafanaIntegrationResolver

    field :snippets, Types::SnippetType.connection_type,
      null: true,
      description: 'Snippets of the project.',
      resolver: Resolvers::Projects::SnippetsResolver

    field :sentry_errors, Types::ErrorTracking::SentryErrorCollectionType,
      null: true,
      description: 'Paginated collection of Sentry errors on the project.',
      resolver: Resolvers::ErrorTracking::SentryErrorCollectionResolver

    field :boards, Types::BoardType.connection_type,
      null: true,
      description: 'Boards of the project.',
      max_page_size: 2000,
      resolver: Resolvers::BoardsResolver

    field :recent_issue_boards, Types::BoardType.connection_type,
      null: true,
      description: 'List of recently visited boards of the project. Maximum size is 4.',
      resolver: Resolvers::RecentBoardsResolver

    field :board, Types::BoardType,
      null: true,
      description: 'A single board of the project.',
      resolver: Resolvers::BoardResolver

    field :jira_imports, Types::JiraImportType.connection_type,
      null: true,
      description: 'Jira imports into the project.'

    field :services, Types::Projects::ServiceType.connection_type,
      null: true,
      deprecated: {
        reason: 'A `Project.integrations` field is proposed instead in [issue 389904](https://gitlab.com/gitlab-org/gitlab/-/issues/389904)',
        milestone: '15.9'
      },
      description: 'Project services.',
      resolver: Resolvers::Projects::ServicesResolver

    field :alert_management_alerts, Types::AlertManagement::AlertType.connection_type,
      null: true,
      description: 'Alert Management alerts of the project.',
      extras: [:lookahead],
      resolver: Resolvers::AlertManagement::AlertResolver

    field :alert_management_alert, Types::AlertManagement::AlertType,
      null: true,
      description: 'A single Alert Management alert of the project.',
      resolver: Resolvers::AlertManagement::AlertResolver.single

    field :alert_management_alert_status_counts, Types::AlertManagement::AlertStatusCountsType,
      null: true,
      description: 'Counts of alerts by status for the project.',
      resolver: Resolvers::AlertManagement::AlertStatusCountsResolver

    field :alert_management_integrations, Types::AlertManagement::IntegrationType.connection_type,
      null: true,
      description: 'Integrations which can receive alerts for the project.',
      resolver: Resolvers::AlertManagement::IntegrationsResolver,
      deprecated: { reason: 'Use `alertManagementHttpIntegrations`', milestone: '18.2' }

    field :alert_management_http_integrations, Types::AlertManagement::HttpIntegrationType.connection_type,
      null: true,
      description: 'HTTP Integrations which can receive alerts for the project.',
      resolver: Resolvers::AlertManagement::HttpIntegrationsResolver

    field :incident_management_timeline_events, Types::IncidentManagement::TimelineEventType.connection_type,
      null: true,
      description: 'Incident Management Timeline events associated with the incident.',
      extras: [:lookahead],
      resolver: Resolvers::IncidentManagement::TimelineEventsResolver

    field :incident_management_timeline_event, Types::IncidentManagement::TimelineEventType,
      null: true,
      description: 'Incident Management Timeline event associated with the incident.',
      resolver: Resolvers::IncidentManagement::TimelineEventsResolver.single

    field :releases, Types::ReleaseType.connection_type,
      null: true,
      description: 'Releases of the project.',
      resolver: Resolvers::ReleasesResolver

    field :release, Types::ReleaseType,
      null: true,
      description: 'A single release of the project.',
      resolver: Resolvers::ReleasesResolver.single,
      authorize: :read_release

    field :container_tags_expiration_policy, Types::ContainerRegistry::ContainerTagsExpirationPolicyType,
      null: true,
      description: 'Container tags expiration policy of the project.',
      method: :container_expiration_policy,
      authorize: :read_container_image

    field :container_expiration_policy, Types::ContainerExpirationPolicyType,
      null: true,
      deprecated: { reason: 'Use `container_tags_expiration_policy`', milestone: '17.5' },
      description: 'Container expiration policy of the project.'

    field :container_protection_repository_rules,
      Types::ContainerRegistry::Protection::RuleType.connection_type,
      null: true,
      description: 'Container protection rules for the project.',
      experiment: { milestone: '16.10' },
      resolver: Resolvers::ProjectContainerRegistryProtectionRulesResolver

    field :container_protection_tag_rules,
      Types::ContainerRegistry::Protection::TagRuleType.connection_type,
      null: true,
      experiment: { milestone: '17.8' },
      description: 'Container repository tag protection rules for the project.'

    field :container_repositories, Types::ContainerRegistry::ContainerRepositoryType.connection_type,
      null: true,
      description: 'Container repositories of the project.',
      resolver: Resolvers::ContainerRepositoriesResolver

    field :container_repositories_count, GraphQL::Types::Int,
      null: false,
      description: 'Number of container repositories in the project.'

    field :label, Types::LabelType,
      null: true,
      description: 'Label available on the project.' do
      argument :title, GraphQL::Types::String,
        required: true,
        description: 'Title of the label.'
    end

    field :terraform_state, Types::Terraform::StateType,
      null: true,
      description: 'Find a single Terraform state by name.',
      resolver: Resolvers::Terraform::StatesResolver.single

    field :terraform_states, Types::Terraform::StateType.connection_type,
      null: true,
      description: 'Terraform states associated with the project.',
      resolver: Resolvers::Terraform::StatesResolver

    field :pipeline_analytics, Types::Ci::AnalyticsType,
      null: true,
      description: 'Pipeline analytics.',
      resolver: Resolvers::Ci::PipelineAnalyticsResolver

    field :ci_template, Types::Ci::TemplateType,
      null: true,
      description: 'Find a single CI/CD template by name.',
      resolver: Resolvers::Ci::TemplateResolver

    field :ci_job_token_scope, Types::Ci::JobTokenScopeType,
      null: true,
      description: 'The CI Job Tokens scope of access.',
      resolver: Resolvers::Ci::JobTokenScopeResolver

    field :ci_job_token_scope_allowlist, Types::Ci::JobTokenScope::AllowlistType,
      null: true,
      experiment: { milestone: '17.6' },
      description: 'List of CI job token scopes where the project is the source.',
      resolver: Resolvers::Ci::JobTokenScopeAllowlistResolver

    field :ci_job_token_auth_logs, Types::Ci::JobTokenAuthLogType.connection_type,
      null: true,
      experiment: { milestone: '17.6' },
      description: 'The CI Job Tokens authorization logs.',
      extras: [:lookahead],
      resolver: Resolvers::Ci::JobTokenAuthLogsResolver

    field :timelogs, Types::TimelogType.connection_type,
      null: true,
      description: 'Time logged on issues and merge requests in the project.',
      extras: [:lookahead],
      complexity: 5,
      resolver: ::Resolvers::TimelogResolver

    field :agent_configurations,
      null: true,
      description: 'Agent configurations defined by the project',
      resolver: ::Resolvers::Kas::AgentConfigurationsResolver

    field :cluster_agent, ::Types::Clusters::AgentType,
      null: true,
      description: 'Find a single cluster agent by name.',
      resolver: ::Resolvers::Clusters::AgentsResolver.single

    field :cluster_agents, ::Types::Clusters::AgentType.connection_type,
      extras: [:lookahead],
      null: true,
      description: 'Cluster agents associated with the project.',
      resolver: ::Resolvers::Clusters::AgentsResolver

    field :ci_access_authorized_agents, ::Types::Clusters::Agents::Authorizations::CiAccessType.connection_type,
      null: true,
      description: 'Authorized cluster agents for the project through ci_access keyword.',
      resolver: ::Resolvers::Clusters::Agents::Authorizations::CiAccessResolver,
      authorize: :read_cluster_agent

    field :user_access_authorized_agents, ::Types::Clusters::Agents::Authorizations::UserAccessType.connection_type,
      null: true,
      description: 'Authorized cluster agents for the project through user_access keyword.',
      resolver: ::Resolvers::Clusters::Agents::Authorizations::UserAccessResolver,
      authorize: :read_cluster_agent

    field :merge_commit_template, GraphQL::Types::String,
      null: true,
      description: 'Template used to create merge commit message in merge requests.'

    field :squash_commit_template, GraphQL::Types::String,
      null: true,
      description: 'Template used to create squash commit message in merge requests.'

    field :merge_request_title_regex, GraphQL::Types::String,
      null: true,
      description: 'Regex used to validate the title of merge requests.'

    field :merge_request_title_regex_description, GraphQL::Types::String,
      null: true,
      description: 'Description of the regex used to validate the title of merge requests.'

    field :labels, Types::LabelType.connection_type,
      null: true,
      description: 'Labels available on this project.',
      resolver: Resolvers::LabelsResolver

    field :work_item_types, Types::WorkItems::TypeType.connection_type,
      resolver: Resolvers::WorkItems::TypesResolver,
      description: 'Work item types available to the project.'

    field :timelog_categories, Types::TimeTracking::TimelogCategoryType.connection_type,
      null: true,
      description: "Timelog categories for the project.",
      experiment: { milestone: '15.3' }

    field :fork_targets, Types::NamespaceType.connection_type,
      resolver: Resolvers::Projects::ForkTargetsResolver,
      description: 'Namespaces in which the current user can fork the project into.'

    field :fork_details, Types::Projects::ForkDetailsType,
      calls_gitaly: true,
      experiment: { milestone: '15.7' },
      authorize: :read_code,
      resolver: Resolvers::Projects::ForkDetailsResolver,
      description: 'Details of the fork project compared to its upstream project.'

    field :forked_from, Types::ProjectType,
      null: true,
      description: 'Project the project was forked from.',
      method: :forked_from_project

    field :branch_rules, Types::Projects::BranchRuleType.connection_type,
      null: true,
      description: "Branch rules configured for the project.",
      resolver: Resolvers::Projects::BranchRulesResolver

    field :languages, [Types::Projects::RepositoryLanguageType],
      null: true,
      description: "Programming languages used in the project.",
      scopes: [:api, :read_api, :ai_workflows],
      calls_gitaly: true

    field :runners, Types::Ci::RunnerType.connection_type,
      null: true,
      resolver: ::Resolvers::Ci::ProjectRunnersResolver,
      description: "Find runners visible to the current user."

    field :data_transfer, Types::DataTransfer::ProjectDataTransferType,
      null: true, # disallow null once data_transfer_monitoring feature flag is rolled-out! https://gitlab.com/gitlab-org/gitlab/-/issues/391682
      resolver: Resolvers::DataTransfer::ProjectDataTransferResolver,
      description: 'Data transfer data point for a specific period. ' \
        'This is mocked data under a development feature flag.'

    field :visible_forks, Types::ProjectType.connection_type,
      null: true,
      experiment: { milestone: '15.10' },
      description: "Visible forks of the project." do
      argument :minimum_access_level,
        type: ::Types::AccessLevelEnum,
        required: false,
        description: 'Minimum access level.'
    end

    field :flow_metrics,
      ::Types::Analytics::CycleAnalytics::FlowMetrics[:project],
      null: true,
      description: 'Flow metrics for value stream analytics.',
      method: :project_namespace,
      authorize: :read_cycle_analytics,
      experiment: { milestone: '15.10' }

    field :commit_references, ::Types::CommitReferencesType,
      null: true,
      resolver: Resolvers::Projects::CommitReferencesResolver,
      experiment: { milestone: '16.0' },
      description: "Get tag names containing a given commit."

    field :autocomplete_users,
      null: true,
      resolver: Resolvers::AutocompleteUsersResolver,
      description: 'Search users for autocompletion'

    field :detailed_import_status,
      ::Types::Projects::DetailedImportStatusType,
      null: true,
      description: 'Detailed import status of the project.',
      method: :import_state

    field :value_streams,
      description: 'Value streams available to the project.',
      null: true,
      resolver: Resolvers::Analytics::CycleAnalytics::ValueStreamsResolver

    field :ml_models, ::Types::Ml::ModelType.connection_type,
      null: true,
      experiment: { milestone: '16.8' },
      description: 'Finds machine learning models',
      resolver: Resolvers::Ml::FindModelsResolver

    field :ml_experiments, ::Types::Ml::ExperimentType.connection_type,
      null: true,
      description: 'Find machine learning experiments',
      resolver: ::Resolvers::Ml::FindExperimentsResolver

    field :allows_multiple_merge_request_assignees,
      GraphQL::Types::Boolean,
      method: :allows_multiple_merge_request_assignees?,
      description: 'Project allows assigning multiple users to a merge request.',
      null: false

    field :allows_multiple_merge_request_reviewers,
      GraphQL::Types::Boolean,
      method: :allows_multiple_merge_request_reviewers?,
      description: 'Project allows assigning multiple reviewers to a merge request.',
      null: false

    field :is_forked,
      GraphQL::Types::Boolean,
      resolver: Resolvers::Projects::IsForkedResolver,
      description: 'Project is forked.',
      null: false

    field :protectable_branches,
      [GraphQL::Types::String],
      description: 'List of unprotected branches, ignoring any wildcard branch rules.',
      null: true,
      calls_gitaly: true,
      experiment: { milestone: '16.9' },
      authorize: :read_code

    field :project_plan_limits, Types::ProjectPlanLimitsType,
      resolver: Resolvers::Projects::PlanLimitsResolver,
      description: 'Plan limits for the current project.',
      experiment: { milestone: '16.9' },
      null: true

    field :available_deploy_keys, Types::AccessLevels::DeployKeyType.connection_type,
      resolver: Resolvers::Projects::DeployKeyResolver,
      description: 'List of available deploy keys',
      extras: [:lookahead],
      null: true,
      authorize: :admin_project do
        argument :title_query, GraphQL::Types::String,
          required: false,
          description: 'Term by which to search deploy key titles.'
      end

    field :pages_deployments, Types::PagesDeploymentType.connection_type, null: true,
      resolver: Resolvers::PagesDeploymentsResolver,
      connection: true,
      description: "List of the project's Pages Deployments."

    field :pages_force_https, GraphQL::Types::Boolean,
      null: false,
      description: "Project's Pages site redirects unsecured connections to HTTPS."

    field :pages_use_unique_domain, GraphQL::Types::Boolean,
      null: false,
      description: "Project's Pages site uses a unique subdomain."

    def ci_pipeline_creation_request(request_id:)
      ::Ci::PipelineCreation::Requests.get_request(object, request_id)
    end

    def pages_force_https
      project.pages_https_only?
    end

    def pages_use_unique_domain
      lazy_project_settings = BatchLoader::GraphQL.for(object.id).batch do |project_ids, loader|
        ::ProjectSetting.for_projects(project_ids).each do |project_setting|
          loader.call(project_setting.project_id, project_setting)
        end
      end

      Gitlab::Graphql::Lazy.with_value(lazy_project_settings) do |settings|
        (settings || object.project_setting).pages_unique_domain_enabled?
      end
    end

    def protectable_branches
      ProtectableDropdown.new(project, :branches).protectable_ref_names
    end

    def timelog_categories
      object.project_namespace.timelog_categories if Feature.enabled?(:timelog_categories)
    end

    def label(title:)
      BatchLoader::GraphQL.for(title).batch(key: project) do |titles, loader, args|
        LabelsFinder
          .new(current_user, project: args[:key], title: titles)
          .execute
          .each { |label| loader.call(label.title, label) }
      end
    end

    def container_protection_tag_rules
      # Immutable tag rules are added in EE extension
      object.container_registry_protection_tag_rules.mutable
    end

    {
      issues: "Issues are",
      merge_requests: "Merge requests are",
      wiki: 'Wikis are',
      snippets: 'Snippets are',
      container_registry: 'Container registry is'
    }.each do |feature, name_string|
      field "#{feature}_enabled", GraphQL::Types::Boolean, null: true,
        description: "Indicates if #{name_string} enabled for the current user"

      define_method "#{feature}_enabled" do # rubocop:disable Performance/StringIdentifierArgument
        object.feature_available?(feature, context[:current_user]) # rubocop:disable Gitlab/FeatureAvailableUsage
      end
    end

    [:issues, :forking, :merge_requests].each do |feature|
      field_name = "#{feature}_access_level"
      feature_name = feature.to_s.tr("_", " ")

      field field_name, Types::ProjectFeatureAccessLevelType,
        null: true,
        description: "Access level required for #{feature_name} access."

      define_method field_name do
        project.project_feature&.access_level(feature)
      end
    end

    markdown_field :description_html, null: true

    def jobs_enabled
      object.feature_available?(:builds, context[:current_user])
    end

    def open_issues_count
      BatchLoader::GraphQL.wrap(object.open_issues_count) if object.feature_available?(:issues, context[:current_user])
    end

    def open_merge_requests_count
      return unless object.feature_available?(:merge_requests, context[:current_user])

      BatchLoader::GraphQL.wrap(object.open_merge_requests_count)
    end

    def forks_count
      BatchLoader::GraphQL.wrap(object.forks_count)
    end

    def is_catalog_resource # rubocop:disable Naming/PredicateName
      lazy_catalog_resource = BatchLoader::GraphQL.for(object.id).batch do |project_ids, loader|
        ::Ci::Catalog::Resource.for_projects(project_ids).each do |catalog_resource|
          loader.call(catalog_resource.project_id, catalog_resource)
        end
      end

      Gitlab::Graphql::Lazy.with_value(lazy_catalog_resource, &:present?)
    end

    def explore_catalog_path
      return unless project.catalog_resource

      Gitlab::Routing.url_helpers.explore_catalog_path(project.catalog_resource)
    end

    def statistics
      Gitlab::Graphql::Loaders::BatchProjectStatisticsLoader.new(object.id).find
    end

    def container_repositories_count
      project.container_repositories.size
    end

    def ci_pipeline_creation_inputs(ref:)
      response = ::Ci::PipelineCreation::FindPipelineInputsService.new(
        current_user: context[:current_user],
        project: object,
        ref: ref).execute

      raise Gitlab::Graphql::Errors::ArgumentError, response.message if response.error?

      response.payload[:inputs].all_inputs
    end

    def ci_config_variables(ref:)
      result = ::Ci::ListConfigVariablesService.new(object, context[:current_user]).execute(ref)

      return if result.nil?

      result.map do |var_key, var_config|
        { key: var_key, **var_config }
      end
    end

    def job(id:)
      object.commit_statuses.find(id.model_id)
    rescue ActiveRecord::RecordNotFound
    end

    def sast_ci_configuration
      return unless Ability.allowed?(current_user, :read_code, object)

      if project.repository.empty?
        raise Gitlab::Graphql::Errors::MutationError,
          _(format('You must %s before using Security features.', add_file_docs_link.html_safe)).html_safe
      end

      ::Security::CiConfiguration::SastParserService.new(object).configuration
    end

    def service_desk_address
      return unless Ability.allowed?(current_user, :admin_issue, project)

      ::ServiceDesk::Emails.new(object).address
    end

    def service_desk_enabled
      ::ServiceDesk.enabled?(project)
    end

    def languages
      ::Projects::RepositoryLanguagesService.new(project, current_user).execute
    end

    def visible_forks(minimum_access_level: nil)
      if minimum_access_level.nil?
        object.forks.public_or_visible_to_user(current_user)
      else
        return [] if current_user.nil?

        object.forks.visible_to_user_and_access_level(current_user, minimum_access_level)
      end
    end

    def statistics_details_paths
      root_ref = project.repository.root_ref || project.default_branch_or_main

      {
        repository: Gitlab::Routing.url_helpers.project_tree_url(project, root_ref),
        wiki: Gitlab::Routing.url_helpers.project_wikis_pages_url(project),
        build_artifacts: Gitlab::Routing.url_helpers.project_artifacts_url(project),
        packages: Gitlab::Routing.url_helpers.project_packages_url(project),
        snippets: Gitlab::Routing.url_helpers.project_snippets_url(project),
        container_registry: Gitlab::Routing.url_helpers.project_container_registry_index_url(project)
      }
    end

    def max_access_level
      return Gitlab::Access::NO_ACCESS if current_user.nil?

      BatchLoader::GraphQL.for(object.id).batch do |project_ids, loader|
        current_user.max_member_access_for_project_ids(project_ids).each do |project_id, max_access_level|
          loader.call(project_id, max_access_level)
        end
      end
    end

    def organization_edit_path
      return if project.organization.nil?

      ::Gitlab::Routing.url_helpers.edit_namespace_projects_organization_path(
        project.organization,
        id: project.to_param,
        namespace_id: project.namespace.to_param
      )
    end

    # marked_for_deletion_at is deprecated in our v5 REST API in favor of marked_for_deletion_on
    # https://docs.gitlab.com/ee/api/projects.html#removals-in-api-v5
    def marked_for_deletion_on
      project.marked_for_deletion_at
    end

    def permanent_deletion_date
      permanent_deletion_date_formatted(project) || permanent_deletion_date_formatted
    end

    private

    def project
      @project ||= object.respond_to?(:sync) ? object.sync : object
    end

    def add_file_docs_link
      ActionController::Base.helpers.link_to _('add at least one file to the repository'),
        Rails.application.routes.url_helpers.help_page_url(
          'user/project/repository/_index.md',
          anchor: 'add-files-to-a-repository'),
        target: '_blank',
        rel: 'noopener noreferrer'
    end
  end
end

Types::ProjectType.prepend_mod_with('Types::ProjectType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/prometheus_alert_type.rb =====
# frozen_string_literal: true

# All references to this type are deprecated and always return nil,
# so this type should no longer be initialized
module Types
  class PrometheusAlertType < BaseObject
    graphql_name 'PrometheusAlert'
    description 'The alert condition for Prometheus'

    authorize :admin_operations

    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the alert condition.'

    field :humanized_text,
      GraphQL::Types::String,
      null: false,
      description: 'Human-readable text of the alert condition.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/query_complexity_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class QueryComplexityType < ::Types::BaseObject
    graphql_name 'QueryComplexity'

    ANALYZER = GraphQL::Analysis::AST::QueryComplexity

    alias_method :query, :object

    field :limit, GraphQL::Types::Int,
      null: true,
      method: :max_complexity,
      see: {
        'GitLab documentation on this limit' =>
          'https://docs.gitlab.com/ee/api/graphql/#maximum-query-complexity'
      },
      description: 'GraphQL query complexity limit.'

    field :score, GraphQL::Types::Int,
      null: true,
      description: 'GraphQL query complexity score.'

    def score
      ::GraphQL::Analysis::AST.analyze_query(query, [ANALYZER]).first
    end
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/query_type.rb =====
# frozen_string_literal: true

module Types
  class QueryType < ::Types::BaseObject
    graphql_name 'Query'

    # The design management context object needs to implement #issue
    DesignManagementObject = Struct.new(:issue)

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    field :board_list, ::Types::BoardListType,
      null: true,
      resolver: Resolvers::BoardListResolver
    field :ci_application_settings, Types::Ci::ApplicationSettingType,
      null: true,
      description: 'CI related settings that apply to the entire instance.'

    field :ci_config, resolver: Resolvers::Ci::ConfigResolver, complexity: 126, # AUTHENTICATED_MAX_COMPLEXITY / 2 + 1
      deprecated: {
        reason: 'Use CiLint mutation: <https://docs.gitlab.com/api/graphql/reference/#mutationcilint>',
        milestone: '18.1'
      }

    field :ci_pipeline_stage, ::Types::Ci::StageType,
      null: true, description: 'Stage belonging to a CI pipeline.' do
      argument :id, type: ::Types::GlobalIDType[::Ci::Stage],
        required: true, description: 'Global ID of the CI stage.'
    end

    field :ci_catalog_resources,
      ::Types::Ci::Catalog::ResourceType.connection_type,
      null: true,
      experiment: { milestone: '15.11' },
      description: 'All CI/CD Catalog resources under a common namespace, visible to an authorized user',
      resolver: ::Resolvers::Ci::Catalog::ResourcesResolver

    field :ci_catalog_resource,
      ::Types::Ci::Catalog::ResourceType,
      null: true,
      experiment: { milestone: '16.1' },
      description: 'A single CI/CD Catalog resource visible to an authorized user',
      resolver: ::Resolvers::Ci::Catalog::ResourceResolver

    field :ci_variables,
      Types::Ci::InstanceVariableType.connection_type,
      null: true,
      description: "List of the instance's CI/CD variables.",
      resolver: Resolvers::Ci::VariablesResolver
    field :container_repository, Types::ContainerRegistry::ContainerRepositoryDetailsType,
      null: true,
      description: 'Find a container repository.' do
      argument :id,
        type: ::Types::GlobalIDType[::ContainerRepository],
        required: true,
        description: 'Global ID of the container repository.'
    end
    field :current_user, Types::CurrentUserType,
      null: true,
      description: "Get information about current user."
    field :design_management, Types::DesignManagementType,
      null: false,
      description: 'Fields related to design management.'
    field :echo, resolver: Resolvers::EchoResolver
    field :frecent_groups, [Types::GroupType],
      resolver: Resolvers::Users::FrecentGroupsResolver,
      description: "A user's frecently visited groups"
    field :frecent_projects, [Types::ProjectType],
      resolver: Resolvers::Users::FrecentProjectsResolver,
      description: "A user's frecently visited projects"
    field :gitpod_enabled, GraphQL::Types::Boolean,
      null: true,
      description: "Whether Gitpod is enabled in application settings."
    field :group, Types::GroupType,
      null: true,
      resolver: Resolvers::GroupResolver,
      description: "Find a group."
    field :groups, Types::GroupType.connection_type,
      null: true,
      resolver: Resolvers::GroupsResolver,
      description: "Find groups."
    field :issue, Types::IssueType,
      null: true,
      description: 'Find an issue.' do
      argument :id, ::Types::GlobalIDType[::Issue], required: true, description: 'Global ID of the issue.'
    end
    field :issues,
      null: true,
      experiment: { milestone: '15.6' },
      resolver: Resolvers::IssuesResolver,
      description: 'Find issues visible to the current user. ' \
        'At least one filter must be provided.'
    field :jobs,
      ::Types::Ci::JobInterface.connection_type,
      null: true,
      description: 'All jobs on this GitLab instance. ' \
        'Returns an empty result for users without administrator access.',
      resolver: ::Resolvers::Ci::AllJobsResolver
    field :merge_request, Types::MergeRequestType,
      null: true,
      description: 'Find a merge request.' do
      argument :id, ::Types::GlobalIDType[::MergeRequest], required: true, description: 'Global ID of the merge request.'
    end
    field :metadata, Types::AppConfig::InstanceMetadataType,
      null: true,
      resolver: Resolvers::AppConfig::InstanceMetadataResolver,
      description: 'Metadata about GitLab.'
    field :milestone, ::Types::MilestoneType,
      null: true,
      extras: [:lookahead],
      description: 'Find a milestone.' do
      argument :id, ::Types::GlobalIDType[Milestone], required: true, description: 'Find a milestone by its ID.'
    end
    field :namespace, Types::NamespaceType,
      null: true,
      scopes: [:api, :read_api, :ai_workflows],
      resolver: Resolvers::NamespaceResolver,
      description: "Find a namespace."
    field :note,
      ::Types::Notes::NoteType,
      null: true,
      description: 'Find a note.',
      experiment: { milestone: '15.9' } do
      argument :id, ::Types::GlobalIDType[::Note],
        required: true,
        description: 'Global ID of the note.'
    end
    field :organization,
      Types::Organizations::OrganizationType,
      null: true,
      resolver: Resolvers::Organizations::OrganizationResolver,
      description: "Find an organization.",
      experiment: { milestone: '16.4' }
    field :organizations, Types::Organizations::OrganizationType.connection_type,
      null: true,
      resolver: Resolvers::Organizations::OrganizationsResolver,
      description: "List organizations.",
      experiment: { milestone: '16.8' }
    field :package,
      description: 'Find a package. This field can only be resolved for one query in any single request. Returns `null` if a package has no `default` status.',
      resolver: Resolvers::PackageDetailsResolver
    field :project, Types::ProjectType,
      null: true,
      resolver: Resolvers::ProjectResolver,
      description: "Find a project.",
      scopes: [:api, :read_api, :ai_workflows]
    field :projects,
      null: true,
      resolver: Resolvers::ProjectsResolver,
      description: "Find projects visible to the current user."
    field :query_complexity, Types::QueryComplexityType,
      null: true,
      description: 'Information about the complexity of the GraphQL query.'
    field :runner, Types::Ci::RunnerType,
      null: true,
      resolver: Resolvers::Ci::RunnerResolver,
      description: "Find a runner."
    field :runner_platforms, resolver: Resolvers::Ci::RunnerPlatformsResolver,
      deprecated: { reason: 'No longer used, use gitlab-runner documentation to learn about supported platforms', milestone: '15.9' }
    field :runner_setup, resolver: Resolvers::Ci::RunnerSetupResolver,
      deprecated: { reason: 'No longer used, use gitlab-runner documentation to learn about runner registration commands', milestone: '15.9' }
    field :runners, Types::Ci::RunnerType.connection_type,
      null: true,
      resolver: Resolvers::Ci::RunnersResolver,
      description: "Get all runners in the GitLab instance (project and shared). " \
        "Access is restricted to users with administrator access."
    field :snippets,
      Types::SnippetType.connection_type,
      null: true,
      resolver: Resolvers::SnippetsResolver,
      description: 'Find Snippets visible to the current user.'
    field :synthetic_note,
      Types::Notes::NoteType,
      null: true,
      description: 'Find a synthetic note',
      resolver: ::Resolvers::Notes::SyntheticNoteResolver,
      experiment: { milestone: '15.9' }
    field :timelogs, Types::TimelogType.connection_type,
      null: true,
      description: 'Find timelogs visible to the current user.',
      extras: [:lookahead],
      complexity: 5,
      resolver: ::Resolvers::TimelogResolver
    field :todo,
      null: true,
      resolver: Resolvers::TodoResolver
    field :topics, Types::Projects::TopicType.connection_type,
      null: true,
      resolver: Resolvers::TopicsResolver,
      description: "Find project topics."
    field :usage_trends_measurements,
      null: true,
      description: 'Get statistics on the instance.',
      resolver: Resolvers::Admin::Analytics::UsageTrends::MeasurementsResolver
    field :user, Types::UserType,
      null: true,
      description: 'Find a user.',
      resolver: Resolvers::UserResolver
    field :users, Types::UserType.connection_type,
      null: true,
      description: 'Find users.',
      resolver: Resolvers::UsersResolver
    field :wiki_page, Types::Wikis::WikiPageType,
      null: true,
      resolver: Resolvers::Wikis::WikiPageResolver,
      experiment: { milestone: '17.6' },
      description: 'Find a wiki page.',
      calls_gitaly: true
    field :work_item, Types::WorkItemType,
      null: true,
      resolver: Resolvers::WorkItemResolver,
      experiment: { milestone: '15.1' },
      description: 'Find a work item.'

    field :work_item_description_template_content, WorkItems::DescriptionTemplateType,
      null: true,
      resolver: Resolvers::WorkItems::DescriptionTemplateContentResolver,
      experiment: { milestone: '17.9' },
      description: 'Find a work item description template.',
      calls_gitaly: true

    field :audit_event_definitions,
      Types::AuditEvents::DefinitionType.connection_type,
      null: false,
      description: 'Definitions for all audit events available on the instance.',
      resolver: Resolvers::AuditEvents::AuditEventDefinitionsResolver

    field :abuse_report, ::Types::AbuseReportType,
      null: true,
      experiment: { milestone: '16.3' },
      description: 'Find an abuse report.',
      resolver: Resolvers::AbuseReportResolver

    field :abuse_report_labels, ::Types::AntiAbuse::AbuseReportLabelType.connection_type,
      null: true,
      experiment: { milestone: '16.3' },
      description: 'Abuse report labels.',
      resolver: Resolvers::AbuseReportLabelsResolver

    field :ml_model, ::Types::Ml::ModelType,
      null: true,
      experiment: { milestone: '16.7' },
      description: 'Find machine learning models.',
      resolver: Resolvers::Ml::ModelDetailResolver

    field :ml_experiment, ::Types::Ml::ExperimentType,
      null: true,
      description: 'Find a machine learning experiment.',
      resolver: Resolvers::Ml::ExperimentDetailResolver

    field :integration_exclusions, Types::Integrations::ExclusionType.connection_type,
      null: true,
      experiment: { milestone: '17.0' },
      resolver: Resolvers::Integrations::ExclusionsResolver

    field :work_items_by_reference,
      null: true,
      experiment: { milestone: '16.7' },
      description: 'Find work items by their reference.',
      extras: [:lookahead],
      resolver: Resolvers::WorkItemReferencesResolver

    field :feature_flag_enabled, GraphQL::Types::Boolean,
      null: false,
      deprecated: { reason: 'Replaced with metadata.featureFlags', milestone: '17.4' },
      description: 'Check if a feature flag is enabled',
      resolver: Resolvers::FeatureFlagResolver

    def design_management
      DesignManagementObject.new(nil)
    end

    def issue(id:)
      GitlabSchema.find_by_gid(id)
    end

    def note(id:)
      GitlabSchema.find_by_gid(id)
    end

    def merge_request(id:)
      GitlabSchema.find_by_gid(id)
    end

    def milestone(id:, lookahead:)
      preloads = [:releases] if lookahead.selects?(:releases)
      Gitlab::Graphql::Loaders::BatchModelLoader.new(id.model_class, id.model_id, preloads).find
    end

    def container_repository(id:)
      GitlabSchema.find_by_gid(id)
    end

    def current_user
      context[:current_user]
    end

    def ci_application_settings
      application_settings
    end

    def application_settings
      Gitlab::CurrentSettings.current_application_settings
    end

    def gitpod_enabled
      application_settings.gitpod_enabled
    end

    def query_complexity
      context.query
    end

    def ci_pipeline_stage(id:)
      stage = ::Gitlab::Graphql::Lazy.force(GitlabSchema.find_by_gid(id))
      return unless stage

      authorized = Ability.allowed?(current_user, :read_build, stage.project)

      return unless authorized

      stage
    end
  end
end

Types::QueryType.prepend_mod_with('Types::QueryType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/range_input_type.rb =====
# frozen_string_literal: true

module Types
  class RangeInputType < BaseInputObject
    def self.[](type, closed = true)
      @subtypes ||= {}

      @subtypes[[type, closed]] ||= Class.new(self) do
        argument :start, type,
          required: closed,
          description: 'Start of the range.'

        argument :end, type,
          required: closed,
          description: 'End of the range.'
      end
    end

    def prepare
      if self[:end] && self[:start] && self[:end] < self[:start]
        raise ::Gitlab::Graphql::Errors::ArgumentError, 'start must be before end'
      end

      super
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/ref_type_enum.rb =====
# frozen_string_literal: true

module Types
  class RefTypeEnum < BaseEnum
    graphql_name 'RefType'
    description 'Type of ref'

    value 'HEADS', description: 'Ref type for branches.', value: 'heads'
    value 'TAGS', description: 'Ref type for tags.', value: 'tags'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/relative_position_type_enum.rb =====
# frozen_string_literal: true

module Types
  class RelativePositionTypeEnum < BaseEnum
    graphql_name 'RelativePositionType'
    description 'The position to which the object should be moved'

    value 'BEFORE', 'Object is moved before an adjacent object.'
    value 'AFTER', 'Object is moved after an adjacent object.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_asset_link_input_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseAssetLinkInputType < BaseInputObject
    graphql_name 'ReleaseAssetLinkInput'
    description 'Fields that are available when modifying a release asset link'

    include Types::ReleaseAssetLinkSharedInputArguments
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_asset_link_shared_input_arguments.rb =====
# frozen_string_literal: true

module Types
  module ReleaseAssetLinkSharedInputArguments
    extend ActiveSupport::Concern

    included do
      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Name of the asset link.'

      argument :url, GraphQL::Types::String,
        required: true,
        description: 'URL of the asset link.'

      argument :direct_asset_path, GraphQL::Types::String,
        required: false, as: :filepath,
        description: 'Relative path for a direct asset link.'

      argument :link_type, Types::ReleaseAssetLinkTypeEnum,
        required: false, default_value: 'other',
        description: 'Type of the asset link.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_asset_link_type_enum.rb =====
# frozen_string_literal: true

module Types
  class ReleaseAssetLinkTypeEnum < BaseEnum
    graphql_name 'ReleaseAssetLinkType'
    description 'Type of the link: `other`, `runbook`, `image`, `package`'

    ::Releases::Link.link_types.keys.each do |link_type|
      value link_type.upcase, value: link_type, description: "#{link_type.titleize} link type"
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_asset_link_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseAssetLinkType < BaseObject
    graphql_name 'ReleaseAssetLink'
    description 'Represents an asset link associated with a release'

    authorize :read_release

    present_using Releases::LinkPresenter

    field :id, GraphQL::Types::ID, null: false,
      description: 'ID of the link.'
    field :link_type,
      Types::ReleaseAssetLinkTypeEnum,
      null: true,
      description: 'Type of the link: `other`, `runbook`, `image`, `package`; defaults to `other`.'
    field :name, GraphQL::Types::String, null: true,
      description: 'Name of the link.'
    field :url, GraphQL::Types::String, null: true,
      description: 'URL of the link.'

    field :direct_asset_path, GraphQL::Types::String, null: true, method: :filepath,
      description: 'Relative path for the direct asset link.'
    field :direct_asset_url, GraphQL::Types::String, null: true,
      description: 'Direct asset URL of the link.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_assets_input_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseAssetsInputType < BaseInputObject
    graphql_name 'ReleaseAssetsInput'
    description 'Fields that are available when modifying release assets'

    argument :links, [Types::ReleaseAssetLinkInputType],
      required: false,
      description: 'List of asset links to associate to the release.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_assets_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseAssetsType < BaseObject
    graphql_name 'ReleaseAssets'
    description 'A container for all assets associated with a release'

    authorize :read_release

    alias_method :release, :object

    present_using ReleasePresenter

    field :count, GraphQL::Types::Int, null: true, method: :assets_count,
      description: 'Number of assets of the release.'
    field :links, Types::ReleaseAssetLinkType.connection_type, null: true, method: :sorted_links,
      description: 'Asset links of the release.'
    field :sources, Types::ReleaseSourceType.connection_type, null: true,
      description: 'Sources of the release.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_links_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseLinksType < BaseObject
    graphql_name 'ReleaseLinks'

    authorize :read_release

    alias_method :release, :object

    present_using ReleasePresenter

    field :closed_issues_url,
      GraphQL::Types::String,
      null: true,
      description: 'HTTP URL of the issues page, filtered by the release and `state=closed`.',
      authorize: :read_code
    field :closed_merge_requests_url,
      GraphQL::Types::String,
      null: true,
      description: 'HTTP URL of the merge request page, filtered by the release and `state=closed`.',
      authorize: :read_code
    field :edit_url, GraphQL::Types::String, null: true,
      description: "HTTP URL of the release's edit page.",
      authorize: :update_release
    field :merged_merge_requests_url,
      GraphQL::Types::String,
      null: true,
      description: 'HTTP URL of the merge request page, filtered by the release and `state=merged`.',
      authorize: :read_code
    field :opened_issues_url,
      GraphQL::Types::String,
      null: true,
      description: 'HTTP URL of the issues page, filtered by the release and `state=open`.',
      authorize: :read_code
    field :opened_merge_requests_url,
      GraphQL::Types::String,
      null: true,
      description: 'HTTP URL of the merge request page, filtered by the release and `state=open`.',
      authorize: :read_code
    field :self_url, GraphQL::Types::String, null: true,
      description: 'HTTP URL of the release.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_sort_enum.rb =====
# frozen_string_literal: true

module Types
  # Not inheriting from Types::SortEnum since we only want
  # to implement a subset of the sort values it defines.
  class ReleaseSortEnum < BaseEnum
    graphql_name 'ReleaseSort'
    description 'Values for sorting releases'

    # Borrowed from Types::SortEnum
    # These values/descriptions should stay in-sync as much as possible.
    value 'CREATED_DESC', 'Created at descending order.', value: :created_desc
    value 'CREATED_ASC', 'Created at ascending order.', value: :created_asc

    value 'RELEASED_AT_DESC', 'Released at by descending order.', value: :released_at_desc
    value 'RELEASED_AT_ASC', 'Released at by ascending order.', value: :released_at_asc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_source_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseSourceType < BaseObject
    graphql_name 'ReleaseSource'
    description 'Represents the source code attached to a release in a particular format'

    authorize :read_code

    field :format, GraphQL::Types::String, null: true,
      description: 'Format of the source.'
    field :url, GraphQL::Types::String, null: true,
      description: 'Download URL of the source.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_tag_wildcard_id_enum.rb =====
# frozen_string_literal: true

module Types
  class ReleaseTagWildcardIdEnum < BaseEnum
    graphql_name 'ReleaseTagWildcardId'
    description 'Release tag ID wildcard values'

    value 'NONE', 'No release tag is assigned.'
    value 'ANY', 'Release tag is assigned.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/release_type.rb =====
# frozen_string_literal: true

module Types
  class ReleaseType < BaseObject
    graphql_name 'Release'
    description 'Represents a release'

    connection_type_class Types::CountableConnectionType

    authorize :read_release

    alias_method :release, :object

    present_using ReleasePresenter

    field :assets, Types::ReleaseAssetsType, null: true, method: :itself,
      description: 'Assets of the release.'
    field :created_at, Types::TimeType, null: true,
      description: 'Timestamp of when the release was created.'
    field :description,
      GraphQL::Types::String,
      null: true,
      description: 'Description (also known as "release notes") of the release.'
    field :evidences, Types::EvidenceType.connection_type, null: true,
      description: 'Evidence for the release.'
    field :historical_release, GraphQL::Types::Boolean, null: true, method: :historical_release?,
      description: 'Indicates the release is a historical release.'
    field :id, ::Types::GlobalIDType[Release],
      null: false,
      description: 'Global ID of the release.'
    field :links, Types::ReleaseLinksType, null: true, method: :itself,
      description: 'Links of the release.'
    field :milestones, Types::MilestoneType.connection_type, null: true,
      description: 'Milestones associated to the release.',
      resolver: ::Resolvers::ReleaseMilestonesResolver
    field :name, GraphQL::Types::String, null: true,
      description: 'Name of the release.'
    field :released_at, Types::TimeType, null: true,
      description: 'Timestamp of when the release was released.'
    field :tag_name, GraphQL::Types::String, null: true, method: :tag,
      description: 'Name of the tag associated with the release.'
    field :tag_path, GraphQL::Types::String, null: true,
      description: 'Relative web path to the tag associated with the release.',
      authorize: :read_code
    field :upcoming_release, GraphQL::Types::Boolean, null: true, method: :upcoming_release?,
      description: 'Indicates the release is an upcoming release.'

    field :author, Types::UserType, null: true,
      description: 'User that created the release.'

    field :commit, Types::Repositories::CommitType, null: true,
      complexity: 10, calls_gitaly: true,
      description: 'Commit associated with the release.'

    markdown_field :description_html, null: true

    def author
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, release.author_id).find
    end

    def commit
      return if release.sha.nil?

      release.project.commit_by(oid: release.sha)
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/repositories/commit_type.rb =====
# frozen_string_literal: true

module Types
  module Repositories
    class CommitType < BaseObject
      graphql_name 'Commit'

      authorize :read_code

      present_using CommitPresenter

      implements Types::TodoableInterface

      field :id, type: GraphQL::Types::ID, null: false,
        description: 'ID (global ID) of the commit.'

      field :sha, type: GraphQL::Types::String, null: false,
        description: 'SHA1 ID of the commit.'

      field :short_id, type: GraphQL::Types::String, null: false,
        description: 'Short SHA1 ID of the commit.'

      field :title, type: GraphQL::Types::String, null: true, calls_gitaly: true,
        description: 'Title of the commit message.'

      field :full_title, type: GraphQL::Types::String, null: true, calls_gitaly: true,
        description: 'Full title of the commit message.'

      field :description, type: GraphQL::Types::String, null: true,
        description: 'Description of the commit message.'

      field :message, type: GraphQL::Types::String, null: true,
        description: 'Raw commit message.'

      field :authored_date, type: Types::TimeType, null: true,
        description: 'Timestamp of when the commit was authored.'

      field :committed_date, type: Types::TimeType, null: true,
        description: 'Timestamp of when the commit was committed.'

      field :web_url, type: GraphQL::Types::String, null: false,
        description: 'Web URL of the commit.'

      field :web_path, type: GraphQL::Types::String, null: false,
        description: 'Web path of the commit.'

      field :signature, type: Types::CommitSignatureInterface,
        null: true,
        calls_gitaly: true,
        description: 'Signature of the commit.'

      field :signature_html, type: GraphQL::Types::String, null: true, calls_gitaly: true,
        description: 'Rendered HTML of the commit signature.'

      field :author_email, type: GraphQL::Types::String, null: true,
        description: "Commit author's email."
      field :author_gravatar, type: GraphQL::Types::String, null: true,
        description: 'Commit authors gravatar.'
      field :author_name, type: GraphQL::Types::String, null: true,
        description: 'Commit authors name.'

      field :committer_email, type: GraphQL::Types::String, null: true,
        description: "Email of the committer."

      field :committer_name, type: GraphQL::Types::String, null: true,
        description: "Name of the committer."

      # models/commit lazy loads the author by email
      field :author, type: Types::UserType, null: true,
        description: 'Author of the commit.'

      field :diffs, [Types::DiffType], null: true, calls_gitaly: true,
        description: 'Diffs contained within the commit. ' \
          'This field can only be resolved for 10 diffs in any single request.' do
        # Limited to 10 calls per GraphQL request as calling `diffs` multiple times will
        # lead to N+1 queries to Gitaly.
        extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 10
      end

      field :pipelines,
        null: true,
        description: 'Pipelines of the commit ordered latest first.',
        resolver: Resolvers::CommitPipelinesResolver

      markdown_field :title_html, null: true
      markdown_field :full_title_html, null: true
      markdown_field :description_html, null: true

      def diffs
        object.diffs.diffs
      end

      def author_gravatar
        GravatarService.new.execute(object.author_email, 40)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/repositories/tag_type.rb =====
# frozen_string_literal: true

module Types
  module Repositories
    class TagType < BaseObject
      graphql_name 'Tag'

      authorize :read_code

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the tag.'

      field :message,
        GraphQL::Types::String,
        null: true,
        description: 'Tagging message.'

      field :commit, Types::Repositories::CommitType,
        null: true, resolver: Resolvers::Repositories::RefCommitResolver,
        description: 'Commit for the tag.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/repository/blob_type.rb =====
# frozen_string_literal: true

module Types
  module Repository
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `Repository` that has its own authorization
    class BlobType < BaseObject
      graphql_name 'RepositoryBlob'

      present_using BlobPresenter

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the blob.'

      field :oid, GraphQL::Types::String, null: false, method: :id,
        description: 'OID of the blob.'

      field :path, GraphQL::Types::String, null: false,
        description: 'Path of the blob.'

      field :name, GraphQL::Types::String,
        description: 'Blob name.',
        null: true

      field :mode, type: GraphQL::Types::String,
        description: 'Blob mode.',
        null: true

      field :lfs_oid, GraphQL::Types::String, null: true,
        calls_gitaly: true,
        description: 'LFS OID of the blob.'

      field :web_path, GraphQL::Types::String, null: true,
        description: 'Web path of the blob.'

      field :ide_edit_path, GraphQL::Types::String, null: true,
        description: 'Web path to edit the blob in the Web IDE.'

      field :fork_and_edit_path, GraphQL::Types::String, null: true,
        description: 'Web path to edit the blob using a forked project.'

      field :ide_fork_and_edit_path, GraphQL::Types::String, null: true,
        description: 'Web path to edit the blob in the Web IDE using a forked project.'

      field :fork_and_view_path, GraphQL::Types::String, null: true,
        description: 'Web path to view the blob using a forked project.'

      field :size, GraphQL::Types::BigInt, null: true,
        description: 'Size (in bytes) of the blob.'

      field :raw_size, GraphQL::Types::BigInt, null: true,
        description: 'Size (in bytes) of the blob, or the blob target if stored externally.'

      field :raw_blob, GraphQL::Types::String, null: true, method: :data,
        description: 'Raw content of the blob.'

      field :base64_encoded_blob, GraphQL::Types::String, null: true,
        experiment: { milestone: '17.1' }, description: 'Content of blob is encoded base64. Returns `null` if the `unicode_escaped_data` feature flag is disabled.'

      field :raw_text_blob, GraphQL::Types::String, null: true, method: :text_only_data,
        description: 'Raw content of the blob, if the blob is text data.'

      field :stored_externally, GraphQL::Types::Boolean, null: true, method: :stored_externally?,
        description: "Whether the blob's content is stored externally (for instance, in LFS)."

      field :external_storage, GraphQL::Types::String, null: true,
        description: "External storage being used, if enabled (for instance, 'LFS')."

      field :edit_blob_path, GraphQL::Types::String, null: true,
        description: 'Web path to edit the blob in the old-style editor.'

      field :raw_path, GraphQL::Types::String, null: true,
        description: 'Web path to download the raw blob.'

      field :external_storage_url, GraphQL::Types::String, null: true,
        description: 'Web path to download the raw blob via external storage, if enabled.'

      field :replace_path, GraphQL::Types::String, null: true,
        description: 'Web path to replace the blob content.'

      field :pipeline_editor_path, GraphQL::Types::String, null: true,
        description: 'Web path to edit .gitlab-ci.yml file.'

      field :gitpod_blob_url, GraphQL::Types::String, null: true,
        description: 'URL to the blob within Gitpod.'

      field :find_file_path, GraphQL::Types::String, null: true,
        description: 'Web path to find file.'

      field :blame_path, GraphQL::Types::String, null: true,
        description: 'Web path to blob blame page.'

      field :blame, Types::Blame::BlameType, null: true,
        description: 'Blob blame.', experiment: { milestone: '16.3' }, resolver: Resolvers::BlameResolver

      field :history_path, GraphQL::Types::String, null: true,
        description: 'Web path to blob history page.'

      field :permalink_path, GraphQL::Types::String, null: true,
        description: 'Web path to blob permalink.',
        calls_gitaly: true

      field :environment_formatted_external_url, GraphQL::Types::String, null: true,
        description: 'Environment on which the blob is available.',
        calls_gitaly: true

      field :environment_external_url_for_route_map, GraphQL::Types::String, null: true,
        description: 'Web path to blob on an environment.',
        calls_gitaly: true

      field :file_type, GraphQL::Types::String, null: true,
        description: 'Expected format of the blob based on the extension.'

      field :simple_viewer, type: Types::BlobViewerType,
        description: 'Blob content simple viewer.',
        null: false

      field :rich_viewer, type: Types::BlobViewerType,
        description: 'Blob content rich viewer.',
        null: true

      field :plain_data, GraphQL::Types::String,
        description: 'Blob plain highlighted data.',
        null: true,
        calls_gitaly: true

      field :can_modify_blob, GraphQL::Types::Boolean, null: true, method: :can_modify_blob?,
        calls_gitaly: true,
        description: 'Whether the current user can modify the blob.'

      field :can_modify_blob_with_web_ide, GraphQL::Types::Boolean, null: false, method: :can_modify_blob_with_web_ide?,
        description: 'Whether the current user can modify the blob with Web IDE.'

      field :can_current_user_push_to_branch, GraphQL::Types::Boolean, null: true, method: :can_current_user_push_to_branch?,
        description: 'Whether the current user can push to the branch.'

      field :archived, GraphQL::Types::Boolean, null: true, method: :archived?,
        description: 'Whether the current project is archived.'

      field :language, GraphQL::Types::String,
        description: 'Blob language.',
        method: :blob_language,
        null: true,
        calls_gitaly: true

      field :code_navigation_path, GraphQL::Types::String, null: true, calls_gitaly: true,
        description: 'Web path for code navigation.'

      field :project_blob_path_root, GraphQL::Types::String, null: true,
        description: 'Web path for the root of the blob.'

      def raw_text_blob
        object.data unless object.binary?
      end

      def lfs_oid
        Gitlab::Graphql::Loaders::BatchLfsOidLoader.new(object.repository, object.id).find
      end
    end
  end
end

Types::Repository::BlobType.prepend_mod_with('Types::Repository::BlobType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/repository_type.rb =====
# frozen_string_literal: true

module Types
  class RepositoryType < BaseObject
    graphql_name 'Repository'

    authorize :read_code

    field :blobs, Types::Repository::BlobType.connection_type, null: true, resolver: Resolvers::BlobsResolver, calls_gitaly: true,
      description: 'Blobs contained within the repository'
    field :branch_names, [GraphQL::Types::String], null: true, calls_gitaly: true,
      complexity: 170, description: 'Names of branches available in this repository that match the search pattern.',
      resolver: Resolvers::RepositoryBranchNamesResolver
    field :commit, Types::Repositories::CommitType, null: true,
      calls_gitaly: true,
      description: 'Commit from the repository.',
      resolver: Resolvers::Repositories::CommitResolver
    field :disk_path, GraphQL::Types::String,
      description: 'Shows a disk path of the repository.',
      null: true,
      authorize: :read_storage_disk_path
    field :empty, GraphQL::Types::Boolean, null: false, method: :empty?, calls_gitaly: true,
      description: 'Indicates repository has no visible content.'
    field :exists, GraphQL::Types::Boolean, null: false, method: :exists?, calls_gitaly: true,
      description: 'Indicates a corresponding Git repository exists on disk.'
    field :last_commit, Types::Repositories::CommitType, null: true, resolver: Resolvers::LastCommitResolver, calls_gitaly: true,
      description: 'The last commit made in the repository for the given path and ref.'
    field :paginated_tree, Types::Tree::TreeType.connection_type, null: true, resolver: Resolvers::PaginatedTreeResolver, calls_gitaly: true,
      connection_extension: Gitlab::Graphql::Extensions::ExternallyPaginatedArrayExtension,
      max_page_size: 100,
      description: 'Paginated tree of the repository.'
    field :root_ref, GraphQL::Types::String, null: true, calls_gitaly: true,
      description: 'Default branch of the repository.'
    field :tree, Types::Tree::TreeType, null: true, resolver: Resolvers::TreeResolver, calls_gitaly: true,
      description: 'Tree of the repository.'
  end
end

Types::RepositoryType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/resolvable_interface.rb =====
# frozen_string_literal: true

module Types
  # This Interface contains fields that are shared between objects that include either
  # the `ResolvableNote` or `ResolvableDiscussion` modules.
  module ResolvableInterface
    include Types::BaseInterface

    field :resolved_by, Types::UserType,
      null: true,
      description: 'User who resolved the object.'

    field :resolved, GraphQL::Types::Boolean, null: false,
      description: 'Indicates if the object is resolved.',
      method: :resolved?

    field :resolvable, GraphQL::Types::Boolean, null: false,
      description: 'Indicates if the object can be resolved.',
      method: :resolvable?

    field :resolved_at, Types::TimeType, null: true,
      description: 'Timestamp of when the object was resolved.'

    def resolved_by
      return unless object.resolved_by_id

      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.resolved_by_id).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/reviewer_wildcard_id_enum.rb =====
# frozen_string_literal: true

module Types
  class ReviewerWildcardIdEnum < BaseEnum
    graphql_name 'ReviewerWildcardId'
    description 'Reviewer ID wildcard values'

    value 'NONE', 'No reviewer is assigned.'
    value 'ANY', 'Any reviewer is assigned.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/root_storage_statistics_type.rb =====
# frozen_string_literal: true

module Types
  class RootStorageStatisticsType < BaseObject
    graphql_name 'RootStorageStatistics'

    authorize :read_statistics

    field :build_artifacts_size, GraphQL::Types::Float, null: false, description: 'CI artifacts size in bytes.'
    field :container_registry_size, GraphQL::Types::Float, null: false, description: 'Container registry size in bytes.'
    field :container_registry_size_is_estimated, GraphQL::Types::Boolean, method: :registry_size_estimated, null: false,
      description: 'Indicates whether the deduplicated container registry size for ' \
        'the namespace is an estimated value or not.'
    field :dependency_proxy_size, GraphQL::Types::Float, null: false, description: 'Dependency Proxy sizes in bytes.'
    field :lfs_objects_size, GraphQL::Types::Float, null: false, description: 'LFS objects size in bytes.'
    field :packages_size, GraphQL::Types::Float, null: false, description: 'Packages size in bytes.'
    field :pipeline_artifacts_size, GraphQL::Types::Float, null: false,
      description: 'CI pipeline artifacts size in bytes.'
    field :registry_size_estimated, GraphQL::Types::Boolean,
      null: false,
      deprecated: { reason: 'Use `container_registry_size_is_estimated`', milestone: '16.2' },
      description: 'Indicates whether the deduplicated container registry size for ' \
        'the namespace is an estimated value or not.'
    field :repository_size, GraphQL::Types::Float, null: false, description: 'Git repository size in bytes.'
    field :snippets_size, GraphQL::Types::Float, null: false, description: 'Snippets size in bytes.'
    field :storage_size, GraphQL::Types::Float, null: false, description: 'Total storage in bytes.'
    field :uploads_size, GraphQL::Types::Float, null: false, description: 'Uploads size in bytes.'
    field :wiki_size, GraphQL::Types::Float, null: false, description: 'Wiki size in bytes.'
  end
end

Types::RootStorageStatisticsType.prepend_mod_with('Types::RootStorageStatisticsType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/saved_reply_type.rb =====
# frozen_string_literal: true

module Types
  class SavedReplyType < BaseObject
    connection_type_class Types::CountableConnectionType

    authorize :read_saved_replies

    field :content, GraphQL::Types::String,
      null: false,
      description: 'Content of the saved reply.'

    field :name, GraphQL::Types::String,
      null: false,
      description: 'Name of the saved reply.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/codequality_reports_comparer/degradation_type.rb =====
# frozen_string_literal: true

module Types
  module Security
    module CodequalityReportsComparer
      # rubocop: disable Graphql/AuthorizeTypes -- The resolver authorizes the request
      class DegradationType < BaseObject
        graphql_name 'CodequalityReportsComparerReportDegradation'
        description 'Represents a degradation on the compared codequality report.'

        field :description, GraphQL::Types::String,
          null: false,
          description: 'Description of the code quality degradation.'

        field :fingerprint, GraphQL::Types::String,
          null: false,
          description: 'Unique fingerprint to identify the code quality degradation. For example, an MD5 hash.'

        field :severity, Types::Ci::CodeQualityDegradationSeverityEnum,
          null: false,
          description:
            "Severity of the code quality degradation " \
            "(#{::Gitlab::Ci::Reports::CodequalityReports::SEVERITY_PRIORITIES.keys.map(&:upcase).join(', ')})."

        field :file_path, GraphQL::Types::String,
          null: false,
          description: 'Relative path to the file containing the code quality degradation.'

        field :line, GraphQL::Types::Int,
          null: false,
          description: 'Line on which the code quality degradation occurred.'

        field :web_url, GraphQL::Types::String,
          null: true,
          description: 'URL to the file along with line number.'

        field :engine_name, GraphQL::Types::String,
          null: true,
          description: 'Code quality plugin that reported the degradation.'
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/codequality_reports_comparer/report_generation_status_enum.rb =====
# frozen_string_literal: true

module Types
  module Security
    module CodequalityReportsComparer
      class ReportGenerationStatusEnum < BaseEnum
        graphql_name 'CodequalityReportsComparerReportGenerationStatus'
        description 'Represents the generation status of the compared codequality report.'

        value 'PARSED', value: :parsed, description: 'Report was generated.'
        value 'PARSING', value: :parsing, description: 'Report is being generated.'
        value 'ERROR', value: :error, description: 'An error happened while generating the report.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/codequality_reports_comparer/report_type.rb =====
# frozen_string_literal: true

module Types
  module Security
    module CodequalityReportsComparer
      # rubocop: disable Graphql/AuthorizeTypes -- Parent node applies authorization
      class ReportType < BaseObject
        graphql_name 'CodequalityReportsComparerReport'

        description 'Represents compared code quality report.'

        field :status,
          type: CodequalityReportsComparer::StatusEnum,
          null: false,
          description: 'Status of report.'

        field :new_errors,
          type: [CodequalityReportsComparer::DegradationType],
          null: false,
          description: 'New code quality degradations.'

        field :resolved_errors,
          type: [CodequalityReportsComparer::DegradationType],
          null: true,
          description: 'Resolved code quality degradations.'

        field :existing_errors,
          type: [CodequalityReportsComparer::DegradationType],
          null: true,
          description: 'All code quality degradations.'

        field :summary,
          type: CodequalityReportsComparer::SummaryType,
          null: false,
          description: 'Codequality report summary.'
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/codequality_reports_comparer/status_enum.rb =====
# frozen_string_literal: true

module Types
  module Security
    module CodequalityReportsComparer
      class StatusEnum < BaseEnum
        graphql_name 'CodequalityReportsComparerStatus'
        description 'Represents the state of the code quality report.'

        value 'SUCCESS', value: 'success', description: 'No degradations found in the head pipeline report.'
        value 'FAILED', value: 'failed', description: 'Report generated and there are new code quality degradations.'
        value 'NOT_FOUND', value: 'not_found', description: 'Head report or base report not found.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/codequality_reports_comparer/summary_type.rb =====
# frozen_string_literal: true

module Types
  module Security
    module CodequalityReportsComparer
      # rubocop: disable Graphql/AuthorizeTypes -- The resolver authorizes the request
      class SummaryType < BaseObject
        graphql_name 'CodequalityReportsComparerReportSummary'

        description 'Represents a summary of the compared codequality report.'

        field :total,
          type: GraphQL::Types::Int,
          null: true,
          description: 'Total count of code quality degradations.'

        field :resolved,
          type: GraphQL::Types::Int,
          null: true,
          description: 'Count of resolved code quality degradations.'

        field :errored,
          type: GraphQL::Types::Int,
          null: true,
          description: 'Count of code quality errors.'
      end
      # rubocop: enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/codequality_reports_comparer_type.rb =====
# frozen_string_literal: true

module Types
  module Security
    # rubocop: disable Graphql/AuthorizeTypes -- The resolver authorizes the request
    class CodequalityReportsComparerType < BaseObject
      graphql_name 'CodequalityReportsComparer'

      description 'Represents reports comparison for code quality.'

      field :status,
        type: CodequalityReportsComparer::ReportGenerationStatusEnum,
        null: true,
        description: 'Compared codequality report generation status.'

      field :report,
        type: CodequalityReportsComparer::ReportType,
        null: true,
        hash_key: :data,
        description: 'Compared codequality report.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/preferred_license_source_configuration_enum.rb =====
# frozen_string_literal: true

module Types
  module Security
    class PreferredLicenseSourceConfigurationEnum < BaseEnum
      graphql_name 'SecurityPreferredLicenseSourceConfiguration'

      value 'SBOM',
        value: 'sbom',
        description: 'Use the SBOM as a source of license information for dependencies.'

      value 'PMDB',
        value: 'pmdb',
        description: 'Use internal instance license database as a source of license information for dependencies.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/security/report_type_enum.rb =====
# frozen_string_literal: true

module Types
  module Security
    class ReportTypeEnum < BaseEnum
      graphql_name 'SecurityReportTypeEnum'

      ::Security::SecurityJobsFinder.allowed_job_types.each do |report_type|
        value report_type.upcase,
          value: report_type,
          description: "#{report_type.upcase.to_s.tr('_', ' ')} scan report"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/sha_format_enum.rb =====
# frozen_string_literal: true

module Types
  class ShaFormatEnum < BaseEnum
    graphql_name 'ShaFormat'
    description 'How to format SHA strings.'

    FORMATS_DESCRIPTION = {
      short: 'Abbreviated format. Short SHAs are typically eight characters long.',
      long: 'Unabbreviated format.'
    }.freeze

    FORMATS_DESCRIPTION.each do |format, description|
      value format.to_s.upcase,
        description: description,
        value: format.to_s
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/blob_action_enum.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    class BlobActionEnum < BaseEnum
      graphql_name 'SnippetBlobActionEnum'
      description 'Type of a snippet blob input action'

      value 'create', description: 'Create a snippet blob.', value: :create
      value 'update', description: 'Update a snippet blob.', value: :update
      value 'delete', description: 'Delete a snippet blob.', value: :delete
      value 'move', description: 'Move a snippet blob.', value: :move
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/blob_action_input_type.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    class BlobActionInputType < BaseInputObject
      graphql_name 'SnippetBlobActionInputType'
      description 'Represents an action to perform over a snippet file'

      argument :action, Types::Snippets::BlobActionEnum,
        description: 'Type of input action.',
        required: true

      argument :previous_path, GraphQL::Types::String,
        description: 'Previous path of the snippet file.',
        required: false

      argument :file_path, GraphQL::Types::String,
        description: 'Path of the snippet file.',
        required: true

      argument :content, GraphQL::Types::String,
        description: 'Snippet file content.',
        required: false
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/blob_connection_type.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    # rubocop: disable Graphql/AuthorizeTypes
    class BlobConnectionType < GraphQL::Types::Relay::BaseConnection
      field :has_unretrievable_blobs,
        GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates if the snippet has unretrievable blobs.',
        resolver_method: :unretrievable_blobs?

      def unretrievable_blobs?
        !!context[:unretrievable_blobs?]
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/blob_type.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    # rubocop: disable Graphql/AuthorizeTypes
    class BlobType < BaseObject
      graphql_name 'SnippetBlob'
      description 'Represents the snippet blob'
      present_using SnippetBlobPresenter

      connection_type_class Types::Snippets::BlobConnectionType

      field :rich_data, GraphQL::Types::String,
        description: 'Blob highlighted data.',
        null: true

      field :plain_data, GraphQL::Types::String,
        description: 'Blob plain highlighted data.',
        null: true

      field :raw_plain_data, GraphQL::Types::String,
        description: 'Raw content of the blob, if the blob is text data.',
        null: true

      field :raw_path, GraphQL::Types::String,
        description: 'Blob raw content endpoint path.',
        null: false

      field :size, GraphQL::Types::Int,
        description: 'Blob size.',
        null: false

      field :binary, GraphQL::Types::Boolean,
        description: 'Shows whether the blob is binary.',
        method: :binary?,
        null: false

      field :name, GraphQL::Types::String,
        description: 'Blob name.',
        null: true

      field :path, GraphQL::Types::String,
        description: 'Blob path.',
        null: true

      field :simple_viewer, type: Types::Snippets::BlobViewerType,
        description: 'Blob content simple viewer.',
        null: false

      field :rich_viewer, type: Types::Snippets::BlobViewerType,
        description: 'Blob content rich viewer.',
        null: true

      field :mode, type: GraphQL::Types::String,
        description: 'Blob mode.',
        null: true

      field :external_storage, type: GraphQL::Types::String,
        description: 'Blob external storage.',
        null: true

      field :rendered_as_text, type: GraphQL::Types::Boolean,
        description: 'Shows whether the blob is rendered as text.',
        method: :rendered_as_text?,
        null: false
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/blob_viewer_type.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    # Kept to avoid changing the type of existing fields. New fields should use
    # ::Types::BlobViewerType directly
    class BlobViewerType < ::Types::BlobViewerType # rubocop:disable Graphql/AuthorizeTypes
      graphql_name 'SnippetBlobViewer'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/type_enum.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    class TypeEnum < BaseEnum
      value 'personal', description: 'Snippet created independent of any project.', value: 'personal'
      value 'project', description: 'Snippet related to a specific project.', value: 'project'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippets/visibility_scopes_enum.rb =====
# frozen_string_literal: true

module Types
  module Snippets
    class VisibilityScopesEnum < BaseEnum
      value 'private', description: 'Snippet is visible only to the snippet creator.', value: 'are_private'
      value 'internal', description: 'Snippet is visible for any logged in user except external users.', value: 'are_internal'
      value 'public', description: 'Snippet can be accessed without any authentication.', value: 'are_public'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/snippet_type.rb =====
# frozen_string_literal: true

module Types
  class SnippetType < BaseObject
    graphql_name 'Snippet'
    description 'Represents a snippet entry'

    implements Types::Notes::NoteableInterface

    present_using SnippetPresenter

    authorize :read_snippet

    expose_permissions Types::PermissionTypes::Snippet

    field :id, Types::GlobalIDType[::Snippet],
      description: 'ID of the snippet.',
      null: false

    field :title, GraphQL::Types::String,
      description: 'Title of the snippet.',
      null: false

    field :project, Types::ProjectType,
      description: 'Project the snippet is associated with.',
      null: true,
      authorize: :read_project

    # Author can be nil in some scenarios. For example,
    # when the admin setting restricted visibility
    # level is set to public
    field :author, Types::UserType,
      description: 'Owner of the snippet.',
      null: true

    field :file_name, GraphQL::Types::String,
      description: 'File Name of the snippet.',
      null: true

    field :description, GraphQL::Types::String,
      description: 'Description of the snippet.',
      null: true

    field :visibility_level, Types::VisibilityLevelsEnum,
      description: 'Visibility Level of the snippet.',
      null: false

    field :hidden, GraphQL::Types::Boolean,
      description: 'Indicates the snippet is hidden because the author has been banned.',
      null: false,
      method: :hidden_due_to_author_ban?

    field :created_at, Types::TimeType,
      description: 'Timestamp the snippet was created.',
      null: false

    field :updated_at, Types::TimeType,
      description: 'Timestamp the snippet was updated.',
      null: false

    field :web_url, type: GraphQL::Types::String,
      description: 'Web URL of the snippet.',
      null: false

    field :raw_url, type: GraphQL::Types::String,
      description: 'Raw URL of the snippet.',
      null: false

    field :blobs, type: Types::Snippets::BlobType.connection_type,
      description: 'Snippet blobs.',
      calls_gitaly: true,
      null: true,
      resolver: Resolvers::Snippets::BlobsResolver

    field :ssh_url_to_repo, type: GraphQL::Types::String,
      description: 'SSH URL to the snippet repository.',
      calls_gitaly: true,
      null: true

    field :http_url_to_repo, type: GraphQL::Types::String,
      description: 'HTTP URL to the snippet repository.',
      calls_gitaly: true,
      null: true

    field :imported, type: GraphQL::Types::Boolean,
      description: 'Indicates whether the snippet was imported.',
      null: false, method: :imported?

    field :imported_from,
      Types::Import::ImportSourceEnum,
      null: false,
      description: 'Import source of the snippet.'

    markdown_field :description_html, null: true, method: :description

    def author
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.author_id).find
    end

    def project
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/sort_direction_enum.rb =====
# frozen_string_literal: true

module Types
  class SortDirectionEnum < BaseEnum
    graphql_name 'SortDirectionEnum'
    description 'Values for sort direction'

    value 'ASC', 'Ascending order.', value: 'asc'
    value 'DESC', 'Descending order.', value: 'desc'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/sort_enum.rb =====
# frozen_string_literal: true

module Types
  class SortEnum < BaseEnum
    graphql_name 'Sort'
    description 'Common sort values'

    # Deprecated, as we prefer uppercase enums
    # https://gitlab.com/groups/gitlab-org/-/epics/1838
    value 'updated_desc', 'Updated at descending order.',
      value: :updated_desc,
      deprecated: {
        reason: :renamed,
        replacement: 'UPDATED_DESC',
        milestone: '13.5'
      }
    value 'updated_asc', 'Updated at ascending order.',
      value: :updated_asc,
      deprecated: {
        reason: :renamed,
        replacement: 'UPDATED_ASC',
        milestone: '13.5'
      }
    value 'created_desc', 'Created at descending order.',
      value: :created_desc,
      deprecated: {
        reason: :renamed,
        replacement: 'CREATED_DESC',
        milestone: '13.5'
      }
    value 'created_asc', 'Created at ascending order.',
      value: :created_asc,
      deprecated: {
        reason: :renamed,
        replacement: 'CREATED_ASC',
        milestone: '13.5'
      }

    value 'UPDATED_DESC', 'Updated at descending order.', value: :updated_desc
    value 'UPDATED_ASC', 'Updated at ascending order.', value: :updated_asc
    value 'CREATED_DESC', 'Created at descending order.', value: :created_desc
    value 'CREATED_ASC', 'Created at ascending order.', value: :created_asc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/subscription_type.rb =====
# frozen_string_literal: true

module Types
  class SubscriptionType < ::Types::BaseObject
    graphql_name 'Subscription'

    field :ci_job_status_updated,
      subscription: Subscriptions::Ci::Jobs::StatusUpdated, null: true,
      description: 'Triggered when a job status is updated.'

    field :ci_pipeline_status_updated,
      subscription: Subscriptions::Ci::Pipelines::StatusUpdated, null: true,
      description: 'Triggered when a pipeline status is updated.',
      experiment: { milestone: '17.10' }

    field :issuable_assignees_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the assignees of an issuable are updated.'

    field :issue_crm_contacts_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the crm contacts of an issuable are updated.'

    field :issuable_title_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the title of an issuable is updated.'

    field :issuable_description_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the description of an issuable is updated.'

    field :issuable_labels_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the labels of an issuable are updated.'

    field :issuable_dates_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the due date or start date of an issuable is updated.'

    field :issuable_milestone_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the milestone of an issuable is updated.'

    field :work_item_note_created,
      subscription: ::Subscriptions::Notes::Created, null: true,
      description: 'Triggered when a note is created.',
      experiment: { milestone: '15.9' }

    field :work_item_note_deleted,
      subscription: ::Subscriptions::Notes::Deleted, null: true,
      description: 'Triggered when a note is deleted.',
      experiment: { milestone: '15.9' }

    field :work_item_note_updated,
      subscription: ::Subscriptions::Notes::Updated, null: true,
      description: 'Triggered when a note is updated.',
      experiment: { milestone: '15.9' }

    field :work_item_updated,
      subscription: Subscriptions::WorkItemUpdated,
      null: true,
      description: 'Triggered when a work item is updated.'

    field :merge_request_reviewers_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the reviewers of a merge request are updated.'

    field :merge_request_merge_status_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when the merge status of a merge request is updated.'

    field :merge_request_approval_state_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when approval state of a merge request is updated.'

    field :merge_request_diff_generated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when a merge request diff is generated.'

    field :issuable_todo_updated,
      subscription: Subscriptions::IssuableUpdated, null: true,
      description: 'Triggered when a todo on an issuable is updated.',
      experiment: { milestone: '17.5' }

    field :user_merge_request_updated,
      subscription: Subscriptions::User::MergeRequestUpdated,
      null: true,
      description: 'Triggered when a merge request the user is an assignee or a reviewer of is updated.',
      experiment: { milestone: '17.9' }
  end
end

Types::SubscriptionType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/task_completion_status.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  # This is used in `IssueType` and `MergeRequestType` both of which have their
  # own authorization
  class TaskCompletionStatus < BaseObject
    graphql_name 'TaskCompletionStatus'
    description 'Completion status of tasks'

    field :completed_count, GraphQL::Types::Int, null: false,
      description: 'Number of completed tasks.'
    field :count, GraphQL::Types::Int, null: false,
      description: 'Number of total tasks.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/terraform/state_type.rb =====
# frozen_string_literal: true

module Types
  module Terraform
    class StateType < BaseObject
      graphql_name 'TerraformState'

      authorize :read_terraform_state

      connection_type_class Types::CountableConnectionType

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the Terraform state.'

      field :name, GraphQL::Types::String,
        null: false,
        description: 'Name of the Terraform state.'

      field :locked_by_user, Types::UserType,
        null: true,
        description: 'User currently holding a lock on the Terraform state.'

      field :locked_at, Types::TimeType,
        null: true,
        description: 'Timestamp the Terraform state was locked.'

      field :latest_version, Types::Terraform::StateVersionType,
        complexity: 3,
        null: true,
        description: 'Latest version of the Terraform state.'

      field :created_at, Types::TimeType,
        null: false,
        description: 'Timestamp the Terraform state was created.'

      field :updated_at, Types::TimeType,
        null: false,
        description: 'Timestamp the Terraform state was updated.'

      field :deleted_at, Types::TimeType,
        null: true,
        description: 'Timestamp the Terraform state was deleted.'

      def locked_by_user
        Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.locked_by_user_id).find
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/terraform/state_version_type.rb =====
# frozen_string_literal: true

module Types
  module Terraform
    class StateVersionType < BaseObject
      graphql_name 'TerraformStateVersion'

      include ::API::Helpers::RelatedResourcesHelpers

      authorize :read_terraform_state

      field :id, GraphQL::Types::ID,
        null: false,
        description: 'ID of the Terraform state version.'

      field :created_by_user, Types::UserType,
        null: true,
        description: 'User that created the version.'

      field :download_path, GraphQL::Types::String,
        null: true,
        description: "URL for downloading the version's JSON file."

      field :job, Types::Ci::JobType,
        null: true,
        description: 'Job that created the version.',
        authorize: :read_commit_status

      field :serial, GraphQL::Types::Int,
        null: true,
        description: 'Serial number of the version.',
        method: :version

      field :created_at, Types::TimeType,
        null: false,
        description: 'Timestamp the version was created.'

      field :updated_at, Types::TimeType,
        null: false,
        description: 'Timestamp the version was updated.'

      def created_by_user
        Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.created_by_user_id).find
      end

      def download_path
        expose_path api_v4_projects_terraform_state_versions_path(
          id: object.project_id,
          name: object.terraform_state.name,
          serial: object.version
        )
      end

      def job
        Gitlab::Graphql::Loaders::BatchModelLoader.new(::Ci::Build, object.ci_build_id).find
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/timeframe_input_type.rb =====
# frozen_string_literal: true

module Types
  class TimeframeInputType < RangeInputType[::Types::DateType]
    graphql_name 'Timeframe'
    description 'A time-frame defined as a closed inclusive range of two dates'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/timelog_type.rb =====
# frozen_string_literal: true

module Types
  class TimelogType < BaseObject
    graphql_name 'Timelog'

    connection_type_class Types::TimeTracking::TimelogConnectionType

    authorize :read_issuable

    expose_permissions Types::PermissionTypes::Timelog

    field :id,
      GraphQL::Types::ID,
      null: false,
      description: 'Internal ID of the timelog.'

    field :spent_at,
      Types::TimeType,
      null: true,
      description: 'Timestamp of when the time tracked was spent at.'

    field :time_spent,
      GraphQL::Types::Int,
      null: false,
      description: 'Time spent displayed in seconds.'

    field :user,
      Types::UserType,
      null: false,
      description: 'User that logged the time.'

    field :issue,
      Types::IssueType,
      null: true,
      description: 'Issue that logged time was added to.'

    field :merge_request,
      Types::MergeRequestType,
      null: true,
      description: 'Merge request that logged time was added to.'

    field :note,
      Types::Notes::NoteType,
      null: true,
      description: 'Note where the quick action was executed to add the logged time.'

    field :summary, GraphQL::Types::String,
      null: true,
      description: 'Summary of how the time was spent.'

    field :project, Types::ProjectType,
      null: false,
      description: 'Target project of the timelog merge request or issue.'

    def user
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.user_id, default_value: ::Users::Internal.ghost).find
    end

    def issue
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Issue, object.issue_id).find
    end

    def spent_at
      object.spent_at || object.created_at
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/time_tracking/timelog_category_type.rb =====
# frozen_string_literal: true

module Types
  module TimeTracking
    class TimelogCategoryType < BaseObject
      graphql_name 'TimeTrackingTimelogCategory'

      authorize :read_timelog_category

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'Internal ID of the timelog category.'

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the category.'

      field :description,
        GraphQL::Types::String,
        null: true,
        description: 'Description of the category.'

      field :color,
        Types::ColorType,
        null: true,
        description: 'Color assigned to the category.'

      field :billable,
        GraphQL::Types::Boolean,
        null: true,
        description: 'Whether the category is billable or not.'

      field :billing_rate,
        GraphQL::Types::Float,
        null: true,
        description: 'Billing rate for the category.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'When the category was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'When the category was last updated.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/time_tracking/timelog_connection_type.rb =====
# frozen_string_literal: true

module Types
  module TimeTracking
    # rubocop: disable Graphql/AuthorizeTypes
    class TimelogConnectionType < CountableConnectionType
      field :total_spent_time,
        GraphQL::Types::BigInt,
        null: false,
        description: 'Total time spent in seconds.'

      def total_spent_time
        relation = object.items

        # sometimes relation is an Array
        relation = relation.without_order if relation.respond_to?(:reorder)

        relation.sum(:time_spent)
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/time_tracking/timelog_sort_enum.rb =====
# frozen_string_literal: true

module Types
  module TimeTracking
    class TimelogSortEnum < SortEnum
      graphql_name 'TimelogSort'
      description 'Values for sorting timelogs'

      value 'SPENT_AT_ASC', 'Spent at ascending order.', value: :spent_at_asc
      value 'SPENT_AT_DESC', 'Spent at descending order.', value: :spent_at_desc
      value 'TIME_SPENT_ASC', 'Time spent ascending order.', value: :time_spent_asc
      value 'TIME_SPENT_DESC', 'Time spent descending order.', value: :time_spent_desc
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/time_type.rb =====
# frozen_string_literal: true

module Types
  class TimeType < BaseScalar
    graphql_name 'Time'
    description <<~DESC
      Time represented in ISO 8601.

      For example: "2021-03-09T14:58:50+00:00".

      See `https://www.iso.org/iso-8601-date-and-time-format.html`.
    DESC

    def self.coerce_input(value, ctx)
      # arguments can be nil, so don't raise an error
      return if value.nil?

      Time.parse(value)
    rescue ArgumentError, TypeError => e
      raise GraphQL::CoercionError, e.message
    end

    def self.coerce_result(value, ctx)
      value.iso8601
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/todoable_interface.rb =====
# frozen_string_literal: true

module Types
  module TodoableInterface
    include Types::BaseInterface

    graphql_name 'Todoable'

    field :web_url,
      GraphQL::Types::String,
      null: true,
      description: 'URL of the object.'

    field :name,
      GraphQL::Types::String,
      null: true,
      description: 'Name or title of the object.'

    def self.resolve_type(object, context)
      case object
      when User
        Types::UserType
      when WorkItem
        Types::WorkItemType
      when Issue
        Types::IssueType
      when MergeRequest
        Types::MergeRequestType
      when ::DesignManagement::Design
        Types::DesignManagement::DesignType
      when ::AlertManagement::Alert
        Types::AlertManagement::AlertType
      when Commit
        Types::Repositories::CommitType
      when Project
        Types::ProjectType
      when Group
        Types::GroupType
      when Key # SSH key
        Types::KeyType
      when WikiPage::Meta
        Types::Wikis::WikiPageType
      else
        raise "Unknown GraphQL type for #{object}"
      end
    end

    def name
      object.try(:name) || object.try(:title)
    end
  end
end

Types::TodoableInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/todo_action_enum.rb =====
# frozen_string_literal: true

module Types
  class TodoActionEnum < BaseEnum
    Todo.action_names.each do |value, action_name|
      value action_name.to_s, value: value, description: "Todo action name for #{action_name}."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/todo_sort_enum.rb =====
# frozen_string_literal: true

module Types
  class TodoSortEnum < SortEnum
    graphql_name 'TodoSort'
    description 'Sort options for todos.'

    value 'LABEL_PRIORITY_ASC', 'By label priority in ascending order.', value: :label_priority_asc
    value 'LABEL_PRIORITY_DESC', 'By label priority in descending order.', value: :label_priority_desc
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/todo_state_enum.rb =====
# frozen_string_literal: true

module Types
  class TodoStateEnum < BaseEnum
    value 'pending', description: "State of the todo is pending."
    value 'done', description: "State of the todo is done."
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/todo_target_enum.rb =====
# frozen_string_literal: true

module Types
  class TodoTargetEnum < BaseEnum
    value 'COMMIT', value: 'Commit', description: 'Commit.'
    value 'ISSUE', value: 'Issue', description: 'Issue.'
    value 'WORKITEM', value: 'WorkItem', description: 'Work item.'
    value 'MERGEREQUEST', value: 'MergeRequest', description: 'Merge request.'
    value 'DESIGN', value: 'DesignManagement::Design', description: 'Design.'
    value 'ALERT', value: 'AlertManagement::Alert', description: 'Alert.'
    value 'PROJECT', value: 'Project', description: 'Project.'
    value 'NAMESPACE', value: 'Namespace', description: 'Namespace.'
    value 'KEY', value: 'Key', description: 'SSH key.'
    value 'WIKIPAGEMETA', value: 'WikiPage::Meta', description: 'Wiki page.'
  end
end

Types::TodoTargetEnum.prepend_mod_with('Types::TodoTargetEnum')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/todo_type.rb =====
# frozen_string_literal: true

module Types
  class TodoType < BaseObject
    graphql_name 'Todo'
    description 'Representing a to-do entry'

    connection_type_class Types::CountableConnectionType

    present_using TodoPresenter

    authorize :read_todo

    field :id, GraphQL::Types::ID,
      description: 'ID of the to-do item.',
      null: false

    field :project, Types::ProjectType,
      description: 'Project the to-do item is associated with.',
      null: true

    field :group, 'Types::GroupType',
      description: 'Group the to-do item is associated with.',
      null: true

    field :author, Types::UserType,
      description: 'Author of the to-do item.',
      null: false

    field :action, Types::TodoActionEnum,
      description: 'Action of the to-do item.',
      null: false

    field :target, Types::TodoableInterface,
      description: 'Target of the to-do item.',
      calls_gitaly: true,
      deprecated: { reason: 'Use `target_entity` field', milestone: '17.4' },
      null: false

    field :target_entity, Types::TodoableInterface,
      description: 'Target of the to-do item.',
      calls_gitaly: true,
      null: true

    field :target_type, Types::TodoTargetEnum,
      description: 'Target type of the to-do item.',
      null: false

    field :target_url, GraphQL::Types::String, # rubocop:disable GraphQL/ExtractType -- Target already exists
      description: 'URL of the to-do item target.',
      null: true

    field :body, GraphQL::Types::String,
      description: 'Body of the to-do item.',
      null: false,
      calls_gitaly: true # TODO This is only true when `target_type` is `Commit`. See https://gitlab.com/gitlab-org/gitlab/issues/34757#note_234752665

    field :state, Types::TodoStateEnum,
      description: 'State of the to-do item.',
      null: false

    field :created_at, Types::TimeType,
      description: 'Timestamp the to-do item was created.',
      null: false

    field :note, Types::Notes::NoteType,
      description: 'Note which created the to-do item.',
      null: true

    field :member_access_type, GraphQL::Types::String,
      description: 'Access type of access request to-do items.',
      null: true

    field :snoozed_until, Types::TimeType,
      description: 'Time until when the todo is snoozed.',
      null: true

    def project
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Project, object.project_id).find
    end

    def group
      Gitlab::Graphql::Loaders::BatchModelLoader.new(Group, object.group_id).find
    end

    def author
      Gitlab::Graphql::Loaders::BatchModelLoader.new(User, object.author_id).find
    end

    def target
      target_entity
    end

    def target_entity
      if object.for_commit?
        Gitlab::Graphql::Loaders::BatchCommitLoader.new(
          container_class: Project,
          container_id: object.project_id,
          oid: object.commit_id
        ).find
      else
        Gitlab::Graphql::Loaders::BatchModelLoader.new(target_type_class, object.target_id).find
      end
    end

    private

    def target_type_class
      klass = object.target_type.safe_constantize
      raise "Invalid target type \"#{object.target_type}\"" unless klass < Todoable

      klass
    end
  end
end

Types::TodoType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tracking/event_input_type.rb =====
# frozen_string_literal: true

module Types
  module Tracking
    class EventInputType < BaseInputObject
      graphql_name 'TrackingEventInput'
      description 'Attributes for defining a tracking event.'

      argument :action, GraphQL::Types::String, required: true, description: 'Event action.'
      argument :category, GraphQL::Types::String, required: true, description: 'Event category.'
      argument :extra, GraphQL::Types::JSON, required: false, description: 'Extra metadata for the event.' # rubocop:disable Graphql/JSONType -- extra can have an arbitrary structure
      argument :label, GraphQL::Types::String, required: false, description: 'Event label.'
      argument :property, GraphQL::Types::String, required: false, description: 'Event property.'
      argument :value, GraphQL::Types::String, required: false, description: 'Event value.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tree/blob_type.rb =====
# frozen_string_literal: true

module Types
  module Tree
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `Repository` that has its own authorization
    class BlobType < BaseObject
      graphql_name 'Blob'

      implements Types::Tree::EntryType
      present_using BlobPresenter

      field :lfs_oid, GraphQL::Types::String, null: true,
        calls_gitaly: true,
        description: 'LFS ID of the blob.'
      field :mode, GraphQL::Types::String, null: true,
        description: 'Blob mode in numeric format.'
      field :web_path, GraphQL::Types::String, null: true,
        description: 'Web path of the blob.'
      field :web_url, GraphQL::Types::String, null: true,
        description: 'Web URL of the blob.'

      def lfs_oid
        Gitlab::Graphql::Loaders::BatchLfsOidLoader.new(object.repository, object.id).find
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tree/entry_type.rb =====
# frozen_string_literal: true

module Types
  module Tree
    module EntryType
      include Types::BaseInterface

      field :id, GraphQL::Types::ID, null: false,
        description: 'ID of the entry.'
      field :sha, GraphQL::Types::String, null: false,
        description: 'SHA of the entry.', method: :id
      field :name, GraphQL::Types::String, null: false,
        description: 'Name of the entry.'
      field :type, Tree::TypeEnum, null: false,
        description: 'Type of tree entry.'
      field :path, GraphQL::Types::String, null: false,
        description: 'Path of the entry.'
      field :flat_path, GraphQL::Types::String, null: false,
        description: 'Flat path of the entry.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tree/submodule_type.rb =====
# frozen_string_literal: true

module Types
  module Tree
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `Repository` that has its own authorization
    class SubmoduleType < BaseObject
      graphql_name 'Submodule'

      implements Types::Tree::EntryType

      field :tree_url, type: GraphQL::Types::String, null: true,
        description: 'Tree URL for the sub-module.'
      field :web_url, type: GraphQL::Types::String, null: true,
        description: 'Web URL for the sub-module.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tree/tree_entry_type.rb =====
# frozen_string_literal: true

module Types
  module Tree
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `Repository` that has its own authorization
    class TreeEntryType < BaseObject
      graphql_name 'TreeEntry'
      description 'Represents a directory'

      implements Types::Tree::EntryType
      present_using TreeEntryPresenter

      field :web_path, GraphQL::Types::String, null: true,
        description: 'Web path for the tree entry (directory).'
      field :web_url, GraphQL::Types::String, null: true,
        description: 'Web URL for the tree entry (directory).'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tree/tree_type.rb =====
# frozen_string_literal: true

module Types
  module Tree
    # rubocop: disable Graphql/AuthorizeTypes
    # This is presented through `Repository` that has its own authorization
    class TreeType < BaseObject
      graphql_name 'Tree'

      present_using ::Projects::TreePresenter

      # Complexity 10 as it triggers a Gitaly call on each render
      field :last_commit, Types::Repositories::CommitType,
        null: true, complexity: 10, calls_gitaly: true, resolver: Resolvers::LastCommitResolver,
        description: 'Last commit for the tree.'

      field :trees, Types::Tree::TreeEntryType.connection_type, null: false,
        description: 'Trees of the tree.'

      field :submodules, Types::Tree::SubmoduleType.connection_type, null: false,
        description: 'Sub-modules of the tree.',
        calls_gitaly: true

      field :blobs, Types::Tree::BlobType.connection_type, null: false,
        description: 'Blobs of the tree.',
        calls_gitaly: true

      field :permalink_path, GraphQL::Types::String, null: true,
        description: "Web path to tree permalink. " \
          "The `permalinkPath` field returns a string that represents the web path to a specific version of " \
          "a directory, identified by its commit SHA. Use this path to create permanent links to directories at " \
          "specific points in your repository's history.",
        calls_gitaly: true,
        experiment: { milestone: '17.11' }

      def trees
        Gitlab::Graphql::Representation::TreeEntry.decorate(object.trees, object.repository)
      end

      def submodules
        Gitlab::Graphql::Representation::SubmoduleTreeEntry.decorate(object.submodules, object)
      end

      def blobs
        Gitlab::Graphql::Representation::TreeEntry.decorate(object.blobs, object.repository)
      end
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/tree/type_enum.rb =====
# frozen_string_literal: true

module Types
  module Tree
    class TypeEnum < BaseEnum
      graphql_name 'EntryType'
      description 'Type of a tree entry'

      value 'tree', description: 'Directory tree type.', value: :tree
      value 'blob', description: 'File tree type.', value: :blob
      value 'commit', description: 'Commit tree type.', value: :commit
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/untrusted_regexp.rb =====
# frozen_string_literal: true

module Types
  class UntrustedRegexp < Types::BaseScalar
    description 'A regexp containing patterns sourced from user input'

    def self.coerce_input(input_value, _)
      return unless input_value

      Gitlab::UntrustedRegexp.new(input_value)

      input_value
    rescue RegexpError => e
      message = "#{input_value} is an invalid regexp: #{e.message}"
      raise GraphQL::CoercionError, message
    end

    def self.coerce_result(ruby_value, _)
      ruby_value.to_s
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/upload_type.rb =====
# frozen_string_literal: true

module Types
  class UploadType < BaseObject
    graphql_name 'FileUpload'

    authorize :read_upload

    field :id, Types::GlobalIDType[::Upload],
      null: false,
      description: 'Global ID of the upload.'
    field :path, GraphQL::Types::String,
      null: false,
      description: 'Path of the upload.'
    field :size, GraphQL::Types::Int,
      null: false,
      description: 'Size of the upload in bytes.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_callout_feature_name_enum.rb =====
# frozen_string_literal: true

module Types
  class UserCalloutFeatureNameEnum < BaseEnum
    graphql_name 'UserCalloutFeatureNameEnum'
    description 'Name of the feature that the callout is for.'

    ::Users::Callout.feature_names.keys.each do |feature_name|
      value feature_name.upcase, value: feature_name, description: "Callout feature name for #{feature_name}."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_callout_type.rb =====
# frozen_string_literal: true

module Types
  class UserCalloutType < BaseObject # rubocop:disable Graphql/AuthorizeTypes
    graphql_name 'UserCallout'

    field :dismissed_at, Types::TimeType, null: true,
      description: 'Date when the callout was dismissed.'
    field :feature_name, UserCalloutFeatureNameEnum, null: true,
      description: 'Name of the feature that the callout is for.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_interface.rb =====
# frozen_string_literal: true

module Types
  module UserInterface
    include Types::BaseInterface

    graphql_name 'User'
    description 'Representation of a GitLab user.'

    implements Types::TodoableInterface

    field :user_permissions,
      type: Types::PermissionTypes::User,
      description: 'Permissions for the current user on the resource.',
      null: false,
      method: :itself

    field :id,
      type: Types::GlobalIDType[::User],
      null: false,
      description: 'Global ID of the user.'
    field :bot,
      type: GraphQL::Types::Boolean,
      null: false,
      description: 'Indicates if the user is a bot.',
      method: :bot?
    field :username,
      type: GraphQL::Types::String,
      null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Username of the user. Unique within the instance of GitLab.'
    field :name,
      type: GraphQL::Types::String,
      null: false,
      scopes: [:api, :read_api, :ai_workflows],
      resolver_method: :redacted_name,
      description: 'Human-readable name of the user. ' \
        'Returns `****` if the user is a project bot and the requester does not have permission to view the project.'

    field :state,
      type: Types::UserStateEnum,
      null: false,
      description: 'State of the user.'
    field :email,
      type: GraphQL::Types::String,
      null: true,
      description: 'User email.', method: :public_email,
      deprecated: { reason: :renamed, replacement: 'User.publicEmail', milestone: '13.7' }
    field :emails,
      type: Types::Users::EmailType.connection_type,
      null: true,
      description: "User's email addresses."
    field :public_email,
      type: GraphQL::Types::String,
      null: true,
      description: "User's public email."
    field :commit_email,
      type: GraphQL::Types::String,
      null: true,
      description: "User's default commit email.",
      authorize: :read_user_email_address
    field :namespace_commit_emails,
      type: Types::Users::NamespaceCommitEmailType.connection_type,
      null: true,
      description: "User's custom namespace commit emails."
    field :avatar_url,
      type: GraphQL::Types::String,
      null: true,
      description: "URL of the user's avatar."
    field :web_url,
      type: GraphQL::Types::String,
      null: false,
      description: 'Web URL of the user.'
    field :web_path,
      type: GraphQL::Types::String,
      null: false,
      description: 'Web path of the user.'
    field :organizations,
      resolver: Resolvers::Users::OrganizationsResolver,
      null: true,
      experiment: { milestone: '16.6' },
      description: 'Organizations where the user has access.'
    field :group_memberships,
      type: Types::GroupMemberType.connection_type,
      null: true,
      description: 'Group memberships of the user.'
    field :groups,
      resolver: Resolvers::Users::GroupsResolver,
      description: 'Groups where the user has access.'
    field :group_count,
      resolver: Resolvers::Users::GroupCountResolver,
      description: 'Group count for the user.'
    field :project_count,
      resolver: Resolvers::Users::ProjectCountResolver,
      description: 'Project count for the user.'
    field :status,
      type: Types::UserStatusType,
      null: true,
      description: 'User status.'
    field :location,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'Location of the user.'
    field :project_memberships,
      type: Types::ProjectMemberType.connection_type,
      null: true,
      description: 'Project memberships of the user.'
    field :starred_projects,
      description: 'Projects starred by the user.',
      resolver: Resolvers::UserStarredProjectsResolver
    field :contributed_projects,
      description: 'Projects the user has contributed to.',
      resolver: Resolvers::Projects::UserContributedProjectsResolver
    field :namespace,
      type: Types::NamespaceType,
      null: true,
      description: 'Personal namespace of the user.',
      resolver_method: :resolve_user_namespace

    field :todos,
      Types::TodoType.connection_type,
      description: 'To-do items of the user.',
      resolver: Resolvers::TodosResolver

    # Merge request field: MRs can be authored, assigned, or assigned-for-review:
    field :authored_merge_requests,
      resolver: Resolvers::AuthoredMergeRequestsResolver,
      description: 'Merge requests authored by the user.'
    field :assigned_merge_requests,
      resolver: Resolvers::AssignedMergeRequestsResolver,
      description: 'Merge requests assigned to the user.'
    field :review_requested_merge_requests,
      resolver: Resolvers::ReviewRequestedMergeRequestsResolver,
      description: 'Merge requests assigned to the user for review.'

    field :snippets,
      description: 'Snippets authored by the user.',
      resolver: Resolvers::Users::SnippetsResolver
    field :callouts,
      Types::UserCalloutType.connection_type,
      null: true,
      description: 'User callouts that belong to the user.'
    field :timelogs,
      Types::TimelogType.connection_type,
      null: true,
      description: 'Time logged by the user.',
      extras: [:lookahead],
      complexity: 5,
      resolver: ::Resolvers::TimelogResolver
    field :saved_replies,
      ::Types::Users::SavedReplyType.connection_type,
      null: true,
      description: 'Saved replies authored by the user.'

    field :saved_reply,
      resolver: Resolvers::SavedReplyResolver,
      description: 'Saved reply authored by the user.'

    field :gitpod_enabled, GraphQL::Types::Boolean, null: true,
      description: 'Whether Gitpod is enabled at the user level.'

    field :user_preferences, ::Types::UserPreferencesType,
      null: true,
      description: 'Preferences for the user.',
      method: :user_preference

    field :preferences_gitpod_path,
      GraphQL::Types::String,
      null: true,
      description: 'Web path to the Gitpod section within user preferences.'

    field :profile_enable_gitpod_path, GraphQL::Types::String, null: true,
      description: 'Web path to enable Gitpod for the user.'

    field :user_achievements,
      Types::Achievements::UserAchievementType.connection_type,
      null: true,
      experiment: { milestone: '15.10' },
      description: "Achievements for the user. " \
        "Only returns for namespaces where the `achievements` feature flag is enabled.",
      extras: [:lookahead],
      resolver: ::Resolvers::Achievements::UserAchievementsForUserResolver

    field :bio,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'Bio of the user.'

    field :active,
      type: ::GraphQL::Types::Boolean,
      null: true,
      method: :active?,
      description: 'Indicates if the user is active.'

    field :human,
      type: ::GraphQL::Types::Boolean,
      null: true,
      method: :human?,
      description: 'Indicates if the user is a regular user.'

    field :linkedin,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'LinkedIn profile name of the user.'

    field :twitter,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'X (formerly Twitter) username of the user.'

    field :discord,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'Discord ID of the user.'

    field :github,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'GitHub profile name of the user.'

    field :organization,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'Who the user represents or works for.',
      method: :user_detail_organization

    field :job_title,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'Job title of the user.'

    field :created_at,
      type: Types::TimeType,
      null: true,
      description: 'Timestamp of when the user was created.'

    field :last_activity_on,
      type: Types::DateType,
      null: true,
      description: 'Date the user last performed any actions.'

    field :pronouns,
      type: ::GraphQL::Types::String,
      null: true,
      description: 'Pronouns of the user.'

    field :ide,
      type: Types::IdeType,
      null: true,
      description: 'IDE settings.',
      method: :itself

    field :type,
      type: Types::Users::TypeEnum,
      null: false,
      description: 'Type of the user.',
      method: :user_type

    definition_methods do
      def resolve_type(object, context)
        # in the absence of other information, we cannot tell - just default to
        # the core user type.
        ::Types::UserType
      end
    end

    def redacted_name
      object.redacted_name(context[:current_user])
    end

    def resolve_user_namespace
      return object.namespace if object.namespace&.organization_id == context[:current_organization].id

      nil
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_merge_request_interaction_type.rb =====
# frozen_string_literal: true

module Types
  class UserMergeRequestInteractionType < BaseObject
    graphql_name 'UserMergeRequestInteraction'
    description <<~MD
      Information about a merge request given a specific user.

      This object has two parts to its state: a `User` and a `MergeRequest`. All
      fields relate to interactions between the two entities.
    MD

    authorize :read_merge_request

    field :can_merge,
      type: ::GraphQL::Types::Boolean,
      null: false,
      calls_gitaly: true,
      method: :can_merge?,
      description: 'Whether the user can merge the merge request.'

    field :can_update,
      type: ::GraphQL::Types::Boolean,
      null: false,
      method: :can_update?,
      description: 'Whether the user can update the merge request.'

    field :review_state,
      ::Types::MergeRequestReviewStateEnum,
      null: true,
      description: 'State of the review by the user.'

    field :reviewed,
      type: ::GraphQL::Types::Boolean,
      null: false,
      method: :reviewed?,
      description: 'Whether the user has provided a review for the merge request.'

    field :approved,
      type: ::GraphQL::Types::Boolean,
      null: false,
      method: :approved?,
      description: 'Whether the user has approved the merge request.'
  end
end

::Types::UserMergeRequestInteractionType.prepend_mod_with('Types::UserMergeRequestInteractionType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_preferences_type.rb =====
# frozen_string_literal: true

module Types
  class UserPreferencesType < BaseObject
    graphql_name 'UserPreferences'

    authorize :read_user_preference

    alias_method :user_preference, :object

    field :extensions_marketplace_opt_in_status, Types::ExtensionsMarketplaceOptInStatusEnum,
      description: 'Status of the Web IDE Extension Marketplace opt-in for the user.',
      null: false

    field :issues_sort, Types::IssueSortEnum,
      description: 'Sort order for issue lists.',
      null: true

    field :visibility_pipeline_id_type, Types::VisibilityPipelineIdTypeEnum,
      description: 'Determines whether the pipeline list shows ID or IID.',
      null: true

    # rubocop:disable GraphQL/ExtractType -- These are stored as user preferences
    field :use_work_items_view, GraphQL::Types::Boolean,
      description: 'Use work item view instead of legacy issue view.',
      null: true

    field :merge_request_dashboard_list_type, Types::MergeRequests::DashboardListTypeEnum,
      description: 'Merge request dashboard list rendering type.',
      null: true

    field :projects_sort,
      Types::Projects::ProjectSortEnum,
      description: 'Sort order for projects.',
      null: true

    field :organization_groups_projects_sort,
      Types::Organizations::GroupsProjectsSortEnum,
      description: 'Sort order for organization groups and projects.',
      null: true,
      experiment: { milestone: '17.2' }

    field :organization_groups_projects_display,
      Types::Organizations::GroupsProjectsDisplayEnum,
      null: false,
      description: 'Default list view for organization groups and projects.',
      experiment: { milestone: '17.2' }
    # rubocop:enable GraphQL/ExtractType

    field :timezone,
      GraphQL::Types::String,
      null: true,
      description: 'Timezone of the user.',
      experiment: { milestone: '17.7' }

    field :work_items_display_settings,
      type: GraphQL::Types::JSON,
      null: false,
      description: 'Display settings for the work item lists.'

    def issues_sort
      user_preference.issues_sort&.to_sym
    end

    def projects_sort
      user_preference.projects_sort&.to_sym
    end

    def organization_groups_projects_sort
      user_preference.organization_groups_projects_sort&.to_sym
    end

    def extensions_marketplace_opt_in_status
      user = user_preference.user

      ::WebIde::ExtensionMarketplaceOptIn.opt_in_status(
        user: user,
        marketplace_home_url: ::WebIde::ExtensionMarketplace.marketplace_home_url(user: user)
      )
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/activity_stream_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class ActivityStreamType < BaseObject
      graphql_name 'ActivityStream'
      description 'Activity streams associated with a user'

      authorize :read_user_profile

      field :followed_users_activity,
        Types::EventType.connection_type,
        description: 'Activity from users followed by the current user.',
        experiment: { milestone: '17.10' } do
          argument :target, EventTargetEnum, default_value: EventFilter::ALL, description: "Event target."
        end

      def followed_users_activity(target: nil, last: 20)
        scope = current_user.followees
        user_events(scope, target, last)
      end

      private

      def user_events(scope, target, last)
        UserRecentEventsFinder.new(current_user, scope, EventFilter.new(target), { limit: last }).execute
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/autocompleted_user_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class AutocompletedUserType < ::Types::UserType
      graphql_name 'AutocompletedUser'

      authorize :read_user

      field :merge_request_interaction, Types::UserMergeRequestInteractionType,
        null: true,
        description: 'Merge request state related to the user.' do
          argument :id, ::Types::GlobalIDType[::MergeRequest], required: true,
            description: 'Global ID of the merge request.'
        end

      def merge_request_interaction(id: nil)
        Gitlab::Graphql::Lazy.with_value(GitlabSchema.object_from_id(id, expected_class: ::MergeRequest)) do |mr|
          ::Users::MergeRequestInteraction.new(user: object.user, merge_request: mr) if mr
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/email_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class EmailType < BaseObject
      graphql_name 'Email'

      authorize :read_user_email_address

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'Internal ID of the email.'

      field :email,
        GraphQL::Types::String,
        null: false,
        description: 'Email address.'

      field :confirmed_at,
        Types::TimeType,
        null: true,
        description: 'Timestamp the email was confirmed.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the email was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the email was last updated.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/event_target_enum.rb =====
# frozen_string_literal: true

module Types
  module Users
    class EventTargetEnum < BaseEnum
      graphql_name 'EventTarget'
      description 'Event target'

      mock_filter = ::EventFilter.new('')
      mock_filter.filters.each do |target_type|
        value target_type.upcase, value: target_type, description: "#{target_type.titleize} events"
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/event_target_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class EventTargetType < BaseUnion
      graphql_name 'EventTargetType'
      description 'Represents an object that can be the subject of an event.'

      possible_types Types::IssueType, Types::MilestoneType,
        Types::MergeRequestType, Types::ProjectType,
        Types::SnippetType, Types::UserType, Types::Wikis::WikiPageType,
        Types::DesignManagement::DesignType, Types::Notes::NoteType

      def self.resolve_type(object, _context)
        case object
        when Issue
          Types::IssueType
        when Milestone
          Types::MilestoneType
        when MergeRequest
          Types::MergeRequestType
        when Note
          Types::Notes::NoteType
        when Project
          Types::ProjectType
        when Snippet
          Types::SnippetType
        when User
          Types::UserType
        when WikiPage::Meta
          Types::Wikis::WikiPageType
        when ::DesignManagement::Design
          Types::DesignManagement::DesignType
        else
          raise "Unsupported event target type: #{object.class.name}"
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/namespace_commit_email_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class NamespaceCommitEmailType < BaseObject
      graphql_name 'NamespaceCommitEmail'

      authorize :read_user_email_address

      field :id,
        GraphQL::Types::ID,
        null: false,
        description: 'Internal ID of the namespace commit email.'

      field :email,
        Types::Users::EmailType,
        null: false,
        description: 'Email.'

      field :namespace,
        Types::NamespaceType,
        null: false,
        description: 'Namespace.'

      field :created_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the namespace commit email was created.'

      field :updated_at,
        Types::TimeType,
        null: false,
        description: 'Timestamp the namespace commit email was last updated.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/recently_viewed_item_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class RecentlyViewedItemType < BaseObject # rubocop:disable Graphql/AuthorizeTypes -- This is a wrapper type, authorization is handled by the underlying items
      graphql_name 'RecentlyViewedItem'

      field :item, Types::Users::RecentlyViewedItemUnion, null: false,
        description: 'Recently viewed item.'

      field :viewed_at, Types::TimeType, null: false,
        description: 'When the item was last viewed.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/recently_viewed_item_union.rb =====
# frozen_string_literal: true

module Types
  module Users
    class RecentlyViewedItemUnion < BaseUnion
      graphql_name 'RecentlyViewedItemUnion'

      possible_types Types::IssueType, Types::MergeRequestType

      def self.resolve_type(object, _context)
        case object
        when ::Issue
          Types::IssueType
        when ::MergeRequest
          Types::MergeRequestType
        else
          raise "Unexpected RecentlyViewedItem type: #{object.class}"
        end
      end
    end
  end
end

Types::Users::RecentlyViewedItemUnion.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/saved_reply_type.rb =====
# frozen_string_literal: true

module Types
  module Users
    class SavedReplyType < ::Types::SavedReplyType
      graphql_name 'SavedReply'

      authorize :read_saved_replies

      field :id, Types::GlobalIDType[::Users::SavedReply],
        null: false,
        description: 'Global ID of the user saved reply.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_state_enum.rb =====
# frozen_string_literal: true

module Types
  class UserStateEnum < BaseEnum
    graphql_name 'UserState'
    description 'Possible states of a user'

    value 'active', 'User is active and can use the system.', value: 'active'
    value 'blocked', 'User has been blocked by an administrator and cannot use the system.', value: 'blocked'
    value 'deactivated', 'User is no longer active and cannot use the system.', value: 'deactivated'
    value 'banned', 'User is blocked, and their contributions are hidden.', value: 'banned'
    value 'ldap_blocked', 'User has been blocked by the system.', value: 'ldap_blocked'
    value 'blocked_pending_approval', 'User is blocked and pending approval.', value: 'blocked_pending_approval'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_status_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes
  class UserStatusType < BaseObject
    graphql_name 'UserStatus'

    markdown_field :message_html, null: true,
      description: 'HTML of the user status message'
    field :availability, Types::AvailabilityEnum, null: false,
      description: 'User availability status.'
    field :emoji, GraphQL::Types::String, null: true,
      description: 'String representation of emoji.'
    field :message, GraphQL::Types::String, null: true,
      description: 'User status message.'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/users/type_enum.rb =====
# frozen_string_literal: true

module Types
  module Users
    class TypeEnum < BaseEnum
      graphql_name 'UserType'
      description 'Possible types of user'

      User.user_types.each_key do |key|
        value key.to_s.upcase, value: key.to_s, description: key.to_s.humanize.to_s
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/user_type.rb =====
# frozen_string_literal: true

module Types
  class UserType < ::Types::BaseObject
    graphql_name 'UserCore'
    description 'Core representation of a GitLab user.'

    connection_type_class Types::CountableConnectionType

    implements ::Types::UserInterface

    authorize :read_user

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    present_using UserPresenter
  end
end

Types::UserType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/visibility_levels_enum.rb =====
# frozen_string_literal: true

module Types
  class VisibilityLevelsEnum < BaseEnum
    Gitlab::VisibilityLevel.string_options.each do |name, int_value|
      value name.downcase, value: int_value, description: "#{name.titleize} visibility level."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/visibility_pipeline_id_type_enum.rb =====
# frozen_string_literal: true

module Types
  class VisibilityPipelineIdTypeEnum < BaseEnum
    graphql_name 'VisibilityPipelineIdType'
    description 'Determines whether the pipeline list shows ID or IID'

    UserPreference.visibility_pipeline_id_types.each_key do |field|
      value field.upcase, value: field, description: "Display pipeline #{field.upcase}."
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/wikis/wiki_page_type.rb =====
# frozen_string_literal: true

module Types
  module Wikis
    class WikiPageType < BaseObject
      graphql_name 'WikiPage'

      implements Types::Notes::NoteableInterface
      implements Types::TodoableInterface

      description 'A wiki page'

      authorize :read_wiki

      expose_permissions Types::PermissionTypes::Wikis::WikiPage

      field :id, Types::GlobalIDType[::WikiPage::Meta],
        null: false, description: 'Global ID of the wiki page metadata record.'

      field :title, GraphQL::Types::String,
        null: false, description: 'Wiki page title.'

      field :subscribed, GraphQL::Types::Boolean,
        null: false,
        description: 'Whether the current user is subscribed to notifications on the wiki page.'

      def subscribed
        object.subscribed?(current_user, object.project)
      end

      def web_url
        Gitlab::UrlBuilder.build(object)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_item_id_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop:disable Graphql/AuthorizeTypes
  # TODO: This type should be removed when Work Items become generally available.
  # This mechanism is introduced temporarily to make the client implementation easier during this transition.
  class WorkItemIdType < GlobalIDType
    graphql_name 'WorkItemID'
    description <<~DESC
      A `WorkItemID` is a global ID. It is encoded as a string.

      An example `WorkItemID` is: `"gid://gitlab/WorkItem/1"`.

      While we transition from Issues into Work Items this type will temporarily support
      `IssueID` like: `"gid://gitlab/Issue/1"`. This behavior will be removed without notice in the future.
    DESC

    class << self
      def coerce_result(gid, ctx)
        global_id = ::Gitlab::GlobalId.as_global_id(gid, model_name: 'WorkItem')

        raise GraphQL::CoercionError, "Expected a WorkItem ID, got #{global_id}" unless suitable?(global_id)

        # Always return a WorkItemID even if an Issue is returned by a resolver
        work_item_gid(global_id).to_s
      end

      def coerce_input(string, ctx)
        gid = super
        return if gid.nil?
        # Always return a WorkItemID even if an Issue Global ID is provided as input
        return work_item_gid(gid) if suitable?(gid)

        raise GraphQL::CoercionError, "#{string.inspect} does not represent an instance of WorkItem"
      end

      def suitable?(gid)
        return false if gid&.model_name&.safe_constantize.blank?

        # Using === operation doesn't work for model classes.
        # See https://github.com/rails/rails/blob/v6.1.6.1/activerecord/lib/active_record/core.rb#L452
        # rubocop:disable Performance/RedundantEqualityComparisonBlock
        [::WorkItem, ::Issue].any? { |model_class| gid.model_class == model_class }
        # rubocop:enable Performance/RedundantEqualityComparisonBlock
      end

      private

      def work_item_gid(gid)
        GlobalID.new(::Gitlab::GlobalId.build(model_name: 'WorkItem', id: gid.model_id))
      end
    end
  end
  # rubocop:enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/available_export_fields_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class AvailableExportFieldsEnum < BaseEnum
      graphql_name 'AvailableExportFields'
      description 'Available fields to be exported as CSV'

      value 'ASSIGNEE', value: 'assignee', description: 'Assignee(s) name of the work item.'
      value 'ASSIGNEE_USERNAME', value: 'assignee username', description: 'Assignee(s) username of the work item.'

      value 'AUTHOR', value: 'author', description: 'Author name of the work item.'
      value 'AUTHOR_USERNAME', value: 'author username', description: 'Author username of the work item.'

      value 'CONFIDENTIAL', value: 'confidential', description: 'Confidentiality flag of the work item.'
      value 'DESCRIPTION', value: 'description', description: 'Description of the work item.'

      value 'ID', value: 'id', description: 'Unique identifier of the work item.'
      value 'IID', value: 'iid', description: 'IID identifier of the work item.'

      value 'LOCKED', value: 'locked', description: 'Locked discussions flag of the work item.'

      value 'START_DATE', value: 'start date', description: 'Start date (UTC) of the work item.'
      value 'DUE_DATE', value: 'due date', description: 'Due date (UTC) of the work item.'

      value 'CLOSED_AT', value: 'closed at', description: 'Closed at (UTC) date of the work item.'
      value 'CREATED_AT', value: 'created at', description: 'Crated at (UTC) date of the work item.'
      value 'UPDATED_AT', value: 'updated at', description: 'Updated at (UTC) date of the work item.'

      value 'MILESTONE', value: 'milestone', description: 'Milestone of the work item.'

      value 'PARENT_ID', value: 'parent id', description: 'Parent ID of the work item.'
      value 'PARENT_IID', value: 'parent iid', description: 'Parent IID of the work item.'
      value 'PARENT_TITLE', value: 'parent title', description: 'Parent title of the work item.'

      value 'STATE', value: 'state', description: 'State of the work item.'

      value 'TITLE', value: 'title', description: 'Title of the work item.'
      value 'TIME_ESTIMATE', value: 'time estimate', description: 'Time estimate of the work item.'
      value 'TIME_SPENT', value: 'time spent', description: 'Time spent of the work item.'
      value 'TYPE', value: 'type', description: 'Type of the work item.'

      value 'URL', value: 'url', description: 'Web URL to the work item.'
    end
  end
end

Types::WorkItems::AvailableExportFieldsEnum.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/award_emoji_update_action_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class AwardEmojiUpdateActionEnum < BaseEnum
      graphql_name 'WorkItemAwardEmojiUpdateAction'
      description 'Values for work item award emoji update enum'

      value 'ADD', 'Adds the emoji.', value: :add
      value 'REMOVE', 'Removes the emoji.', value: :remove
      value 'TOGGLE', 'Toggles the status of the emoji.', value: :toggle
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/closing_merge_request_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class ClosingMergeRequestType < BaseObject
      graphql_name 'WorkItemClosingMergeRequest'

      connection_type_class Types::WorkItems::Widgets::Connections::ClosingMergeRequestsConnectionType

      authorize :read_merge_request_closing_issue

      field :from_mr_description, GraphQL::Types::Boolean,
        null: false,
        description: 'Whether this merge request link was created by referencing the work item on the ' \
          'merge request description, using the closing pattern.'
      field :id, ::Types::GlobalIDType[::MergeRequestsClosingIssues],
        null: false,
        description: 'Global ID of the closing merge request association.'
      field :merge_request, ::Types::MergeRequestType,
        null: true,
        description: 'Related merge request.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/comment_template_path_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class CommentTemplatePathType < BaseObject # rubocop: disable Graphql/AuthorizeTypes -- this type is authorized by the resolver
      graphql_name 'CommentTemplatePathType'

      field :href, GraphQL::Types::String,
        null: false,
        description: 'Management link to the comment template.'
      field :text, GraphQL::Types::String,
        null: false,
        description: 'Name of the comment template scope.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/convert_task_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class ConvertTaskInputType < BaseInputObject
      graphql_name 'WorkItemConvertTaskInput'

      argument :line_number_end, GraphQL::Types::Int,
        required: true,
        description: 'Last line in the Markdown source that defines the list item task.'
      argument :line_number_start, GraphQL::Types::Int,
        required: true,
        description: 'First line in the Markdown source that defines the list item task.'
      argument :lock_version, GraphQL::Types::Int,
        required: true,
        description: 'Current lock version of the work item containing the task in the description.'
      argument :title, GraphQL::Types::String,
        required: true,
        description: 'Full string of the task to be replaced. New title for the created work item.'
      argument :work_item_type_id, ::Types::GlobalIDType[::WorkItems::Type],
        required: true,
        description: 'Global ID of the work item type used to create the new work item.',
        prepare: ->(attribute, _ctx) { work_item_type_global_id(attribute) }

      class << self
        def work_item_type_global_id(global_id)
          global_id&.model_id
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/description_template_content_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class DescriptionTemplateContentInputType < BaseInputObject
      graphql_name 'WorkItemDescriptionTemplateContentInput'

      argument :name, GraphQL::Types::String,
        required: true,
        description: 'Name of the description template.'
      argument :project_id, GraphQL::Types::Int,
        required: true,
        description: 'ID of the project the template belongs to.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/description_template_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    # rubocop: disable Graphql/AuthorizeTypes -- Authorization is done in the parent type
    class DescriptionTemplateType < BaseObject
      graphql_name 'WorkItemDescriptionTemplate'

      field :category, GraphQL::Types::String,
        description: 'Category of description template.', null: true, calls_gitaly: true
      field :content, GraphQL::Types::String,
        description: 'Content of Description Template.', null: true, calls_gitaly: true
      field :name, GraphQL::Types::String,
        description: 'Name of Description Template.', null: true, calls_gitaly: true
      field :project_id, GraphQL::Types::Int,
        description: 'ID of the description template project.', null: true, calls_gitaly: true
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/email_participant_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class EmailParticipantType < BaseObject
      graphql_name 'EmailParticipantType'

      # Don't use read_external_emails here, because we obfuscate emails instead.
      authorize :read_work_item

      present_using IssueEmailParticipantPresenter

      field :email, GraphQL::Types::String,
        description: 'Email address of the email participant. For guests, the email address is obfuscated.', null: false
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/hierarchy_filter_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class HierarchyFilterInputType < BaseInputObject
      graphql_name 'HierarchyFilterInput'

      argument :parent_ids, [::Types::GlobalIDType[::WorkItem]],
        description: 'Filter work items by global IDs of their parent items (maximum is 100 items).',
        required: false,
        prepare: ->(global_ids, _ctx) { GitlabSchema.parse_gids(global_ids, expected_type: ::WorkItem).map(&:model_id) }

      argument :include_descendant_work_items, GraphQL::Types::Boolean,
        description: 'Whether to include work items of descendant parents when filtering by parent_ids.',
        required: false

      argument :parent_wildcard_id, ::Types::WorkItems::ParentWildcardIdEnum,
        required: false,
        description: 'Filter by parent ID wildcard. Incompatible with parentIds.',
        experiment: { milestone: '18.3' }

      validates mutually_exclusive: [:parent_ids, :parent_wildcard_id]
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/linked_item_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    # rubocop:disable Graphql/AuthorizeTypes -- authorized by resolver
    class LinkedItemType < BaseObject
      graphql_name 'LinkedWorkItemType'

      field :link_created_at, ::Types::TimeType,
        description: 'Timestamp the link was created.', null: false,
        method: :issue_link_created_at

      field :work_item_state, ::Types::WorkItemStateEnum,
        description: 'State of the linked work item.', null: false, method: :state

      field :link_id, ::Types::GlobalIDType[::WorkItems::RelatedWorkItemLink],
        description: 'Global ID of the link.', null: false,
        method: :issue_link_id
      field :link_type, GraphQL::Types::String,
        description: 'Type of link.', null: false,
        method: :issue_link_type
      field :link_updated_at, ::Types::TimeType,
        description: 'Timestamp the link was updated.', null: false,
        method: :issue_link_updated_at
      field :work_item, ::Types::WorkItemType,
        description: 'Linked work item.', null: true

      def work_item
        object
      end
    end
    # rubocop:enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/linked_resource_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class LinkedResourceType < BaseObject
      graphql_name 'WorkItemLinkedResource'

      authorize :read_work_item

      field :url,
        GraphQL::Types::String,
        null: false,
        description: 'URL of resource.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/negated_work_item_filter_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class NegatedWorkItemFilterInputType < BaseInputObject
      graphql_name 'NegatedWorkItemFilterInput'

      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Usernames of users not assigned to the work item.'
      argument :author_username, [GraphQL::Types::String],
        required: false,
        description: "Username of a user who didn't author the work item."
      argument :label_name, [GraphQL::Types::String],
        required: false,
        description: 'Labels not applied to the work item.'
      argument :milestone_title, [GraphQL::Types::String],
        required: false,
        description: 'Milestone not applied to the work item.'
      argument :milestone_wildcard_id, ::Types::NegatedMilestoneWildcardIdEnum,
        required: false,
        description: 'Filter by negated milestone wildcard values.'
      argument :my_reaction_emoji, GraphQL::Types::String,
        required: false,
        description: 'Filter by reaction emoji not applied by the current user.'
      argument :parent_ids, [::Types::GlobalIDType[::WorkItem]],
        description: "Filter work items by global IDs who don't belong to parent items (maximum is 100 items).",
        required: false,
        experiment: { milestone: '18.3' },
        prepare: ->(global_ids, _ctx) { GitlabSchema.parse_gids(global_ids, expected_type: ::WorkItem).map(&:model_id) }
      argument :release_tag, [GraphQL::Types::String],
        required: false,
        description: "Release tag not associated with the work items's milestone. Ignored when parent is a group."
      argument :types, [::Types::IssueTypeEnum], as: :issue_types,
        description: 'Filter out work items by the given types.',
        required: false

      validates mutually_exclusive: [:milestone_title, :milestone_wildcard_id]
    end
  end
end

Types::WorkItems::NegatedWorkItemFilterInputType.prepend_mod_with('Types::WorkItems::NegatedWorkItemFilterInputType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/notes_filter_type_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class NotesFilterTypeEnum < BaseEnum
      graphql_name 'NotesFilterType'
      description 'Work item notes collection type.'

      ::UserPreference::NOTES_FILTERS.each_pair do |key, value|
        value key.upcase,
          value: value,
          description: ::UserPreference.notes_filters.invert[::UserPreference::NOTES_FILTERS[key]]
      end

      def self.default_value
        ::UserPreference::NOTES_FILTERS[:all_notes]
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/parent_wildcard_id_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class ParentWildcardIdEnum < BaseEnum
      graphql_name 'WorkItemParentWildcardId'
      description 'Parent ID wildcard values'

      value 'NONE', 'No parent is assigned.'
      value 'ANY', 'Any parent is assigned.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/related_branch_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    # Disabling widget level authorization as it might be too granular
    # and we already authorize the parent work item
    # rubocop:disable Graphql/AuthorizeTypes -- reason above
    class RelatedBranchType < BaseObject
      graphql_name 'WorkItemRelatedBranch'

      field :name,
        GraphQL::Types::String,
        null: false,
        description: 'Name of the branch.'

      field :compare_path, GraphQL::Types::String, null: true,
        description: 'Path to comparison of branch to default branch.'

      field :pipeline_status, ::Types::Ci::DetailedStatusType, null: true,
        description: 'Status of pipeline for the branch.'
    end
    # rubocop:enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/related_link_type_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class RelatedLinkTypeEnum < BaseEnum
      graphql_name 'WorkItemRelatedLinkType'
      description 'Values for work item link types'

      value 'RELATED', 'Related type.', value: 'relates_to'
    end
  end
end

Types::WorkItems::RelatedLinkTypeEnum.prepend_mod_with('Types::WorkItems::RelatedLinkTypeEnum')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/resolve_discussions_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class ResolveDiscussionsInputType < BaseInputObject
      graphql_name 'WorkItemResolveDiscussionsInput'

      argument :discussion_id, GraphQL::Types::String,
        description: 'ID of a discussion to resolve.',
        required: false
      argument :noteable_id, ::Types::GlobalIDType[::Noteable],
        required: true,
        description: 'Global ID of the noteable where discussions will be resolved when the work item is created. ' \
          'Only `MergeRequestID` is supported at the moment.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/sort_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class SortEnum < ::Types::SortEnum
      graphql_name 'WorkItemSort'
      description 'Values for sorting work items'

      ::WorkItems::SortingKeys.all.each do |key, attrs| # rubocop:disable Rails/FindEach -- false positive
        description = attrs.delete(:description)
        value = attrs.fetch(:value, key)

        value key.upcase, # rubocop: disable Graphql/Descriptions -- generated dynamically
          description,
          **attrs.merge(value: value)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/state_event_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class StateEventEnum < BaseEnum
      graphql_name 'WorkItemStateEvent'
      description 'Values for work item state events'

      value 'REOPEN', 'Reopens the work item.', value: 'reopen'
      value 'CLOSE', 'Closes the work item.', value: 'close'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/subscription_event_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class SubscriptionEventEnum < BaseEnum
      graphql_name 'WorkItemSubscriptionEvent'
      description 'Values for work item subscription events'

      value 'SUBSCRIBE', 'Subscribe to a work item.', value: 'subscribe'
      value 'UNSUBSCRIBE', 'Unsubscribe from a work item.', value: 'unsubscribe'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_item_state_counts_type.rb =====
# frozen_string_literal: true

module Types
  # rubocop: disable Graphql/AuthorizeTypes -- Parent node applies authorization
  class WorkItemStateCountsType < BaseObject
    graphql_name 'WorkItemStateCountsType'
    description 'Represents total number of work items for the represented states'

    field :all,
      GraphQL::Types::Int,
      null: true,
      description: 'Number of work items for the project or group.'

    field :closed,
      GraphQL::Types::Int,
      null: true,
      description: 'Number of work items with state CLOSED for the project or group.'

    field :opened,
      GraphQL::Types::Int,
      null: true,
      description: 'Number of work items with state OPENED for the project or group.'
  end
  # rubocop: enable Graphql/AuthorizeTypes
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_item_state_enum.rb =====
# frozen_string_literal: true

module Types
  class WorkItemStateEnum < BaseEnum
    graphql_name 'WorkItemState'
    description 'State of a GitLab work item'

    value 'OPEN', 'In open state.', value: 'opened'
    value 'CLOSED', 'In closed state.', value: 'closed'
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/todo_update_action_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class TodoUpdateActionEnum < BaseEnum
      graphql_name 'WorkItemTodoUpdateAction'
      description 'Values for work item to-do update enum'

      value 'MARK_AS_DONE', 'Marks the to-do as done.', value: 'mark_as_done'
      value 'ADD', 'Adds the to-do.', value: 'add'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/type_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class TypeType < BaseObject
      graphql_name 'WorkItemType'

      authorize :read_work_item_type

      def self.authorization_scopes
        super + [:ai_workflows]
      end

      field :icon_name, GraphQL::Types::String,
        null: true,
        description: 'Icon name of the work item type.'
      field :id, ::Types::GlobalIDType[::WorkItems::Type],
        null: false,
        scopes: [:api, :read_api, :ai_workflows],
        description: 'Global ID of the work item type.'
      field :name, GraphQL::Types::String,
        null: false,
        scopes: [:api, :read_api, :ai_workflows],
        description: 'Name of the work item type.'
      field :widget_definitions, [::Types::WorkItems::WidgetDefinitionInterface],
        null: true,
        description: 'Available widgets for the work item type.',
        method: :widgets,
        experiment: { milestone: '16.7' }

      field :supported_conversion_types, [::Types::WorkItems::TypeType],
        null: true,
        description: 'Supported conversion types for the work item type.',
        experiment: { milestone: '17.8' }

      field :unavailable_widgets_on_conversion, [::Types::WorkItems::WidgetDefinitionInterface],
        null: true,
        description: 'Widgets that will be lost when converting from source work item type to target work item type.' do
          argument :target, ::Types::GlobalIDType[::WorkItems::Type],
            required: true,
            description: 'Target work item type to convert to.'
        end

      def widget_definitions
        object.widgets(context[:resource_parent])
      end

      def supported_conversion_types
        object.supported_conversion_types(context[:resource_parent], current_user)
      end

      def unavailable_widgets_on_conversion(target:)
        source_type = object
        target_type = GitlabSchema.find_by_gid(target).sync

        return [] unless source_type && target_type

        source_type.unavailable_widgets_on_conversion(target_type, context[:resource_parent])
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/unioned_work_item_filter_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class UnionedWorkItemFilterInputType < BaseInputObject
      graphql_name 'UnionedWorkItemFilterInput'

      argument :assignee_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Filters work items that are assigned to at least one of the given users.'
      argument :author_usernames, [GraphQL::Types::String],
        required: false,
        description: 'Filters work items that are authored by one of the given users.'
      argument :label_names, [GraphQL::Types::String],
        required: false,
        description: 'Filters work items that have at least one of the given labels.'
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/user_preference.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class UserPreference < BaseObject
      graphql_name 'WorkItemTypesUserPreference'

      authorize :read_namespace

      field :namespace,
        type: ::Types::NamespaceType,
        null: false,
        description: 'Namespace for the user preference.'

      field :work_item_type,
        type: ::Types::WorkItems::TypeType,
        null: true,
        description: 'Type assigned to the work item.'

      field :sort,
        type: ::Types::WorkItems::SortEnum,
        null: true,
        description: 'Sort order for work item lists.'

      field :display_settings,
        type: GraphQL::Types::JSON,
        null: true,
        description: 'Display settings for the work item lists.'

      def sort
        object.sort&.to_sym
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widget_definition_interface.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module WidgetDefinitionInterface
      include ::Types::BaseInterface

      graphql_name 'WorkItemWidgetDefinition'

      field :type, ::Types::WorkItems::WidgetTypeEnum,
        null: false,
        description: 'Widget type.'

      ORPHAN_TYPES = [
        ::Types::WorkItems::WidgetDefinitions::AssigneesType,
        ::Types::WorkItems::WidgetDefinitions::GenericType,
        ::Types::WorkItems::WidgetDefinitions::HierarchyType
      ].freeze

      TYPE_MAPPING = {
        ::WorkItems::Widgets::Assignees => ::Types::WorkItems::WidgetDefinitions::AssigneesType,
        ::WorkItems::Widgets::Hierarchy => ::Types::WorkItems::WidgetDefinitions::HierarchyType
      }.freeze

      def self.ce_orphan_types
        ORPHAN_TYPES
      end

      def self.resolve_type(object, _context)
        TYPE_MAPPING[object.widget_class] || ::Types::WorkItems::WidgetDefinitions::GenericType
      end

      def type
        object.widget_class.type
      end

      orphan_types(*ce_orphan_types)
    end
  end
end

Types::WorkItems::WidgetDefinitionInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widget_definitions/assignees_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module WidgetDefinitions
      # rubocop:disable Graphql/AuthorizeTypes -- Authorization too granular, parent type is authorized
      class AssigneesType < BaseObject
        graphql_name 'WorkItemWidgetDefinitionAssignees'
        description 'Represents an assignees widget definition'

        implements ::Types::WorkItems::WidgetDefinitionInterface

        field :can_invite_members, GraphQL::Types::Boolean,
          null: false,
          description: 'Indicates whether the current user can invite members to the work item\'s parent.'

        def can_invite_members
          object.widget_class.can_invite_members?(current_user, resource_parent)
        end

        private

        def resource_parent
          context[:resource_parent]
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end

Types::WorkItems::WidgetDefinitions::AssigneesType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widget_definitions/generic_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module WidgetDefinitions
      # rubocop:disable Graphql/AuthorizeTypes -- Authorization too granular, parent type is authorized
      class GenericType < BaseObject
        graphql_name 'WorkItemWidgetDefinitionGeneric'
        description 'Represents a generic widget definition'

        implements ::Types::WorkItems::WidgetDefinitionInterface
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widget_definitions/hierarchy_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module WidgetDefinitions
      # rubocop:disable Graphql/AuthorizeTypes -- authorized in work item type entity
      # rubocop:disable GraphQL/ExtractType -- no need to extra allowed types into a seperate field
      class HierarchyType < BaseObject
        graphql_name 'WorkItemWidgetDefinitionHierarchy'
        description 'Represents a hierarchy widget definition'

        implements ::Types::WorkItems::WidgetDefinitionInterface

        field :allowed_child_types, ::Types::WorkItems::TypeType.connection_type,
          null: true,
          complexity: 5,
          extras: [:parent],
          description: 'Allowed child types for the work item type.'

        field :allowed_parent_types, ::Types::WorkItems::TypeType.connection_type,
          null: true,
          extras: [:parent],
          complexity: 5,
          description: 'Allowed parent types for the work item type.'

        def allowed_child_types(parent:)
          parent.allowed_child_types(cache: true, authorize: true, resource_parent: context[:resource_parent])
        end

        def allowed_parent_types(parent:)
          parent.allowed_parent_types(cache: true, authorize: true, resource_parent: context[:resource_parent])
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
      # rubocop:enable GraphQL/ExtractType
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widget_interface.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module WidgetInterface
      include ::Types::BaseInterface

      graphql_name 'WorkItemWidget'

      field :type,
        ::Types::WorkItems::WidgetTypeEnum,
        null: true,
        description: 'Widget type.'

      # Whenever a new widget is added make sure to update the spec to avoid N + 1 queries in
      # spec/requests/api/graphql/project/work_items_spec.rb and add the necessary preloads
      # in app/graphql/resolvers/work_items_resolver.rb
      TYPE_MAPPINGS = {
        ::WorkItems::Widgets::Description => ::Types::WorkItems::Widgets::DescriptionType,
        ::WorkItems::Widgets::Hierarchy => ::Types::WorkItems::Widgets::HierarchyType,
        ::WorkItems::Widgets::Labels => ::Types::WorkItems::Widgets::LabelsType,
        ::WorkItems::Widgets::Assignees => ::Types::WorkItems::Widgets::AssigneesType,
        ::WorkItems::Widgets::StartAndDueDate => ::Types::WorkItems::Widgets::StartAndDueDateType,
        ::WorkItems::Widgets::Milestone => ::Types::WorkItems::Widgets::MilestoneType,
        ::WorkItems::Widgets::Notes => ::Types::WorkItems::Widgets::NotesType,
        ::WorkItems::Widgets::Notifications => ::Types::WorkItems::Widgets::NotificationsType,
        ::WorkItems::Widgets::CurrentUserTodos => ::Types::WorkItems::Widgets::CurrentUserTodosType,
        ::WorkItems::Widgets::AwardEmoji => ::Types::WorkItems::Widgets::AwardEmojiType,
        ::WorkItems::Widgets::LinkedItems => ::Types::WorkItems::Widgets::LinkedItemsType,
        ::WorkItems::Widgets::Participants => ::Types::WorkItems::Widgets::ParticipantsType,
        ::WorkItems::Widgets::TimeTracking => ::Types::WorkItems::Widgets::TimeTracking::TimeTrackingType,
        ::WorkItems::Widgets::Designs => ::Types::WorkItems::Widgets::DesignsType,
        ::WorkItems::Widgets::Development => ::Types::WorkItems::Widgets::DevelopmentType,
        ::WorkItems::Widgets::CrmContacts => ::Types::WorkItems::Widgets::CrmContactsType,
        ::WorkItems::Widgets::EmailParticipants => ::Types::WorkItems::Widgets::EmailParticipantsType,
        ::WorkItems::Widgets::LinkedResources => ::Types::WorkItems::Widgets::LinkedResourcesType,
        ::WorkItems::Widgets::ErrorTracking => ::Types::WorkItems::Widgets::ErrorTrackingType
      }.freeze

      def self.type_mappings
        TYPE_MAPPINGS
      end

      def self.resolve_type(object, context)
        type_mappings[object.class] || raise("Unknown GraphQL type for widget #{object}")
      end

      orphan_types(*type_mappings.values)
    end
  end
end

Types::WorkItems::WidgetInterface.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/assignees_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class AssigneesInputType < BaseInputObject
        graphql_name 'WorkItemWidgetAssigneesInput'

        argument :assignee_ids, [::Types::GlobalIDType[::User]],
          required: true,
          description: 'Global IDs of assignees.',
          prepare: ->(ids, _) { ids.map(&:model_id) }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/assignees_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class AssigneesType < BaseObject
        graphql_name 'WorkItemWidgetAssignees'
        description 'Represents an assignees widget'

        implements ::Types::WorkItems::WidgetInterface

        field :assignees, ::Types::UserType.connection_type,
          null: true,
          method: :assignees_by_name_and_id,
          description: 'Assignees of the work item.'

        field :allows_multiple_assignees, GraphQL::Types::Boolean,
          null: true, method: :allows_multiple_assignees?,
          description: 'Indicates whether multiple assignees are allowed.',
          deprecated: {
            milestone: '16.7',
            replacement: 'workitemWidgetDefinitionAssignees.allowsMultipleAssignees',
            reason: 'Field moved to workItemType widget definition interface'
          }

        field :can_invite_members, GraphQL::Types::Boolean,
          null: false, resolver_method: :can_invite_members?,
          description: 'Indicates whether the current user can invite members to the work item\'s project.',
          deprecated: {
            milestone: '16.7',
            replacement: 'workitemWidgetDefinitionAssignees.canInviteMembers',
            reason: 'Field moved to workItemType widget definition interface'
          }

        def can_invite_members?
          Ability.allowed?(current_user, :invite_project_members, object.work_item.project)
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/award_emoji_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class AwardEmojiType < BaseObject
        graphql_name 'WorkItemWidgetAwardEmoji'
        description 'Represents the emoji reactions widget'

        implements ::Types::WorkItems::WidgetInterface

        field :award_emoji,
          ::Types::AwardEmojis::AwardEmojiType.connection_type,
          null: true,
          description: 'Emoji reactions on the work item.'
        field :downvotes,
          GraphQL::Types::Int,
          null: false,
          description: 'Number of downvotes the work item has received.'
        field :new_custom_emoji_path,
          GraphQL::Types::String,
          null: true,
          description: 'Path to create a new custom emoji.'
        field :upvotes,
          GraphQL::Types::Int,
          null: false,
          description: 'Number of upvotes the work item has received.'

        def downvotes
          BatchLoaders::AwardEmojiVotesBatchLoader
            .load_downvotes(object.work_item, awardable_class: 'Issue')
        end

        def upvotes
          BatchLoaders::AwardEmojiVotesBatchLoader
            .load_upvotes(object.work_item, awardable_class: 'Issue')
        end

        def new_custom_emoji_path
          return unless context[:current_user]

          object.new_custom_emoji_path(context[:current_user])
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end

Types::WorkItems::Widgets::AwardEmojiType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/award_emoji_update_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class AwardEmojiUpdateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetAwardEmojiUpdateInput'

        argument :action, ::Types::WorkItems::AwardEmojiUpdateActionEnum,
          required: true,
          description: 'Action for the update.'

        argument :name,
          GraphQL::Types::String,
          required: true,
          description: copy_field_description(Types::AwardEmojis::AwardEmojiType, :name)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/connections/closing_merge_requests_connection_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module Connections
        # rubocop: disable Graphql/AuthorizeTypes -- counts are looking up authorized data already
        class ClosingMergeRequestsConnectionType < GraphQL::Types::Relay::BaseConnection
          graphql_name 'ClosingMergeRequestsConnectionType'
          description 'Connection details for closing merge requests data'

          field :count,
            null: true,
            description: 'Number of merge requests that close the work item on merge.',
            resolver: Resolvers::MergeRequestsCountResolver
        end
        # rubocop: enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/crm_contacts_create_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class CrmContactsCreateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetCrmContactsCreateInput'

        argument :contact_ids,
          [::Types::GlobalIDType[::CustomerRelations::Contact]],
          required: true,
          description: 'CRM contact IDs to set.',
          prepare: ->(ids, _ctx) { ids.map { |gid| gid.model_id.to_i } }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/crm_contacts_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes -- reason above
      class CrmContactsType < BaseObject
        graphql_name 'WorkItemWidgetCrmContacts'
        description 'Represents CRM contacts widget'

        implements ::Types::WorkItems::WidgetInterface

        field :contacts,
          ::Types::CustomerRelations::ContactType.connection_type,
          null: true,
          description: 'Collection of CRM contacts associated with the work item.',
          method: :customer_relations_contacts

        field :contacts_available,
          GraphQL::Types::Boolean,
          null: false,
          description: 'Indicates whether contacts are available to be associated with the work item.'

        def contacts_available
          object.work_item.namespace.crm_group&.contacts&.exists? || false
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/crm_contacts_update_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class CrmContactsUpdateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetCrmContactsUpdateInput'

        argument :contact_ids,
          [::Types::GlobalIDType[::CustomerRelations::Contact]],
          required: true,
          description: 'CRM contact IDs to set. Replaces existing contacts by default.',
          prepare: ->(ids, _ctx) { ids.map { |gid| gid.model_id.to_i } }

        argument :operation_mode,
          ::Types::MutationOperationModeEnum,
          required: false,
          default_value: ::Types::MutationOperationModeEnum.default_mode,
          description: 'Set the operation mode.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/current_user_todos_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class CurrentUserTodosInputType < BaseInputObject
        graphql_name 'WorkItemWidgetCurrentUserTodosInput'

        argument :action, ::Types::WorkItems::TodoUpdateActionEnum,
          required: true,
          description: 'Action for the update.'

        argument :todo_id,
          ::Types::GlobalIDType[::Todo],
          required: false,
          description: "Global ID of the to-do. If not present, all to-dos of the work item will be updated.",
          prepare: ->(id, _) { id.model_id }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/current_user_todos_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class CurrentUserTodosType < BaseObject
        graphql_name 'WorkItemWidgetCurrentUserTodos'
        description 'Represents a todos widget'

        implements ::Types::WorkItems::WidgetInterface
        implements ::Types::CurrentUserTodos

        private

        # Overriden as `Types::CurrentUserTodos` relies on `unpresented` being the Issuable record.
        def unpresented
          object.work_item
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/description_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class DescriptionInputType < BaseInputObject
        graphql_name 'WorkItemWidgetDescriptionInput'

        argument :description, GraphQL::Types::String,
          required: true,
          description: copy_field_description(Types::WorkItemType, :description)
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/description_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class DescriptionType < BaseObject
        graphql_name 'WorkItemWidgetDescription'
        description 'Represents a description widget'

        implements ::Types::WorkItems::WidgetInterface

        field :description, GraphQL::Types::String,
          null: true,
          description: 'Description of the work item.'
        field :edited, GraphQL::Types::Boolean,
          null: false,
          description: 'Whether the description has been edited since the work item was created.',
          method: :edited?
        field :last_edited_at, ::Types::TimeType,
          null: true,
          description: 'Timestamp of when the work item\'s description was last edited.'
        field :last_edited_by, ::Types::UserType,
          null: true,
          description: 'User that made the last edit to the work item\'s description.'
        field :task_completion_status, ::Types::TaskCompletionStatus, null: false,
          description: 'Task completion status of the work item.'

        markdown_field :description_html, null: true, &:work_item
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/designs_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes -- reason above
      class DesignsType < BaseObject
        graphql_name 'WorkItemWidgetDesigns'
        description 'Represents designs widget'

        implements ::Types::WorkItems::WidgetInterface

        field :design_collection, ::Types::DesignManagement::DesignCollectionType, null: true,
          description: 'Collection of design images associated with the issue.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/development_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes -- reason above
      class DevelopmentType < BaseObject
        graphql_name 'WorkItemWidgetDevelopment'
        description 'Represents a development widget'

        implements ::Types::WorkItems::WidgetInterface

        field :closing_merge_requests,
          ::Types::WorkItems::ClosingMergeRequestType.connection_type,
          null: true,
          description: 'Merge requests that will close the work item when merged.',
          complexity: 10
        field :related_branches,
          ::Types::WorkItems::RelatedBranchType.connection_type,
          calls_gitaly: true,
          description: 'Branches that have referred to the work item, but do not have an associated merge request.',
          null: true,
          complexity: 10 do
            extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
          end
        field :related_merge_requests, # rubocop:disable GraphQL/ExtractType -- no need to extract to related
          ::Types::MergeRequestType.connection_type,
          null: true,
          resolver: ::Resolvers::MergeRequests::WorkItemRelatedResolver,
          description: 'Merge requests where the work item has been mentioned. ' \
            'This field can only be resolved for one work item in any single request.',
          experiment: { milestone: '17.6' },
          complexity: 10 do
            extension ::Gitlab::Graphql::Limit::FieldCallCount, limit: 1
          end
        field :will_auto_close_by_merge_request,
          GraphQL::Types::Boolean,
          null: false,
          description: 'Whether the work item will automatically be closed when a closing merge request is merged.',
          complexity: 1

        def related_branches
          return [] unless object.work_item.project

          ::Issues::RelatedBranchesService
            .new(container: object.work_item.project, current_user: current_user)
            .execute(object.work_item)
        end

        def closing_merge_requests
          if object.closing_merge_requests.loaded?
            object.closing_merge_requests
          else
            object.closing_merge_requests.preload_merge_request_for_authorization
          end
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end

Types::WorkItems::Widgets::DevelopmentType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/email_participants_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes -- reason above
      class EmailParticipantsType < BaseObject
        graphql_name 'WorkItemWidgetEmailParticipants'
        description 'Represents email participants widget'

        implements ::Types::WorkItems::WidgetInterface

        field :email_participants,
          ::Types::WorkItems::EmailParticipantType.connection_type,
          null: true,
          description: 'Collection of email participants associated with the work item.',
          method: :issue_email_participants
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/error_tracking/stack_trace_context_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module ErrorTracking
        # rubocop:disable Graphql/AuthorizeTypes -- we already authorize the work item itself
        class StackTraceContextType < BaseObject
          graphql_name 'WorkItemWidgetErrorTrackingStackTraceContext'
          description 'Represents details about a line of code of the stack trace'

          field :line_number, GraphQL::Types::Int,
            null: true,
            description: 'Line number of code.', method: :first

          field :line, GraphQL::Types::String,
            null: true,
            description: 'Line of code.', method: :last
        end
        # rubocop:enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/error_tracking/stack_trace_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module ErrorTracking
        # Disabling widget level authorization as it might be too granular
        # and we already authorize the parent work item
        # rubocop:disable Graphql/AuthorizeTypes -- reason above
        class StackTraceType < BaseObject
          graphql_name 'ErrorTrackingStackTrace'
          description 'Represents a stack trace'

          connection_type_class Types::CountableConnectionType

          field :filename, GraphQL::Types::String,
            null: true,
            description: 'Filename of the stack trace.'

          field :absolute_path, GraphQL::Types::String,
            null: true,
            description: 'Absolute path of the stack trace.', hash_key: "absPath"

          field :function, GraphQL::Types::String,
            null: true,
            description: 'Name of the function where the error occured.'

          field :line_number, GraphQL::Types::Int,
            null: true,
            description: 'Line number of the stack trace.', hash_key: "lineNo"

          field :column_number, GraphQL::Types::Int,
            null: true,
            description: 'Column number of the stack trace.', hash_key: "colNo"

          field :context, [Types::WorkItems::Widgets::ErrorTracking::StackTraceContextType],
            null: true,
            description: 'Context of the stack trace.', hash_key: "context"
        end
        # rubocop:enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/error_tracking_status_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class ErrorTrackingStatusEnum < BaseEnum
        graphql_name 'ErrorTrackingStatus'
        description 'Status of the error tracking service'

        value 'SUCCESS', value: :success, description: 'Successfuly fetch the stack trace.'
        value 'ERROR', value: :error, description: 'Error tracking service respond with an error.'
        value 'NOT_FOUND', value: :not_found, description: 'Sentry issue not found.'
        value 'RETRY', value: :retry, description: 'Error tracking service is not ready.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/error_tracking_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes -- reason above
      class ErrorTrackingType < BaseObject
        graphql_name 'WorkItemWidgetErrorTracking'
        description 'Represents the error tracking widget'

        implements ::Types::WorkItems::WidgetInterface

        field :identifier, GraphQL::Types::BigInt, null: true,
          description: 'Error tracking issue id.' \
            'This field can only be resolved for one work item in any single request.',
          method: :sentry_issue_identifier do
            extension(::Gitlab::Graphql::Limit::FieldCallCount, limit: 1)
          end

        field :stack_trace, ::Types::WorkItems::Widgets::ErrorTracking::StackTraceType.connection_type,
          null: true,
          description: 'Stack trace details of the error.' \
            'This field can only be resolved for one work item in any single request.' do
          extension(::Gitlab::Graphql::Limit::FieldCallCount, limit: 1)
        end

        field :status, ErrorTrackingStatusEnum, null: true,
          description: 'Response status of error service.' \
            'This field can only be resolved for one work item in any single request.' do
              extension(::Gitlab::Graphql::Limit::FieldCallCount, limit: 1)
            end

        def stack_trace
          return [] if object.sentry_issue_identifier.nil?

          if latest_event_result[:status] == :success
            Gitlab::ErrorTracking::StackTraceHighlightDecorator
              .decorate(latest_event_result[:latest_event])
              .stack_trace_entries
          else
            []
          end
        end

        def status
          return :not_found if object.sentry_issue_identifier.nil?

          if latest_event_result[:status] == :success
            :success
          elsif latest_event_result[:http_status] == :no_content
            :retry
          else
            :error
          end
        end

        private

        def latest_event_result
          @latest_event ||= ::ErrorTracking::IssueLatestEventService
            .new(object.work_item.project, current_user, issue_id: object.sentry_issue_identifier)
            .execute
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/hierarchy_create_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class HierarchyCreateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetHierarchyCreateInput'

        argument :parent_id, ::Types::GlobalIDType[::WorkItem],
          required: false,
          loads: ::Types::WorkItemType,
          description: 'Global ID of the parent work item.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/hierarchy_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class HierarchyType < BaseObject
        graphql_name 'WorkItemWidgetHierarchy'
        description 'Represents a hierarchy widget'

        implements ::Types::WorkItems::WidgetInterface

        field :parent, ::Types::WorkItemType,
          null: true, complexity: 5,
          description: 'Parent work item.'

        field :children, ::Types::WorkItemType.connection_type,
          null: true, complexity: 5,
          description: 'Child work items.',
          resolver: Resolvers::WorkItems::ChildrenResolver,
          skip_type_authorization: [:read_work_item]

        field :ancestors, ::Types::WorkItemType.connection_type,
          null: true, complexity: 5,
          description: 'Ancestors (parents) of the work item.',
          extras: [:lookahead],
          resolver: Resolvers::WorkItems::AncestorsResolver,
          skip_type_authorization: [:read_work_item]

        field :has_children, GraphQL::Types::Boolean,
          null: false, description: 'Indicates if the work item has children.'

        field :has_parent, GraphQL::Types::Boolean,
          null: false, method: :has_parent?, description: 'Indicates if the work item has a parent.'

        field :rolled_up_counts_by_type, [::Types::WorkItems::WorkItemTypeCountsByStateType],
          null: false, description: 'Counts of descendant work items by work item type and state.',
          experiment: { milestone: '17.3' }

        field :depth_limit_reached_by_type, [::Types::WorkItems::WorkItemTypeDepthLimitReachedByType],
          null: false, description: 'Depth limit reached by allowed work item type.',
          experiment: { milestone: '17.4' }

        # rubocop: disable CodeReuse/ActiveRecord
        def has_children?
          BatchLoader::GraphQL.for(object.work_item.id).batch(default_value: false) do |ids, loader|
            links_for_parents = ::WorkItems::ParentLink.for_parents(ids)
                                           .select(:work_item_parent_id)
                                           .group(:work_item_parent_id)
                                           .without_order

            links_for_parents.each { |link| loader.call(link.work_item_parent_id, true) }
          end
        end
        # rubocop: enable CodeReuse/ActiveRecord

        alias_method :has_children, :has_children?
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/hierarchy_update_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class HierarchyUpdateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetHierarchyUpdateInput'

        argument :adjacent_work_item_id,
          ::Types::GlobalIDType[::WorkItem],
          required: false,
          loads: ::Types::WorkItemType,
          description: 'ID of the work item to be switched with.'

        argument :children_ids, [::Types::GlobalIDType[::WorkItem]],
          required: false,
          description: 'Global IDs of children work items.',
          loads: ::Types::WorkItemType,
          as: :children

        argument :parent_id, ::Types::GlobalIDType[::WorkItem],
          required: false,
          loads: ::Types::WorkItemType,
          description: 'Global ID of the parent work item. Use `null` to remove the association.'

        argument :relative_position,
          ::Types::RelativePositionTypeEnum,
          required: false,
          description: 'Type of switch. Valid values are `BEFORE` or `AFTER`.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/labels_create_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class LabelsCreateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetLabelsCreateInput'

        argument :label_ids, [::Types::GlobalIDType[::Label]],
          required: true,
          description: 'IDs of labels to be added to the work item.',
          prepare: ->(label_ids, _ctx) { label_ids.map(&:model_id) }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/labels_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class LabelsType < BaseObject
        graphql_name 'WorkItemWidgetLabels'
        description 'Represents the labels widget'

        implements ::Types::WorkItems::WidgetInterface

        field :labels, ::Types::LabelType.connection_type,
          null: true,
          description: 'Labels assigned to the work item.',
          skip_type_authorization: [:read_label],
          resolver: Resolvers::BulkLabelsResolver

        field :allows_scoped_labels, GraphQL::Types::Boolean,
          null: true,
          method: :allows_scoped_labels?,
          description: 'Indicates whether a scoped label is allowed.',
          deprecated: {
            milestone: '16.7',
            replacement: 'WorkItemWidgetDefinitionLabels.allowsScopedLabels',
            reason: 'Field moved to workItemType widget definition interface'
          }
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/labels_update_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class LabelsUpdateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetLabelsUpdateInput'

        argument :add_label_ids, [::Types::GlobalIDType[::Label]],
          required: false,
          description: 'Global IDs of labels to be added to the work item.',
          prepare: ->(label_ids, _ctx) { label_ids.map(&:model_id) }
        argument :remove_label_ids, [::Types::GlobalIDType[::Label]],
          required: false,
          description: 'Global IDs of labels to be removed from the work item.',
          prepare: ->(label_ids, _ctx) { label_ids.map(&:model_id) }
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/linked_items_create_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class LinkedItemsCreateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetLinkedItemsCreateInput'

        MAX_WORK_ITEMS = 10
        ERROR_MESSAGE = "No more than #{MAX_WORK_ITEMS} work items can be linked at the same time.".freeze

        argument :link_type, ::Types::WorkItems::RelatedLinkTypeEnum,
          required: false, description: 'Type of link. Defaults to `RELATED`.'
        argument :work_items_ids, [::Types::GlobalIDType[::WorkItem]],
          description: "Global IDs of the items to link. Maximum number of IDs you can provide: #{MAX_WORK_ITEMS}.",
          required: true,
          prepare: ->(ids, _ctx) do
            raise Gitlab::Graphql::Errors::ArgumentError, ERROR_MESSAGE if ids.size > MAX_WORK_ITEMS

            ids.map { |gid| gid.model_id.to_i }
          end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/linked_items_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # rubocop:disable Graphql/AuthorizeTypes
      class LinkedItemsType < BaseObject
        graphql_name 'WorkItemWidgetLinkedItems'
        description 'Represents the linked items widget'

        implements ::Types::WorkItems::WidgetInterface

        field :linked_items, ::Types::WorkItems::LinkedItemType.connection_type,
          null: true, complexity: 5,
          experiment: { milestone: '16.3' },
          extras: [:lookahead],
          description: 'Linked items for the work item.',
          resolver: Resolvers::WorkItems::LinkedItemsResolver
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end

Types::WorkItems::Widgets::LinkedItemsType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/linked_resources_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes -- reason above
      class LinkedResourcesType < BaseObject
        graphql_name 'WorkItemWidgetLinkedResources'
        description 'Represents the linked resources widget'

        implements ::Types::WorkItems::WidgetInterface

        # linked_resources currently exposes zoom_meetings records associated with the work item.
        # The plan is to make this field more generic in the future as we already have another source
        # of linked_resources associated with the issues table. More details in
        # https://gitlab.com/gitlab-org/gitlab/-/merge_requests/174793#note_2256696898
        field :linked_resources,
          ::Types::WorkItems::LinkedResourceType.connection_type,
          null: true,
          description: 'Resources for the work item.',
          method: :zoom_meetings
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/milestone_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class MilestoneInputType < BaseInputObject
        graphql_name 'WorkItemWidgetMilestoneInput'

        argument :milestone_id,
          ::Types::GlobalIDType[::Milestone],
          required: :nullable,
          prepare: ->(id, _) { id.model_id unless id.nil? },
          description: 'Milestone to assign to the work item.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/milestone_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class MilestoneType < BaseObject
        graphql_name 'WorkItemWidgetMilestone'
        description 'Represents a milestone widget'

        implements ::Types::WorkItems::WidgetInterface

        field :milestone,
          ::Types::MilestoneType,
          skip_type_authorization: [:read_milestone],
          null: true,
          description: 'Milestone of the work item.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/notes_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class NotesInputType < BaseInputObject
        graphql_name 'WorkItemWidgetNotesInput'

        argument :discussion_locked, GraphQL::Types::Boolean,
          required: true,
          description: 'Discussion lock attribute for notes widget of the work item.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/notes_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class NotesType < BaseObject
        graphql_name 'WorkItemWidgetNotes'
        description 'Represents a notes widget'

        implements ::Types::WorkItems::WidgetInterface

        def self.authorization_scopes
          super + [:ai_workflows]
        end

        field :discussion_locked, GraphQL::Types::Boolean,
          null: true,
          description: 'Discussion lock attribute of the work item.'

        # This field loads user comments, system notes and resource events as a discussion for an work item,
        # raising the complexity considerably. In order to discourage fetching this field as part of fetching
        # a list of issues we raise the complexity
        field :discussions, ::Types::Notes::DiscussionType.connection_type,
          null: true,
          skip_type_authorization: [:read_note, :read_emoji],
          description: "Discussions on this work item.",
          resolver: Resolvers::WorkItems::WorkItemDiscussionsResolver,
          connection_extension: Gitlab::Graphql::Extensions::ForwardOnlyExternallyPaginatedArrayExtension
        field :notes, ::Types::Notes::NoteType.connection_type,
          scopes: [:api, :read_api, :ai_workflows],
          null: false,
          description: "Notes on this work item.",
          resolver: Resolvers::Noteable::NotesResolver
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/notifications_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      # rubocop:disable Graphql/AuthorizeTypes
      class NotificationsType < BaseObject
        graphql_name 'WorkItemWidgetNotifications'
        description 'Represents the notifications widget'

        implements ::Types::WorkItems::WidgetInterface

        field :subscribed, GraphQL::Types::Boolean,
          null: false,
          description: 'Whether the current user is subscribed to notifications on the work item.'

        def subscribed
          object.work_item.subscribed?(current_user, object.work_item.project, cache_enforced: false)
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/notifications_update_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class NotificationsUpdateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetNotificationsUpdateInput'

        argument :subscribed,
          GraphQL::Types::Boolean,
          required: true,
          description: 'Desired state of the subscription.'
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/participants_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # Disabling widget level authorization as we scope by `.visible_participants`
      # rubocop:disable Graphql/AuthorizeTypes -- see above
      class ParticipantsType < BaseObject
        graphql_name 'WorkItemWidgetParticipants'
        description 'Represents a participants widget'

        implements ::Types::WorkItems::WidgetInterface

        field :participants, ::Types::UserType.connection_type,
          null: true,
          description: 'Participants in the work item.'

        def participants
          object.visible_participants(current_user)
        end
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/start_and_due_date_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      # rubocop:disable Graphql/AuthorizeTypes -- Disabling widget level authorization as it might be too granular
      # and we already authorize the parent work item
      class StartAndDueDateType < BaseObject
        graphql_name 'WorkItemWidgetStartAndDueDate'
        description 'Represents a start and due date widget'

        implements ::Types::WorkItems::WidgetInterface

        field :due_date,
          ::Types::DateType,
          null: true,
          description: 'Due date of the work item.'

        field :start_date,
          ::Types::DateType,
          null: true,
          description: 'Start date of the work item.'

        field :roll_up,
          ::GraphQL::Types::Boolean,
          method: :can_rollup?,
          null: false,
          description: 'Indicates if the work item can use rolled up dates.'
      end
      # rubocop:enable Graphql/AuthorizeTypes
    end
  end
end
Types::WorkItems::Widgets::StartAndDueDateType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/start_and_due_date_update_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      class StartAndDueDateUpdateInputType < BaseInputObject
        graphql_name 'WorkItemWidgetStartAndDueDateUpdateInput'

        argument :due_date,
          ::Types::DateType,
          required: false,
          description: 'Due date for the work item.'

        argument :start_date,
          ::Types::DateType,
          required: false,
          description: 'Start date for the work item.'
      end
    end
  end
end
Types::WorkItems::Widgets::StartAndDueDateUpdateInputType.prepend_mod


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/time_tracking/human_readable_attributes_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module TimeTracking
        # rubocop:disable Graphql/AuthorizeTypes -- we already authorize the work item itself
        class HumanReadableAttributesType < BaseObject
          graphql_name 'WorkItemWidgetTimeTrackingHumanReadableAttributes'
          description 'Represents a time tracking human readable attributes'

          field :time_estimate, GraphQL::Types::String,
            null: true, method: :human_time_estimate,
            description: 'Human-readable time estimate of the work item.'
          field :total_time_spent, GraphQL::Types::String,
            null: true, method: :human_total_time_spent,
            description: 'Human-readable total time reported as spent on the work item.'
        end
        # rubocop:enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/time_tracking/timelog_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module TimeTracking
        class TimelogInputType < BaseInputObject
          graphql_name 'WorkItemWidgetTimeTrackingTimelogInput'

          argument :time_spent, GraphQL::Types::String,
            required: true,
            description: 'Amount of time spent in human readable format. For example: 1h 30m.'

          argument :spent_at, ::Types::TimeType,
            required: false,
            description: 'Timestamp of when the time tracked was spent at, ' \
              'if not provided would be set to current timestamp.'

          argument :summary, GraphQL::Types::String,
            required: false,
            description: 'Summary of how the time was spent.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/time_tracking/timelog_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module TimeTracking
        # rubocop:disable Graphql/AuthorizeTypes -- we already authorize the work item itself
        class TimelogType < BaseObject
          graphql_name 'WorkItemTimelog'

          connection_type_class ::Types::TimeTracking::TimelogConnectionType
          expose_permissions ::Types::PermissionTypes::Timelog

          field :id, GraphQL::Types::ID,
            null: false,
            description: 'Internal ID of the timelog.'

          field :spent_at, ::Types::TimeType,
            null: true,
            description: 'Timestamp of when the time tracked was spent at.'

          field :time_spent, GraphQL::Types::Int,
            null: false,
            description: 'Time spent displayed in seconds.'

          field :user, ::Types::UserType,
            null: false,
            description: 'User that logged the time.'

          field :note, ::Types::Notes::NoteType,
            null: true,
            description: 'Note where the quick action was executed to add the logged time.'

          field :summary, GraphQL::Types::String,
            null: true,
            description: 'Summary of how the time was spent.'

          def user
            Gitlab::Graphql::Loaders::BatchModelLoader.new(
              User, object.user_id, default_value: ::Users::Internal.ghost
            ).find
          end

          def spent_at
            object.spent_at || object.created_at
          end
        end
        # rubocop:enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/time_tracking/time_tracking_input_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module TimeTracking
        class TimeTrackingInputType < BaseInputObject
          graphql_name 'WorkItemWidgetTimeTrackingInput'

          argument :time_estimate, GraphQL::Types::String,
            required: false,
            description: 'Time estimate for the work item in human readable format. For example: 1h 30m.'

          argument :timelog, ::Types::WorkItems::Widgets::TimeTracking::TimelogInputType,
            required: false,
            description: 'Timelog data for time spent on the work item.'
        end
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widgets/time_tracking/time_tracking_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    module Widgets
      module TimeTracking
        # rubocop:disable Graphql/AuthorizeTypes -- we already authorize the work item itself
        class TimeTrackingType < BaseObject
          graphql_name 'WorkItemWidgetTimeTracking'
          description 'Represents the time tracking widget on the work item'

          implements ::Types::WorkItems::WidgetInterface

          field :human_readable_attributes, ::Types::WorkItems::Widgets::TimeTracking::HumanReadableAttributesType,
            null: true, resolver_method: :object,
            description: 'Human-readable attributes of the work item.'

          field :time_estimate, GraphQL::Types::Int,
            null: true,
            description: 'Time estimate of the work item.'
          field :total_time_spent, GraphQL::Types::Int,
            null: true,
            description: 'Total time (in seconds) reported as spent on the work item.'

          field :timelogs, ::Types::WorkItems::Widgets::TimeTracking::TimelogType.connection_type,
            null: true,
            description: 'Timelogs on the work item.'
        end
        # rubocop:enable Graphql/AuthorizeTypes
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/widget_type_enum.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    class WidgetTypeEnum < BaseEnum
      graphql_name 'WorkItemWidgetType'
      description 'Type of a work item widget'

      ::WorkItems::WidgetDefinition.widget_classes.each do |cls|
        value cls.type.to_s.upcase, value: cls.type, description: "#{cls.type.to_s.titleize} widget."
      end
    end
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/work_item_type_counts_by_state_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    # rubocop: disable Graphql/AuthorizeTypes -- Parent node applies authorization
    class WorkItemTypeCountsByStateType < BaseObject
      graphql_name 'WorkItemTypeCountsByState'
      description 'Represents work item counts for the work item type'

      field :work_item_type, ::Types::WorkItems::TypeType, null: false,
        description: 'Work item type.'

      field :counts_by_state, ::Types::WorkItemStateCountsType, null: false,
        description: 'Total number of work items for the represented states.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_items/work_item_type_depth_limit_reached_by_type.rb =====
# frozen_string_literal: true

module Types
  module WorkItems
    # rubocop: disable Graphql/AuthorizeTypes -- Parent node applies authorization
    class WorkItemTypeDepthLimitReachedByType < BaseObject
      graphql_name 'WorkItemTypeDepthLimitReachedByType'
      description 'Represents Depth limit reached for the allowed work item type.'

      field :work_item_type, ::Types::WorkItems::TypeType, null: false,
        description: 'Work item type.'

      field :depth_limit_reached, GraphQL::Types::Boolean,
        null: false,
        description: 'Indicates if maximum allowed depth has been reached for the descendant type.'
    end
    # rubocop: enable Graphql/AuthorizeTypes
  end
end


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/work_item_type.rb =====
# frozen_string_literal: true

module Types
  class WorkItemType < BaseObject
    graphql_name 'WorkItem'

    include ::IssuablesHelper

    implements Types::TodoableInterface
    connection_type_class Types::CountableConnectionType

    authorize :read_work_item

    def self.authorization_scopes
      super + [:ai_workflows]
    end

    present_using WorkItemPresenter
    expose_permissions Types::PermissionTypes::WorkItem

    field :author, Types::UserType, null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'User that created the work item.',
      experiment: { milestone: '15.9' }
    field :closed_at, Types::TimeType, null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Timestamp of when the work item was closed.'
    field :confidential, GraphQL::Types::Boolean, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Indicates the work item is confidential.'
    field :created_at, Types::TimeType, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Timestamp of when the work item was created.'
    field :description, GraphQL::Types::String, null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Description of the work item.'
    field :id, Types::GlobalIDType[::WorkItem], null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Global ID of the work item.'
    field :iid, GraphQL::Types::String, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Internal ID of the work item.'
    field :imported, GraphQL::Types::Boolean, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      method: :imported?,
      description: 'Indicates whether the work item was imported.'
    field :lock_version,
      GraphQL::Types::Int,
      null: false,
      description: 'Lock version of the work item. Incremented each time the work item is updated.'
    field :namespace, Types::NamespaceType, null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Namespace the work item belongs to.',
      skip_type_authorization: [:read_namespace],
      experiment: { milestone: '15.10' }
    field :project, Types::ProjectType, null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Project the work item belongs to.',
      skip_type_authorization: [:read_project],
      experiment: { milestone: '15.3' }
    field :state, WorkItemStateEnum, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'State of the work item.'
    field :title, GraphQL::Types::String, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Title of the work item.'
    field :updated_at, Types::TimeType, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Timestamp of when the work item was last updated.'

    field :create_note_email, GraphQL::Types::String,
      null: true,
      description: 'User specific email address for the work item.'
    field :user_discussions_count, GraphQL::Types::Int, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Number of user discussions in the work item.',
      resolver: Resolvers::UserDiscussionsCountResolver

    field :reference, GraphQL::Types::String, null: false,
      description: 'Internal reference of the work item. Returned in shortened format by default.',
      method: :to_reference do
      argument :full, GraphQL::Types::Boolean, required: false, default_value: false,
        description: 'Boolean option specifying whether the reference should be returned in full.'
    end

    field :widgets,
      [Types::WorkItems::WidgetInterface],
      null: true,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Collection of widgets that belong to the work item.' do
      argument :except_types, [::Types::WorkItems::WidgetTypeEnum],
        required: false,
        default_value: nil,
        description: 'Except widgets of the given types.'
      argument :only_types, [::Types::WorkItems::WidgetTypeEnum],
        required: false,
        default_value: nil,
        description: 'Only widgets of the given types.'

      validates mutually_exclusive: %i[except_types only_types]
    end

    field :work_item_type, Types::WorkItems::TypeType, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Type assigned to the work item.'

    field :archived, GraphQL::Types::Boolean, null: false,
      scopes: [:api, :read_api, :ai_workflows],
      description: 'Whether the work item belongs to an archived project. Always false for group level work items.',
      experiment: { milestone: '16.5' }

    field :comment_templates_paths, [Types::WorkItems::CommentTemplatePathType], null: false,
      description: 'Paths of the comment templates.'
    field :duplicated_to_work_item_url, GraphQL::Types::String, null: true,
      description: 'URL of the work item that the work item is marked as a duplicate of.'
    field :moved_to_work_item_url, GraphQL::Types::String, null: true,
      description: 'URL of the work item that the work item was moved to.'
    field :show_plan_upgrade_promotion, GraphQL::Types::Boolean, null: false,
      description: 'Whether to show the promotional message for the work item.',
      experiment: { milestone: '17.11' }

    field :hidden, GraphQL::Types::Boolean, null: true,
      method: :hidden?,
      description: 'Indicates the work item is hidden because the author has been banned.'

    markdown_field :title_html, null: true
    markdown_field :description_html, null: true

    def work_item_type
      context.scoped_set!(:resource_parent, object.resource_parent)

      object.work_item_type
    end

    def comment_templates_paths
      new_comment_template_paths(object.namespace.group_namespace? ? object.namespace : object.project.group,
        object.project)
    end

    def create_note_email
      object.creatable_note_email_address(context[:current_user])
    end

    def archived
      return false if object.project.blank?

      object.project.archived?
    end

    def show_plan_upgrade_promotion
      # It should be true for namespaces in free plan.
      # As we don't have a direct way to check that. We can check if the licensed feature for epics is enabled,
      # which is a premium and ultimate feature.
      !object.namespace.licensed_feature_available?(:epics)
    end
  end
end

Types::WorkItemType.prepend_mod_with('Types::WorkItemType')


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/x509_certificate_type.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/AuthorizeTypes

module Types
  class X509CertificateType < Types::BaseObject
    graphql_name 'X509Certificate'
    description 'Represents an X.509 certificate.'

    field :certificate_status, GraphQL::Types::String,
      null: false,
      description: 'Indicates if the certificate is good or revoked.'

    field :created_at, Types::TimeType, null: false,
      description: 'Timestamp of when the certificate was saved.'

    field :email, GraphQL::Types::String, null: false,
      description: 'Email associated with the cerificate.'

    field :id, GraphQL::Types::ID, null: false, description: 'ID of the certificate.'

    field :serial_number, GraphQL::Types::String, null: false,
      description: 'Serial number of the certificate.'

    field :subject, GraphQL::Types::String, null: false, description: 'Subject of the certificate.'

    field :subject_key_identifier, GraphQL::Types::String,
      null: false,
      description: 'Subject key identifier of the certificate.'

    field :updated_at, Types::TimeType, null: false,
      description: 'Timestamp of when the certificate was last updated.'

    field :x509_issuer, Types::X509IssuerType, null: false,
      description: 'Issuer of the certificate.'
  end
end

# rubocop:enable Graphql/AuthorizeTypes


===== FILE: /workspace/gitlab-org-gitlab/app/graphql/types/x509_issuer_type.rb =====
# frozen_string_literal: true

# rubocop:disable Graphql/AuthorizeTypes

module Types
  class X509IssuerType < Types::BaseObject
    graphql_name 'X509Issuer'
    description 'Issuer of an X.509 certificate.'

    field :created_at, Types::TimeType, null: true,
      description: 'Timestamp of when the issuer was created.'

    field :crl_url, GraphQL::Types::String, null: true,
      description: 'Certificate revokation list of the issuer.'

    field :id, GraphQL::Types::ID, null: true, description: 'ID of the issuer.'

    field :subject, GraphQL::Types::String, null: true, description: 'Subject of the issuer.'

    field :subject_key_identifier, GraphQL::Types::String,
      null: true,
      description: 'Subject key identifier of the issuer.'

    field :updated_at, Types::TimeType, null: true,
      description: 'Timestamp of when the issuer was last updated.'
  end
end

# rubocop:enable Graphql/AuthorizeTypes


